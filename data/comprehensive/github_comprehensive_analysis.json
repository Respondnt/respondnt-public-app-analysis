{
  "application_name": "GitHub",
  "initial_access": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Valid Accounts",
        "technique_stix_id": "b17a1a56-e99c-403c-8948-561df0cffe81",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Connect to GitHub from an IP address that falls within the target enterprise’s configured allowlisted ranges so that web and API traffic is not blocked.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Identity & Authentication Service",
              "API Gateway & REST Layer"
            ],
            "related_interfaces": [
              "Web UI: General GitHub access and login flows (referenced in Get started docs) – https://docs.github.com/en/get-started"
            ],
            "related_data": [
              "IP addresses and session metadata evaluated against the organization’s IP allowlist",
              "Session and device verification metadata recorded in account security logs"
            ],
            "notes": "IP Allowlisting constraint requires the attacker to originate traffic from an approved network (for example, via a compromised VPN, proxy, or on-prem host)."
          },
          {
            "step_id": 2,
            "description": "Browse to the enterprise’s GitHub SSO sign-in flow and initiate SAML/OIDC-based login for the compromised user identity.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Identity & Authentication Service"
            ],
            "related_interfaces": [
              "Enterprise IAM configuration and SSO docs – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam",
              "User authentication and account security settings docs – https://docs.github.com/en/authentication"
            ],
            "related_data": [
              "SSO configuration metadata (SAML/OIDC settings) for the enterprise account",
              "Mapping between IdP identities and GitHub enterprise/organization accounts"
            ],
            "notes": "The SSO-Only Authentication constraint means all interactive logins go through the IdP; there is no fallback to local GitHub passwords."
          },
          {
            "step_id": 3,
            "description": "Authenticate to the external IdP as the compromised user (including satisfying MFA), causing the IdP to issue a valid SAML/OIDC assertion for GitHub.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Identity & Authentication Service"
            ],
            "related_interfaces": [
              "Enterprise IAM management and SAML/OIDC integration docs – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
            ],
            "related_data": [
              "User credentials and MFA secrets at the IdP (outside GitHub)",
              "SAML/OIDC assertions presented to GitHub for SSO",
              "Account-level security logs recording successful SSO events"
            ],
            "notes": "MFA Required and SSO-Only Authentication force the attacker to control both primary credentials and the second factor (or a valid SSO session) at the IdP."
          },
          {
            "step_id": 4,
            "description": "Upon successful SSO, allow GitHub to establish an authenticated web session for the compromised user and reuse that session to access private organizations, repositories, issues, and other resources the account can see.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Organizations & Enterprise Admin Service"
            ],
            "related_interfaces": [
              "Organization settings and membership UI – https://docs.github.com/en/organizations",
              "Repositories UI – https://docs.github.com/en/repositories",
              "REST API index – https://docs.github.com/en/rest"
            ],
            "related_data": [
              "User identities and account metadata associated with the compromised user",
              "Organization membership and roles for that user",
              "Private repositories and repository metadata accessible to that user",
              "Issues, pull requests, projects, security alerts, and other tenant data within the user’s scope"
            ],
            "notes": "From GitHub’s perspective this is a normal, fully authenticated session using a valid account; no additional exploitation is required beyond using the stolen identity."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "Identity & Authentication Service",
          "Organizations & Enterprise Admin Service"
        ],
        "interfaces_used": [
          "Web UI: General GitHub access and login – https://docs.github.com/en/get-started",
          "Enterprise SSO/IAM configuration and SAML/OIDC docs – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam",
          "User account security settings UI – https://docs.github.com/en/authentication",
          "Organization settings UI – https://docs.github.com/en/organizations",
          "Repositories UI – https://docs.github.com/en/repositories",
          "REST API index – https://docs.github.com/en/rest"
        ],
        "data_accessed": [
          "User identities and account metadata for the compromised account",
          "Enterprise organizations and their settings visible to that account",
          "Private repositories, code, issues, pull requests, projects, and security data within the user’s existing permissions",
          "Account-level security logs reflecting sign-in and session activity"
        ],
        "preconditions_required": [
          "Attacker has already obtained valid SSO credentials for a target enterprise user whose identity is federated into GitHub (for example via SAML/OIDC).",
          "Attacker can satisfy MFA for that identity (e.g., stolen OTPs, compromised authenticator, session hijack), due to prior compromise outside GitHub.",
          "The enterprise account is configured for SSO-only authentication (no local passwords), and the compromised identity is still active and mapped to a GitHub user.",
          "Attacker can originate traffic from IP ranges that pass the target’s GitHub IP allowlist.",
          "The compromised account has at least some non-public access within the target tenant (organizations/repositories)."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "IP Allowlisting",
          "Rate Limiting"
        ],
        "evasion_considerations": [
          "Log in from IP ranges, geolocations, and time windows that are consistent with the victim’s typical usage to avoid anomaly-based detection.",
          "Avoid repeated failed login attempts that would trigger rate limiting, CAPTCHAs, or security alerts; use the already-compromised credentials directly.",
          "Use the web UI and REST API in patterns similar to a developer or admin (for example, code browsing, limited cloning) rather than bulk scraping, to blend with normal activity.",
          "Prefer reusing existing SSO sessions (e.g., via stolen browser cookies or device compromise) to minimize visible new login events."
        ],
        "resulting_access": "Fully authenticated GitHub web session and API access under a legitimate enterprise user account, with all existing organization and repository permissions of that identity.",
        "comments": "This vector represents classic account takeover in a SAML/SSO-enforced GitHub Enterprise Cloud environment: once IdP credentials and MFA are compromised, GitHub’s own controls treat the attacker as a legitimate user (Valid Accounts)."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Accounts",
        "technique_stix_id": "f232fa7a-025c-4d43-abc7-318e81a73d65",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use compromised administrator access to the enterprise IdP or SCIM integration to create a new identity that is allowed to authenticate to GitHub (for example, an Enterprise Managed User with the target email domain and group memberships mapped to GitHub organizations).",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Identity & Authentication Service",
              "Organizations & Enterprise Admin Service"
            ],
            "related_interfaces": [
              "Enterprise IAM and EMU/SCIM configuration docs – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
            ],
            "related_data": [
              "IdP/SCIM configuration linking external identities and groups to GitHub Enterprise Managed Users and organizations",
              "Newly created identity records at the IdP and in SCIM payloads"
            ],
            "notes": "Domain-Based Registration and Admin Approval Required are effectively enforced at the IdP/SCIM layer; with IdP admin control the attacker can bypass these protections by directly provisioning identities."
          },
          {
            "step_id": 2,
            "description": "Allow the IdP/SCIM integration to automatically provision the new cloud account into GitHub as an Enterprise Managed User and place it into the mapped organizations and teams.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration",
              "Identity & Authentication Service"
            ],
            "related_interfaces": [
              "Enterprise admin UI for managing organizations and IAM – https://docs.github.com/en/enterprise-cloud@latest/admin",
              "Organization settings docs – https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "Enterprise account metadata and organization list",
              "Enterprise Managed User accounts created for the new identity",
              "Organization membership, team assignments, and base permissions granted through IAM mappings"
            ],
            "notes": "This step may be entirely automated once group-to-org mappings are in place; from GitHub’s perspective a legitimate new enterprise user has been created and assigned memberships."
          },
          {
            "step_id": 3,
            "description": "From an allowlisted IP, perform the initial SSO login as the newly provisioned cloud account and complete any first-time setup, including registering MFA devices if required.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Identity & Authentication Service",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "User authentication and MFA configuration docs – https://docs.github.com/en/authentication",
              "Enterprise IAM SSO docs – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
            ],
            "related_data": [
              "New account’s authentication factors (MFA devices, recovery codes)",
              "Account-level security logs recording first login and MFA setup events"
            ],
            "notes": "Because the attacker controls the identity from creation, MFA Required and Email Verification Required do not prevent this login—they are completed legitimately by the attacker-owned account."
          },
          {
            "step_id": 4,
            "description": "Use the authenticated session of the rogue Enterprise Managed User to access the organizations, repositories, and other resources assigned via the IdP/SCIM group mappings.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Organizations & Enterprise Admin Service"
            ],
            "related_interfaces": [
              "Organization settings and membership UI – https://docs.github.com/en/organizations",
              "Repositories UI – https://docs.github.com/en/repositories",
              "REST API index – https://docs.github.com/en/rest"
            ],
            "related_data": [
              "Organization membership and team assignments for the rogue account",
              "Private repositories and repository metadata made accessible to that account",
              "Issues, pull requests, projects, and security data within the mapped organizations"
            ],
            "notes": "This is initial access from the perspective of each affected organization or enterprise tenant: the attacker has introduced a new, apparently legitimate cloud account under their control."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organization & Team Administration",
          "GitHub REST API",
          "Identity & Authentication Service",
          "Organizations & Enterprise Admin Service",
          "Identity Providers (IdPs)"
        ],
        "interfaces_used": [
          "Enterprise IAM and EMU/SCIM configuration – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam",
          "Enterprise admin settings UI – https://docs.github.com/en/enterprise-cloud@latest/admin",
          "Organization settings UI – https://docs.github.com/en/organizations",
          "User authentication and MFA configuration – https://docs.github.com/en/authentication",
          "REST API index – https://docs.github.com/en/rest"
        ],
        "data_accessed": [
          "Enterprise IAM configuration (SAML/OIDC, EMU, SCIM mappings)",
          "Enterprise Managed User account records created for the rogue identity",
          "Organization membership and team assignments derived from IdP groups",
          "Private repositories and associated issues/PRs/projects accessible to the new account",
          "Account- and enterprise-level audit logs capturing provisioning and login events"
        ],
        "preconditions_required": [
          "Attacker has administrative control over the external IdP and/or SCIM provisioning integration used by the GitHub Enterprise account.",
          "Attacker understands or can discover which IdP groups and attributes map to GitHub Enterprise Managed Users and to specific organizations/teams.",
          "The GitHub Enterprise tenant is configured for SSO-only authentication and EMU/SCIM provisioning, so new users are created exclusively via this path.",
          "Attacker can send traffic from IPs that satisfy GitHub IP Allowlisting for the enterprise.",
          "Security monitoring does not immediately flag or remove newly provisioned identities that appear anomalous (for example, unexpected service accounts)."
        ],
        "constraints_encountered": [
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Admin Approval Required",
          "MFA Required",
          "IP Allowlisting"
        ],
        "evasion_considerations": [
          "Name the rogue account and associated IdP entry to resemble a legitimate service account or contractor identity rather than an obvious attacker handle.",
          "Assign the account to existing, plausible IdP groups so its GitHub organization memberships look consistent with established patterns.",
          "Avoid giving the rogue account overtly high privileges (for example, org owner) at creation time; escalate later through separate steps if needed.",
          "Provision only a small number of such accounts to reduce the chance of detection in IAM or audit reviews."
        ],
        "resulting_access": "A newly created, attacker-controlled cloud account (Enterprise Managed User) that is legitimately provisioned into the GitHub Enterprise tenant via SSO/SCIM, with whatever organization and repository access is granted by IdP group mappings.",
        "comments": "This vector abuses the enterprise IAM integration itself to create a fresh, valid cloud account inside the GitHub tenant (Cloud Accounts). It is particularly powerful because MFA, domain-based registration, and admin approval are satisfied through normal provisioning flows under the attacker’s control."
      },
      {
        "can_achieve": true,
        "technique_name": "Valid Accounts",
        "technique_stix_id": "b17a1a56-e99c-403c-8948-561df0cffe81",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Import a previously stolen credential into attacker tooling, such as a personal access token (fine-grained or classic), OAuth access token, GitHub App private key (to mint installation tokens), or SSH/deploy private key associated with the target enterprise’s repositories or organizations.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Repository & Git Service"
            ],
            "related_interfaces": [
              "Authentication and token docs – https://docs.github.com/en/authentication",
              "GitHub Apps & OAuth apps docs – https://docs.github.com/en/apps",
              "REST API authentication guidance – https://docs.github.com/en/rest/authentication",
              "Git setup for GitHub over SSH/HTTPS – https://docs.github.com/en/get-started/git-basics/set-up-git"
            ],
            "related_data": [
              "Personal access tokens and their scopes/expiration",
              "GitHub App private keys and installation IDs",
              "OAuth access tokens issued to OAuth apps",
              "SSH keys and repository deploy keys configured in account or repo settings"
            ],
            "notes": "Credential theft itself (for example via secret leakage, phishing, or CI compromise) occurs outside this initial access step; here the attacker assumes possession of valid non-interactive credentials."
          },
          {
            "step_id": 2,
            "description": "From an IP address allowed by the organization’s IP allowlist, configure HTTP tooling (for example curl, custom scripts, or SDKs) to use a stolen PAT/OAuth/GitHub App installation token against the GitHub REST API.",
            "related_capabilities": [
              "GitHub REST API",
              "Authentication & Account Security Management",
              "API Gateway & REST Layer"
            ],
            "related_interfaces": [
              "REST API index – https://docs.github.com/en/rest",
              "REST API authentication docs – https://docs.github.com/en/rest/authentication"
            ],
            "related_data": [
              "API requests and responses for /orgs, /repos, /issues, /pulls, and other resources within the token’s scope",
              "Rate limiting metadata associated with the token"
            ],
            "notes": "MFA Required and SSO-Only Authentication do not protect against use of already-issued tokens; token authentication is primarily constrained by scopes, org authorizations, and IP allowlisting."
          },
          {
            "step_id": 3,
            "description": "Use the stolen token to enumerate and access private resources—for example, listing organizations the user or app can see, enumerating repositories under /orgs/{org}/repos, and fetching code or metadata via /repos endpoints.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "REST API /orgs and /repos endpoints – https://docs.github.com/en/rest/orgs/orgs and https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Organization metadata and membership that the token’s identity can access",
              "Repository lists, configuration, branches, and contents accessible under the token’s scopes",
              "Issues, pull requests, and other repo-level data"
            ],
            "notes": "This is often the first point at which the attacker gains concrete access to tenant data, without needing to establish a browser session."
          },
          {
            "step_id": 4,
            "description": "Alternatively or additionally, load a stolen SSH or deploy key into an SSH agent and perform Git operations (clone, fetch, pull, push where allowed) directly against the target repositories over SSH or HTTPS.",
            "related_capabilities": [
              "Repository & Git Service",
              "Repository Management & Source Code Hosting",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Git over SSH/HTTPS using GitHub – https://docs.github.com/en/get-started/git-basics/set-up-git",
              "Repositories UI/docs – https://docs.github.com/en/repositories"
            ],
            "related_data": [
              "Git repository contents (code, history, tags) for private repositories associated with the key",
              "Git push/pull metadata logged by GitHub (who accessed which repo and when)"
            ],
            "notes": "SSH keys and deploy keys are explicitly supported mechanisms for repository access; once stolen, they provide transparent Git access with no additional interaction with the victim."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Repository Management & Source Code Hosting",
          "Repository & Git Service",
          "API Gateway & REST Layer"
        ],
        "interfaces_used": [
          "Authentication and token management docs – https://docs.github.com/en/authentication",
          "REST API authentication guide – https://docs.github.com/en/rest/authentication",
          "REST API: /orgs and /repos endpoints – https://docs.github.com/en/rest/orgs/orgs, https://docs.github.com/en/rest/repos/repos",
          "Git setup for GitHub over SSH/HTTPS – https://docs.github.com/en/get-started/git-basics/set-up-git",
          "GitHub Apps & OAuth apps docs – https://docs.github.com/en/apps"
        ],
        "data_accessed": [
          "Private repositories and their Git data (commits, branches, tags, files)",
          "Organization metadata and membership information within the token’s scopes",
          "Issues, pull requests, projects, and security data the tokened identity can see",
          "Audit and security logs that record token or SSH key use (indirectly, as part of normal logging)"
        ],
        "preconditions_required": [
          "Attacker already possesses at least one valid non-interactive credential tied to the target tenant, such as a personal access token, OAuth access token, GitHub App private key/installation mapping, or SSH/deploy private key.",
          "The stolen credential has not been revoked or expired and, for SSO-enforced organizations, is authorized for the relevant orgs.",
          "The credential’s scopes and associated identity provide at least read access to some private organization or repository data.",
          "Attacker can originate API and Git traffic from IP addresses allowed by the target’s GitHub IP allowlist."
        ],
        "constraints_encountered": [
          "IP Allowlisting",
          "Rate Limiting"
        ],
        "evasion_considerations": [
          "Mimic normal automation or user behavior in API usage patterns (for example, similar endpoints and request rates) to blend with expected logs.",
          "Throttle API calls and Git operations to stay well below documented rate limits, reducing the risk of rate-limit alerts or investigation.",
          "Prefer using existing automation-related credentials (for example, CI/CD PATs, GitHub App tokens) whose access patterns already look machine-like.",
          "Rotate between multiple stolen credentials, if available, to avoid concentrating suspicious activity on a single token."
        ],
        "resulting_access": "Programmatic and/or Git access to private organizations and repositories using stolen, yet still-valid, non-interactive credentials (tokens or SSH/deploy keys) associated with legitimate GitHub accounts or apps in the tenant.",
        "comments": "This vector captures the use of valid but stolen credentials (Valid Accounts) to gain initial access without interactive login. It is particularly resistant to MFA and SSO-only constraints because tokens and SSH keys remain usable once issued."
      },
      {
        "can_achieve": true,
        "technique_name": "Trusted Relationship",
        "technique_stix_id": "9fa07bef-9c81-421e-a8e5-ad4366c5a925",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Register a new GitHub App that appears legitimate (for example, branded as a CI tool or reporting integration) and configure its callback URL and webhook endpoint under the attacker’s control.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Apps & Integrations Platform",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "GitHub Apps registration and configuration UI – https://docs.github.com/en/apps",
              "GitHub Apps creation docs – https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps",
              "GitHub App webhook docs – https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events"
            ],
            "related_data": [
              "GitHub App registration metadata (name, description, homepage, webhook URL)",
              "App credentials, including private key used to mint installation tokens"
            ],
            "notes": "This step leverages the documented GitHub Apps platform to create an integration identity that tenants can install and trust."
          },
          {
            "step_id": 2,
            "description": "Request broad but seemingly justified permissions for the GitHub App (for example, read access to repository contents, issues, and pull requests; possibly write/admin scopes depending on the pretext), and configure the app to be installable on organizations and repositories.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "GitHub Apps permissions configuration UI – https://docs.github.com/en/apps",
              "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps"
            ],
            "related_data": [
              "Declared app permissions over repositories, organizations, and other resources",
              "Installation-scoping preferences (all repositories vs. selected repositories)"
            ],
            "notes": "Privileged GitHub Apps with wide permissions are explicitly supported but require careful admin review; an attacker abuses this trust model by over-requesting permissions."
          },
          {
            "step_id": 3,
            "description": "Convince a target organization administrator (through out-of-band channels) to install the app on the organization, selecting either all repositories or a sensitive subset, and approving the requested permissions.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Organization settings: Installed GitHub Apps and Marketplace apps – https://docs.github.com/en/organizations",
              "GitHub Apps installation flows – https://docs.github.com/en/apps/using-github-apps/about-using-github-apps"
            ],
            "related_data": [
              "App installation record linking the app to the target organization and selected repositories",
              "Organization metadata showing installed apps and their scopes"
            ],
            "notes": "MFA Required and SSO-Only Authentication apply to the admin’s session when installing the app, but do not limit what the app can do once installed."
          },
          {
            "step_id": 4,
            "description": "Use the app’s private key and installation ID to obtain short-lived installation access tokens and begin calling the GitHub REST API within the scope granted by the organization during installation.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Authentication & Account Security Management",
              "API Gateway & REST Layer"
            ],
            "related_interfaces": [
              "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps",
              "REST API index – https://docs.github.com/en/rest",
              "REST API authentication docs – https://docs.github.com/en/rest/authentication"
            ],
            "related_data": [
              "GitHub App installation access tokens",
              "API responses for repository contents, issues, pull requests, and other resources in scope"
            ],
            "notes": "From GitHub’s perspective, these are legitimate app tokens acting within declared permissions. IP Allowlisting may require the app’s backend to call the API from allowed IP ranges."
          },
          {
            "step_id": 5,
            "description": "Leverage the app’s access tokens and incoming webhooks to continuously read (and potentially modify) code and metadata in the target organization as initial foothold in the tenant.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Repository APIs – https://docs.github.com/en/rest/repos/repos",
              "Webhook events and payloads docs – https://docs.github.com/en/webhooks/webhook-events-and-payloads"
            ],
            "related_data": [
              "Private repositories and code within installation scope",
              "Issues, pull requests, and other collaborative artifacts accessible to the app",
              "Webhook payloads describing ongoing activity in the target org and repos"
            ],
            "notes": "This constitutes ongoing, API-based initial access via a trusted third-party application relationship (Trusted Relationship)."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Webhook Event Delivery",
          "Organization & Team Administration",
          "Authentication & Account Security Management",
          "Apps & Integrations Platform",
          "API Gateway & REST Layer"
        ],
        "interfaces_used": [
          "GitHub Apps registration UI – https://docs.github.com/en/apps",
          "GitHub Apps creation docs – https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps",
          "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps",
          "Organization apps/Marketplace management UI – https://docs.github.com/en/organizations",
          "REST API index – https://docs.github.com/en/rest",
          "Webhook events and payloads – https://docs.github.com/en/webhooks/webhook-events-and-payloads"
        ],
        "data_accessed": [
          "App registration metadata and credentials (private key, client identifiers)",
          "App installation records linking the app to organizations and repositories",
          "Private repositories, issues, pull requests, and other resources within installation scope",
          "Webhook payloads describing repository and organization activity for the target tenant"
        ],
        "preconditions_required": [
          "Attacker can register GitHub Apps on a normal GitHub account (no special privileges required beyond app developer capabilities).",
          "At least one administrator of the target organization is willing to install the attacker-controlled app and grant it the requested permissions (for example, due to social engineering or Marketplace trust).",
          "The organization’s security policies allow installation of third-party GitHub Apps with the requested scopes.",
          "The attacker’s infrastructure can reach GitHub APIs and receive webhooks from IP addresses that comply with the tenant’s IP Allowlisting policy, if enforced."
        ],
        "constraints_encountered": [
          "IP Allowlisting",
          "MFA Required",
          "SSO-Only Authentication"
        ],
        "evasion_considerations": [
          "Publish the app with a professional-looking Marketplace listing, documentation, and limited but still useful functionality to build trust.",
          "Request the minimum necessary permissions initially (for example, read-only repository and metadata access) to reduce admin suspicion, then rely on stealthy use.",
          "Operate from stable, reputable IP ranges and maintain good uptime so the app appears like any other SaaS integration.",
          "Throttle API usage and avoid large-scale data pulls that could trigger anomaly or DLP alerts."
        ],
        "resulting_access": "An installed GitHub App with legitimate, fine-grained permissions and installation tokens that provide continuous API-level access to selected or all repositories and organization data within the target tenant.",
        "comments": "This vector directly matches the Trusted Relationship technique: the victim organization voluntarily installs and trusts a third-party GitHub App that is in fact controlled or compromised by the attacker, effectively granting initial access via app tokens."
      },
      {
        "can_achieve": true,
        "technique_name": "Spearphishing Link",
        "technique_stix_id": "2b742742-28c3-4e1b-bab7-8350d6300fa7",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Register an OAuth App in GitHub that appears benign (for example, a “productivity dashboard” or “code analytics” tool) and configure its client ID, client secret, and callback URL to an attacker-controlled service.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management",
              "Apps & Integrations Platform"
            ],
            "related_interfaces": [
              "Apps platform docs (OAuth Apps) – https://docs.github.com/en/apps",
              "OAuth app creation and configuration docs – https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps"
            ],
            "related_data": [
              "OAuth app registration metadata (name, description, callback URL)",
              "Client ID and client secret for the OAuth app"
            ],
            "notes": "Although GitHub Apps are preferred for new integrations, OAuth Apps are still supported and documented, including for login/authorization flows."
          },
          {
            "step_id": 2,
            "description": "Craft an OAuth 2.0 authorization URL for the app that requests broad scopes (for example, repo, read:org) and embed it in targeted messages (email, chat, or tickets) sent to users who have access to the target tenant.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "OAuth authorization flows as described in apps/authentication docs – https://docs.github.com/en/apps",
              "User authentication and account security docs – https://docs.github.com/en/authentication"
            ],
            "related_data": [
              "Scope parameters indicating requested GitHub API permissions (for example, repo, read:org)",
              "Targeted users’ GitHub identities and organization memberships (used to choose victims)"
            ],
            "notes": "This is the Spearphishing Link component: a URL that, when followed, leads to a legitimate GitHub OAuth consent page for the attacker-controlled app."
          },
          {
            "step_id": 3,
            "description": "When a victim clicks the link, rely on GitHub’s normal login and MFA/SSO flows (the victim authenticates legitimately) and then present the OAuth consent screen where the user authorizes the app to access their account with the requested scopes.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "User login and MFA flows – https://docs.github.com/en/authentication",
              "OAuth consent screens as part of the apps platform – https://docs.github.com/en/apps"
            ],
            "related_data": [
              "User’s authenticated GitHub identity and organization memberships",
              "Record that the user has authorized the OAuth app for specific scopes"
            ],
            "notes": "MFA Required, SSO-Only Authentication, and Domain-Based Registration constraints are satisfied by the legitimate user’s own login; they do not prevent the user from consenting to the OAuth app."
          },
          {
            "step_id": 4,
            "description": "On receipt of the OAuth authorization code at the attacker-controlled callback URL, exchange it for an OAuth access token using GitHub’s documented token endpoint and store the resulting access token.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Authentication & Account Security Management",
              "API Gateway & REST Layer"
            ],
            "related_interfaces": [
              "OAuth token exchange and API authentication docs – https://docs.github.com/en/rest/authentication",
              "REST API index – https://docs.github.com/en/rest"
            ],
            "related_data": [
              "OAuth access token bound to the victim user and granted scopes",
              "Associated refresh/expiration metadata, if applicable"
            ],
            "notes": "From GitHub’s perspective this is a normal OAuth authorization grant; the attacker’s backend simply plays the role of the legitimate application."
          },
          {
            "step_id": 5,
            "description": "Use the stolen OAuth access token from allowlisted IPs to call the GitHub REST API and access private repositories, organizations, and other resources within the victim user’s scope.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "REST API /user, /orgs, and /repos endpoints – https://docs.github.com/en/rest",
              "Repositories docs – https://docs.github.com/en/repositories",
              "Organizations docs – https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "Private repositories and contents the victim user can access",
              "Organization metadata, issues, pull requests, and other resources within granted scopes"
            ],
            "notes": "This is the point of initial access to the tenant via a stolen application access token obtained through an OAuth consent phishing (Spearphishing Link) flow."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Apps & Integrations Platform",
          "API Gateway & REST Layer"
        ],
        "interfaces_used": [
          "Apps platform (OAuth Apps) – https://docs.github.com/en/apps",
          "User authentication and security docs – https://docs.github.com/en/authentication",
          "REST API authentication docs – https://docs.github.com/en/rest/authentication",
          "REST API index – https://docs.github.com/en/rest"
        ],
        "data_accessed": [
          "OAuth app registration data (client ID/secret, callback URL)",
          "OAuth access tokens tied to victim user accounts and scopes",
          "Private repositories, organization data, and other resources within the victim’s GitHub permissions",
          "Audit and security logs showing app authorization and token usage"
        ],
        "preconditions_required": [
          "Attacker can register OAuth Apps on a GitHub account and host an HTTPS callback endpoint.",
          "Target users are willing or likely to click external links and authorize third-party apps, due to social engineering or plausible business pretext.",
          "The target tenant does not have strict policies prohibiting OAuth Apps or has not disabled/blocked the specific app.",
          "Attacker can reach GitHub’s APIs from IP ranges that pass the tenant’s IP Allowlisting policies, if enforced."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "IP Allowlisting",
          "Rate Limiting"
        ],
        "evasion_considerations": [
          "Use realistic branding and descriptions for the OAuth app so the consent page looks legitimate and the requested scopes seem justified.",
          "Limit scopes to the minimum needed to achieve objectives (for example, repo and read:org) to reduce suspicion on the consent screen.",
          "Host a genuine, minimally functional web application at the callback URL to avoid raising alarms if security teams inspect it.",
          "Schedule API access in line with the victim’s working hours and from plausible geolocations to avoid anomaly detection."
        ],
        "resulting_access": "An OAuth access token that grants the attacker API-level access to the victim user’s GitHub resources (repositories and organizations) according to the scopes the victim consented to, obtained via a spearphishing link to a malicious OAuth authorization URL.",
        "comments": "This vector applies the Spearphishing Link technique specifically to GitHub’s OAuth consent flows, yielding stolen application access tokens that act as valid credentials into the tenant."
      },
      {
        "can_achieve": false,
        "technique_name": "Default Accounts",
        "technique_stix_id": "attack-pattern--6151cbea-819b-455a-9fa6-99a1cc58797d",
        "method_steps": [],
        "capabilities_used": [],
        "interfaces_used": [],
        "data_accessed": [],
        "preconditions_required": [],
        "constraints_encountered": [],
        "evasion_considerations": [],
        "resulting_access": "",
        "comments": "GitHub’s documented model is multi-tenant with individually created user accounts, SSO-managed identities, tokens, and app installations. There is no indication of vendor-shipped default login accounts (such as a global admin/admin pair) that are accessible to customers. Admin and owner roles are granted to specific users or enterprise identities, and deploy keys, PATs, and app tokens are explicitly configured per tenant. Therefore, the Initial Access technique Default Accounts is not realistically achievable against GitHub using documented capabilities alone; exploitation would require an unknown implementation flaw rather than an exposed default credential."
      }
    ],
    "summary": "Across GitHub’s documented capabilities, realistic initial access to a tenant centers on abusing identity and integration surfaces rather than exploiting unknown vulnerabilities. The primary entry points are: (1) taking over existing SSO-managed user identities and logging in via standard SAML/OIDC flows (Valid Accounts); (2) abusing enterprise IAM and SCIM provisioning to create new, attacker-controlled cloud accounts inside the tenant (Cloud Accounts); (3) using stolen non-interactive credentials such as personal access tokens, OAuth tokens, GitHub App tokens, or SSH/deploy keys to access private repositories and organizations via Git or the REST API (Valid Accounts); and (4) leveraging trusted third-party relationships by registering malicious GitHub Apps or OAuth Apps and persuading administrators or users to install/authorize them, thereby gaining app- or user-scoped tokens (Trusted Relationship, Spearphishing Link). Environment constraints like MFA, SSO-only authentication, domain-based registration, email verification, and admin approval mainly harden interactive login and public signup flows, but they do not fully mitigate token-based or app-based initial access, especially when attackers compromise the IdP, existing credentials, or the app trust model. Default account abuse is not supported by the documented GitHub architecture and is considered infeasible in this context."
  },
  "discovery": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Account Discovery",
        "technique_stix_id": "attack-pattern--72b74d71-8169-42aa-92e0-e7b04b9f5a08",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using the already-compromised GitHub identity (user session, personal access token, fine‑grained token, or GitHub App installation token) that has access to the target tenant, enumerate which organizations and/or enterprise accounts it belongs to via the GitHub web UI and the organizations REST API.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Organization settings web UI (https://docs.github.com/en/organizations)",
              "Enterprise account admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "REST API: Organizations endpoints (https://docs.github.com/en/rest/orgs/orgs)",
              "REST API overview (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
            ],
            "related_data": [
              "Organization accounts and profiles",
              "Enterprise account metadata and list of child organizations",
              "User identity and account metadata associated with the compromised identity"
            ],
            "notes": "Analogous to cloud attackers using tenant/domain listing APIs; here the attacker uses GitHub org and enterprise admin surfaces to understand which tenants their compromised identity can reach. MFA/SSO constraints are assumed already satisfied as part of the initial compromise."
          },
          {
            "step_id": 2,
            "description": "For each accessible organization, list all members and outside collaborators to build a directory of user accounts associated with that org.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub REST API",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Organization members and outside collaborators UI (https://docs.github.com/en/organizations)",
              "REST API: Organizations endpoints for members (https://docs.github.com/en/rest/orgs/orgs)",
              "Repository settings and collaborators via REST /repos category (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Organization members and roles (owner, member, billing manager, security manager, etc.)",
              "Outside collaborators associated to repos/org",
              "Repository collaborator lists and associated permissions"
            ],
            "notes": "This mirrors MITRE examples where adversaries obtain bulk user lists from cloud directories. Only org owners/admins can see full membership; regular members may see a subset via UI/API."
          },
          {
            "step_id": 3,
            "description": "Enumerate team structures and team memberships within each organization to discover additional accounts and understand how users are grouped.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization Teams UI (https://docs.github.com/en/organizations)",
              "REST API: Teams endpoints (https://docs.github.com/en/rest/teams/teams)"
            ],
            "related_data": [
              "Teams and team hierarchies",
              "Team membership lists (usernames, maintainers vs members)"
            ],
            "notes": "While primarily supporting permission discovery, team membership also serves as a secondary user directory, helping the attacker identify functional groupings (e.g., SRE, Security, Payments)."
          },
          {
            "step_id": 4,
            "description": "Across repositories the account can see, enumerate repository collaborators and contributors via repo settings UI and the repositories REST API to find additional user and bot accounts, especially external collaborators not visible in org‑level membership views.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Repository settings and collaborators UI (https://docs.github.com/en/repositories)",
              "REST API: Repositories endpoints (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Repository collaborator lists and roles",
              "Repository visibility (public, private, internal) revealing tenant boundary exposure",
              "Usernames and bot accounts referenced in repository metadata"
            ],
            "notes": "This step helps identify accounts that have access only at specific repositories (e.g., contractors or vendor bots), which may not appear as full members in all org contexts."
          },
          {
            "step_id": 5,
            "description": "If the compromised identity has enterprise‑level roles, use the Enterprise Cloud admin console and associated REST APIs to list all organizations in the enterprise and correlate membership and activity data (via available audit log views) to expand the global account inventory.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "REST API: Enterprise teams/administration endpoints (https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)"
            ],
            "related_data": [
              "List of organizations in the enterprise account",
              "Enterprise roles and delegations",
              "Audit log entries referencing user identities and roles"
            ],
            "notes": "This is the GitHub analogue of cloud account enumeration in large tenants: enterprise owners can quickly see all orgs and cross‑org user presence."
          },
          {
            "step_id": 6,
            "description": "Inspect installed GitHub Apps and OAuth apps for the organization/enterprise to discover app identities and associated installation accounts, which function as additional principals in the environment.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub Apps and OAuth Apps configuration UI (https://docs.github.com/en/apps)",
              "REST API: GitHub Apps endpoints (https://docs.github.com/en/rest/apps/apps)"
            ],
            "related_data": [
              "App registrations and metadata (names, owners)",
              "Installation records per user/organization",
              "App tokens and installation scopes (as metadata, not secrets)"
            ],
            "notes": "MITRE’s Cloud Account technique explicitly includes service and app accounts. GitHub Apps and OAuth apps represent powerful non‑human accounts that the attacker can identify and later consider as targets."
          },
          {
            "step_id": 7,
            "description": "Review organization and enterprise audit/security logs (where accessible) to harvest historical account identifiers (users, bots, apps) from recorded events such as logins, membership changes, and admin operations.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Org/enterprise audit log UIs documented under organization and enterprise admin (https://docs.github.com/en/organizations, https://docs.github.com/en/enterprise-cloud@latest/admin)"
            ],
            "related_data": [
              "Audit log entries with actor and target user identifiers",
              "Account‑level security logs (sign‑in events, token usage) for the compromised identity"
            ],
            "notes": "Audit logs provide a time‑series view of identities, including those that might no longer be active but reveal historic access patterns or naming conventions."
          },
          {
            "step_id": 8,
            "description": "If the compromised identity has rights to manage webhooks, inspect existing organization or enterprise global webhook configurations for membership‑related event subscriptions and endpoints, then (if stealth tolerates configuration changes) add an additional webhook endpoint controlled by the attacker to passively receive future account‑related events.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Organization webhooks UI and REST API (https://docs.github.com/en/webhooks, https://docs.github.com/en/rest/orgs/webhooks)",
              "Enterprise global webhooks UI (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)"
            ],
            "related_data": [
              "Webhook configurations (event types, target URLs)",
              "Webhook payloads containing user and organization identifiers for membership‑related events"
            ],
            "notes": "This step moves from snapshot enumeration to ongoing monitoring of account additions/removals. It is noisier (configuration change) but provides continuous account discovery similar to how attackers subscribe to directory or IAM change events in cloud environments."
          }
        ],
        "capabilities_used": [
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Webhook Event Delivery",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Organization settings and members UI (https://docs.github.com/en/organizations)",
          "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
          "REST API: Organizations (https://docs.github.com/en/rest/orgs/orgs)",
          "REST API: Teams (https://docs.github.com/en/rest/teams/teams)",
          "REST API: Repositories (https://docs.github.com/en/rest/repos/repos)",
          "REST API: Enterprise teams/administration (https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)",
          "GitHub Apps and OAuth apps UI (https://docs.github.com/en/apps)",
          "REST API: Apps (https://docs.github.com/en/rest/apps/apps)",
          "Organization webhooks UI and REST API (https://docs.github.com/en/webhooks, https://docs.github.com/en/rest/orgs/webhooks)",
          "Enterprise global webhooks UI (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)",
          "REST API overview (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
        ],
        "data_accessed": [
          "Lists of organizations and enterprises the compromised identity can access",
          "Organization member lists and role assignments",
          "Outside collaborators and their associated repositories",
          "Teams and their memberships",
          "Repository collaborators and their roles",
          "Enterprise account metadata and list of child organizations",
          "GitHub Apps and OAuth apps installations and permissions metadata",
          "Organization and enterprise audit log entries referencing user and app identities",
          "Webhook configurations and, if exploited, membership‑related webhook payloads"
        ],
        "preconditions_required": [
          "Attacker controls a valid authenticated GitHub identity (user session, PAT/fine‑grained token, or GitHub App installation token) that is a member of the target organization and/or enterprise.",
          "If MFA Required and/or SSO‑Only Authentication are enforced, the attacker must already possess or bypass the necessary second factor or SSO session to obtain the token or session used here.",
          "To enumerate complete org membership, the compromised identity should have organization owner/administrator privileges; otherwise enumeration may be partial (only visible collaborators or teams).",
          "To enumerate enterprise‑wide accounts and organizations, the compromised identity must have enterprise owner/administrator privileges in the GitHub Enterprise Cloud account.",
          "To add or modify webhooks for ongoing account discovery, the identity must have permissions to administer organization or enterprise webhooks.",
          "IP Allowlisting must either include the attacker’s source IPs or the attacker must pivot through an allowed network path (e.g., VPN, compromised developer workstation) to access the GitHub UI/API."
        ],
        "constraints_encountered": [
          "MFA Required: makes it harder to obtain new sessions or tokens, but once a valid token/session is compromised, enumeration via UI/API proceeds normally.",
          "SSO-Only Authentication: limits login and token creation to IdP‑backed identities; enumeration is still possible once such an identity or its tokens are compromised.",
          "IP Allowlisting: UI and REST calls from non‑allowlisted IPs will fail; enumeration must come from allowed networks.",
          "Rate Limiting: REST API calls for listing organizations, members, teams, and repos are subject to rate limits, forcing the attacker to use low‑and‑slow enumeration or multiple tokens.",
          "Admin Approval Required / Domain-Based Registration / CAPTCHA Protection / Email Verification Required: these primarily restrict creation of new accounts and are not directly involved in account discovery using an already‑compromised identity."
        ],
        "evasion_considerations": [
          "Prefer UI‑driven enumeration or small batched API queries that resemble normal admin activity rather than large, exhaustive API crawls.",
          "Throttle REST API requests and randomize ordering (e.g., per-org, per-team) to avoid tripping rate‑limit and anomaly‑detection thresholds.",
          "Leverage existing GitHub Apps or automation (Actions workflows) with legitimate purposes to collect or cache membership data, minimizing obviously manual enumeration activity.",
          "If configuring additional webhooks for ongoing monitoring, align event subscriptions and destinations with existing monitoring patterns to reduce the chance of immediate review.",
          "Reuse cached or historic data from audit logs rather than repeatedly querying membership endpoints."
        ],
        "information_discovered": "Comprehensive directory of human and non‑human accounts in the tenant: organizations and enterprises the identity can reach, all members and outside collaborators per org, team‑based groupings, repository‑level collaborators, app/service accounts from installed GitHub Apps and OAuth apps, and historical identities referenced in audit logs. This enables the attacker to understand who exists in the environment, how they are grouped, and where additional identities might be targeted or abused.",
        "comments": "This vector maps primarily to Account Discovery but also overlaps strongly with the Cloud Account technique (attack-pattern--8f104855-e5b7-4077-b1f5-bc3103b41abe) for enumerating organizations, enterprises, and service/app accounts in the GitHub SaaS environment."
      },
      {
        "can_achieve": true,
        "technique_name": "Permission Groups Discovery",
        "technique_stix_id": "attack-pattern--15dbf668-795c-41e6-8219-f0447c0e64ce",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using the compromised identity with at least read:org‑equivalent privileges, enumerate all teams for each accessible organization to identify permission groups and their high‑level scopes.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization Teams UI (https://docs.github.com/en/organizations)",
              "REST API: Teams endpoints (https://docs.github.com/en/rest/teams/teams)"
            ],
            "related_data": [
              "Team names, descriptions, and hierarchies",
              "Team membership counts and maintainers"
            ],
            "notes": "This parallels MITRE examples where adversaries use directory tools to list security groups; here, GitHub teams serve as primary permission groups controlling repository access."
          },
          {
            "step_id": 2,
            "description": "For each team, enumerate its members and the repositories it has access to, including the permission level (read, triage, write, maintain, admin), to construct a detailed team‑to‑resource permission map.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization Teams management UI (https://docs.github.com/en/organizations)",
              "REST API: Teams endpoints for memberships and repository access (https://docs.github.com/en/rest/teams/teams)",
              "REST API: Repositories endpoints (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Team membership lists",
              "Per‑team repository access lists and permission levels",
              "Repository identifiers linked to teams"
            ],
            "notes": "Combining team membership with repo access levels reveals which users or groups can administer or modify specific repositories, equivalent to enumerating ACLs in traditional environments."
          },
          {
            "step_id": 3,
            "description": "Inspect organization‑level repository access policies and base permissions (for example, default repository permission for all members) via organization settings and corresponding REST endpoints to understand implicit access granted to broad groups.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization settings UI for repository access policies (https://docs.github.com/en/organizations)",
              "REST API: Organizations endpoints (https://docs.github.com/en/rest/orgs/orgs)"
            ],
            "related_data": [
              "Org‑wide base permission for members (none/read/write)",
              "Org‑level repository access policies affecting all repos"
            ],
            "notes": "Base permissions can effectively form a giant implicit group (e.g., all members have read access to all private repos), which is critical for modeling real access exposure."
          },
          {
            "step_id": 4,
            "description": "At repository scope, enumerate collaborators, outside collaborators, and their roles, and review branch protection and ruleset configurations to identify accounts and teams with elevated privileges (e.g., ability to push to protected branches or bypass required checks).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines"
            ],
            "related_interfaces": [
              "Repository settings UI (https://docs.github.com/en/repositories)",
              "REST API: Repositories endpoints (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Repository collaborators and roles (read/write/maintain/admin)",
              "Branch protection and ruleset configurations referencing specific users/teams",
              "Required status checks and bypass settings for protected branches"
            ],
            "notes": "Branch/ruleset protections indicate which groups can land code into critical branches and which checks can be bypassed, often more relevant than simple read/write access."
          },
          {
            "step_id": 5,
            "description": "If enterprise‑level access is available, enumerate enterprise teams and their mappings to organizations and repositories using the Enterprise Cloud admin UI and enterprise teams REST APIs to understand cross‑org permission structures.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "REST API: Enterprise teams endpoints (https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)"
            ],
            "related_data": [
              "Enterprise teams and roles",
              "Cross‑organization team‑to‑repository mappings"
            ],
            "notes": "Enterprise teams function similarly to cloud directory groups that span multiple subscriptions/accounts; compromising one such group can grant extremely broad access."
          },
          {
            "step_id": 6,
            "description": "Enumerate installed GitHub Apps and OAuth apps at org/enterprise scope and inspect their requested permissions and installation targets (orgs and repos) to model app‑level permission groups and potential over‑privileged integrations.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub Apps/OAuth Apps configuration UI (https://docs.github.com/en/apps)",
              "REST API: Apps endpoints (https://docs.github.com/en/rest/apps/apps)"
            ],
            "related_data": [
              "App permission scopes (e.g., repository administration, security events, Actions, checks)",
              "Installations per org and repository",
              "App owners and webhook URLs (indicating external control points)"
            ],
            "notes": "From a permissions perspective, each app installation is a powerful principal; mapping app scopes and installation breadth shows where automated code or external vendors can act."
          },
          {
            "step_id": 7,
            "description": "Review organization and enterprise audit logs (where accessible) for events related to role changes, team membership changes, and repository permission modifications to identify historically privileged accounts or groups, even if current settings were tightened.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Org/enterprise audit log UIs under org and enterprise admin docs (https://docs.github.com/en/organizations, https://docs.github.com/en/enterprise-cloud@latest/admin)"
            ],
            "related_data": [
              "Historical role assignments and removals",
              "Team membership changes over time",
              "Repository permission change events"
            ],
            "notes": "Historical data can reveal which users or teams previously held elevated permissions and may still have cached credentials or external dependencies configured with those privileges."
          }
        ],
        "capabilities_used": [
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines"
        ],
        "interfaces_used": [
          "Organization settings and Teams UI (https://docs.github.com/en/organizations)",
          "Repository settings UI (https://docs.github.com/en/repositories)",
          "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
          "REST API: Teams (https://docs.github.com/en/rest/teams/teams)",
          "REST API: Organizations (https://docs.github.com/en/rest/orgs/orgs)",
          "REST API: Repositories (https://docs.github.com/en/rest/repos/repos)",
          "REST API: Enterprise teams (https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)",
          "GitHub Apps/OAuth apps configuration UI (https://docs.github.com/en/apps)",
          "REST API: Apps (https://docs.github.com/en/rest/apps/apps)"
        ],
        "data_accessed": [
          "Team definitions, hierarchies, and descriptions",
          "Team membership lists and maintainers",
          "Per‑team repository access lists and permission levels",
          "Organization‑wide base permissions and repository access policies",
          "Repository collaborator and outside collaborator lists with roles",
          "Branch protection and ruleset configurations defining who can merge or bypass checks",
          "Enterprise teams and cross‑org permission mappings",
          "App permission scopes and installation coverage across organizations and repositories",
          "Audit log records of permission and membership changes"
        ],
        "preconditions_required": [
          "Compromised identity must have at least read:org‑level visibility into teams and org settings; full mapping of permission groups typically requires organization owner or equivalent admin privileges.",
          "To enumerate enterprise teams and cross‑org permissions, the attacker must compromise an enterprise owner/administrator account.",
          "Repository‑level collaborator and branch protection data require at least maintainer/admin rights on those repositories.",
          "Access to app permissions and installation scopes requires rights to view app configuration at org or enterprise scope.",
          "Network access must satisfy any IP Allowlisting controls; enumeration requests must originate from allowed IP ranges.",
          "MFA Required and SSO-Only Authentication must already be satisfied for the compromised identity (e.g., attacker controls a logged‑in browser session or long‑lived token)."
        ],
        "constraints_encountered": [
          "Role-based access control: non‑admin users may see only a subset of teams and will not see organization‑wide base permissions or some app installations, limiting completeness of the permission map.",
          "IP Allowlisting: access to organization and enterprise settings may be blocked from non‑approved networks, forcing the attacker to pivot from allowed infrastructure.",
          "Rate Limiting: bulk enumeration of teams, repos, and collaborators via REST API is constrained by GitHub’s API rate limits, requiring throttling or distribution across multiple tokens.",
          "MFA Required / SSO-Only Authentication: limit the pool of accounts that can be compromised and reused for this activity but do not materially constrain enumeration once a suitable admin account is controlled."
        ],
        "evasion_considerations": [
          "Perform enumeration in smaller batches (per organization or per team) and interleave with benign admin actions to blend into normal administration patterns.",
          "Favor UI access for spot‑checking permissions and reserve heavy API usage for off‑hours with rate‑limit‑aware tooling to reduce anomalies.",
          "Use an existing, trusted GitHub App or Actions‑based reporting workflow (if compromised) to run permission‑mapping queries under the guise of compliance or audit reporting.",
          "Avoid creating or deleting teams/roles; stick to read‑only inspection to minimize audit log entries that would draw attention.",
          "Where possible, reuse existing reports or exports (e.g., internal security tooling built on top of the REST API) rather than directly crawling every endpoint."
        ],
        "information_discovered": "A detailed model of GitHub permission structures: which teams and enterprise teams exist, how they map to repositories and organizations, what base permissions are granted broadly, which collaborators and groups have administrative access or can bypass protections, and which apps function as highly privileged principals. This allows the attacker to identify the smallest set of accounts or groups whose compromise would yield maximal control over code and configuration.",
        "comments": "This vector primarily aligns with Permission Groups Discovery but also captures the SaaS‑specific Cloud Groups perspective (attack-pattern--16e94db9-b5b1-4cd0-b851-f38fbd0a70f2) by treating GitHub teams and enterprise teams as cloud permission groups."
      },
      {
        "can_achieve": true,
        "technique_name": "Password Policy Discovery",
        "technique_stix_id": "attack-pattern--b6075259-dba3-44e9-87c7-e954f37ec0d5",
        "method_steps": [
          {
            "step_id": 1,
            "description": "From the compromised user account, inspect the account’s own security settings to understand which authentication factors are configured (password, passkeys, 2FA methods, SSH keys, tokens) and what self‑service security controls are available.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "User account security settings UI (https://docs.github.com/en/authentication)"
            ],
            "related_data": [
              "Presence of 2FA and its methods for the compromised account",
              "Configured passkeys and recovery mechanisms",
              "Registered SSH and GPG keys, and existing personal access tokens (metadata only)"
            ],
            "notes": "While this focuses on a single account, it reveals how GitHub enforces account‑level security (e.g., whether 2FA can be disabled easily, whether passkeys are in use), which informs the attacker’s model of the environment’s general practices."
          },
          {
            "step_id": 2,
            "description": "For each organization where the compromised identity has owner/admin rights, review organization security and member‑related settings to determine whether mandatory 2FA is enforced, how base permissions are configured, and whether SSO/SAML is required.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Organization settings UI for security policies and member requirements (https://docs.github.com/en/organizations)"
            ],
            "related_data": [
              "Org‑level 2FA enforcement status",
              "SSO/SAML requirements for org members (where configured)",
              "Base repository permission settings that interact with authentication posture"
            ],
            "notes": "This is the SaaS analogue of domain password policy discovery—rather than minimum password length, the attacker learns whether 2FA/SSO is mandatory and what default access authenticated org members receive."
          },
          {
            "step_id": 3,
            "description": "If the compromised identity is an enterprise owner/admin, use the Enterprise Cloud admin console and IAM management docs/APIs to enumerate enterprise‑wide IAM configuration, such as SAML/OIDC SSO, Enterprise Managed Users, SCIM provisioning, and any enterprise‑level authentication or access policies.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "Enterprise IAM management docs and interfaces (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)"
            ],
            "related_data": [
              "SAML/OIDC SSO configuration and enforcement scope",
              "Enterprise Managed Users and SCIM provisioning status",
              "Enterprise‑wide authentication and access policies affecting child organizations"
            ],
            "notes": "Understanding whether GitHub users are IdP‑backed EMUs, which authentication flows are allowed, and how SCIM is used helps the attacker align future operations with IdP constraints."
          },
          {
            "step_id": 4,
            "description": "Use relevant REST API endpoints in the authentication and organizations categories (where authorized) to systematically query which organizations enforce 2FA, which features are restricted, and possibly which authentication‑related events or settings are exposed programmatically.",
            "related_capabilities": [
              "GitHub REST API",
              "Authentication & Account Security Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "REST API: Authentication (https://docs.github.com/en/rest/authentication)",
              "REST API: Organizations (https://docs.github.com/en/rest/orgs/orgs)",
              "REST API overview (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
            ],
            "related_data": [
              "Org‑level security configuration metadata (e.g., whether members must have 2FA)",
              "Programmatically accessible authentication/credential metadata for the compromised identity"
            ],
            "notes": "Analogous to using cloud APIs like GetAccountPasswordPolicy; here the attacker relies on GitHub’s org and auth APIs where they expose effective security requirements."
          },
          {
            "step_id": 5,
            "description": "Review account‑level security logs and organization/enterprise audit logs (if accessible) to infer how strictly authentication policies are enforced in practice—for example, frequency of failed sign‑ins, enforcement of 2FA, and patterns of token creation/revocation.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Account security logs via authentication docs (https://docs.github.com/en/authentication)",
              "Org and enterprise audit log UIs (https://docs.github.com/en/organizations, https://docs.github.com/en/enterprise-cloud@latest/admin)"
            ],
            "related_data": [
              "Sign‑in events and IP/device information for accounts",
              "2FA‑related events and policy changes",
              "Token and SSH key creation/revocation events"
            ],
            "notes": "Logs give practical insight into enforcement (e.g., whether non‑2FA sign‑ins are blocked) and may reveal weaker segments of the org where policies were recently enabled."
          },
          {
            "step_id": 6,
            "description": "Correlate security feature configurations (code scanning, secret scanning, Dependabot, push protection, and branch protections) from the organization security center with authentication policies to understand where technical controls compensate for or leave gaps in account security.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)",
              "REST API: Code security configurations (https://docs.github.com/en/rest/code-security/configurations)"
            ],
            "related_data": [
              "Security configurations applied to repositories",
              "Coverage and enforcement of code scanning, Dependabot, and secret scanning",
              "Push protection enablement and bypass data"
            ],
            "notes": "Although not a password policy per se, this combined view shows how hard it will be to exploit weak account security—for example, whether unprotected repos and branches exist where a compromised account can land unscanned code."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "GitHub REST API",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection"
        ],
        "interfaces_used": [
          "User account security settings UI (https://docs.github.com/en/authentication)",
          "Organization settings UI (https://docs.github.com/en/organizations)",
          "Enterprise Cloud admin/IAM UIs (https://docs.github.com/en/enterprise-cloud@latest/admin, https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)",
          "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)",
          "REST API: Authentication (https://docs.github.com/en/rest/authentication)",
          "REST API: Organizations (https://docs.github.com/en/rest/orgs/orgs)",
          "REST API: Code security configurations (https://docs.github.com/en/rest/code-security/configurations)",
          "REST API overview (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
        ],
        "data_accessed": [
          "Account‑level authentication configuration (2FA enablement, passkeys, SSH keys, tokens metadata)",
          "Org‑level 2FA enforcement settings and SSO/SAML requirements",
          "Enterprise‑level IAM configuration for SSO, EMU, and SCIM",
          "Security and audit logs showing sign‑ins, credential events, and policy changes",
          "Org‑level security feature configurations and coverage metrics"
        ],
        "preconditions_required": [
          "Compromised identity must have access to its own account security settings (always true for a user account).",
          "To view org‑wide authentication and security settings, the attacker must control an org owner/administrator account.",
          "To enumerate enterprise‑wide IAM configuration, the attacker must control an enterprise owner/administrator account.",
          "IP Allowlisting must permit access to the account, org, and enterprise admin UIs from the attacker’s vantage point.",
          "MFA Required and SSO-Only Authentication controls are already satisfied or bypassed for the compromised identities used in this discovery."
        ],
        "constraints_encountered": [
          "MFA Required: may trigger additional prompts (sudo mode, device verification) when viewing or changing sensitive security settings; the attacker must maintain valid second‑factor access.",
          "SSO-Only Authentication: restricts which identities can access sensitive org/enterprise settings, concentrating power in IdP‑managed accounts.",
          "IP Allowlisting: blocks access to security settings and logs from non‑approved networks.",
          "Admin Approval Required and Domain-Based Registration: reduce the chance of the attacker being able to self‑register additional identities for experimentation, but do not prevent introspection using an already‑compromised admin account."
        ],
        "evasion_considerations": [
          "Access security settings and audit logs infrequently and during typical admin working hours to avoid anomalous timing patterns.",
          "Avoid making configuration changes; restrict actions to read‑only viewing to reduce noisy audit log entries.",
          "Prefer using the web UI over heavy API polling when possible, as UI access is indistinguishable from legitimate admin activity.",
          "If API queries are needed (e.g., across many orgs), batch them carefully and respect rate limits to avoid noticeable spikes."
        ],
        "information_discovered": "Effective authentication and account security posture for the tenant: which orgs and enterprises enforce 2FA and SSO, how GitHub accounts are backed by IdP mechanisms, how tokens and SSH keys are managed, and how complementary security controls (code/secret scanning and merge protections) are configured. This allows the attacker to gauge how difficult further account‑based abuse will be and where weaker or less‑protected areas may exist.",
        "comments": "In a SaaS context like GitHub, password policy discovery is principally about understanding 2FA/SSO enforcement and related account security controls rather than raw password complexity; this vector maps that to GitHub’s IAM and security configuration surfaces."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Service Discovery",
        "technique_stix_id": "attack-pattern--e24fcba8-2557-4442-a139-1ee2f2e784db",
        "method_steps": [
          {
            "step_id": 1,
            "description": "For each repository the compromised identity can see, inspect the repository UI and Actions REST API to determine whether GitHub Actions is enabled and actively used (presence of workflow files, Actions tab, workflow runs, logs, and artifacts).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions tab and workflow run history UI (https://docs.github.com/en/actions, https://docs.github.com/en/actions/how-tos/manage-workflow-runs)",
              "Workflow syntax/docs (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
              "REST API: Actions workflows and workflow runs (https://docs.github.com/en/rest/actions/workflow-runs)"
            ],
            "related_data": [
              "Presence and count of workflow definitions (.github/workflows)",
              "Workflow run logs, artifacts, and runner configuration",
              "Events and schedules that trigger workflows"
            ],
            "notes": "Similar to using cloud APIs to enumerate CI/CD services, this step identifies which repos rely on Actions, how often workflows run, and where automation may expose secrets or deployment paths."
          },
          {
            "step_id": 2,
            "description": "Enumerate Codespaces usage and configuration by checking for Codespaces entry points and prebuilds in the repo/org UI, and by using the Codespaces CLI or related APIs where available to list active and recent codespaces linked to repositories.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Projects & Codespaces Automation and Prebuilds",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Codespaces overview and configuration UI (https://docs.github.com/en/codespaces, https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces)",
              "Codespaces prebuilds configuration UI (https://docs.github.com/en/codespaces/prebuilding-your-codespaces)",
              "Codespaces with GitHub CLI docs (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)"
            ],
            "related_data": [
              "List of repositories and branches for which Codespaces can be created",
              "Existing/past codespace instances and usage metadata",
              "Prebuild configurations and machine types/regions (where exposed)"
            ],
            "notes": "Codespaces usage indicates cloud‑hosted development environments tied to repos, which can be high‑value for both developer workflows and potential secret exposure."
          },
          {
            "step_id": 3,
            "description": "Enumerate use of GitHub Packages by listing packages at user, organization, and repository scope via the Packages UI and REST APIs (for example, container images, npm packages, or Maven artifacts) and correlating them back to source repositories.",
            "related_capabilities": [
              "Package Management with GitHub Packages",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Packages UI for users, orgs, and repositories (https://docs.github.com/en/packages)",
              "REST API: Packages category (https://docs.github.com/en/rest/packages/packages)",
              "Container registry docs (https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry)"
            ],
            "related_data": [
              "Package names, ecosystems, and versions",
              "Package visibility and access controls",
              "Links between packages and their source repositories"
            ],
            "notes": "This is analogous to discovering cloud storage and artifact services; it shows where deployable artifacts live and which ecosystems are in play."
          },
          {
            "step_id": 4,
            "description": "Identify GitHub Copilot adoption by observing Copilot Chat and related controls in the GitHub.com UI for repositories and pull requests the compromised identity can access, and by reviewing Copilot documentation and any accessible settings that indicate license assignments or repo‑level enablement.",
            "related_capabilities": [
              "Developer Assistance with GitHub Copilot"
            ],
            "related_interfaces": [
              "Copilot documentation and concepts (https://docs.github.com/en/copilot, https://docs.github.com/en/copilot/concepts/chat)"
            ],
            "related_data": [
              "Repositories and PRs where Copilot Chat or agents are available",
              "High‑level indication of Copilot license presence for the user/org (where visible)"
            ],
            "notes": "GitHub docs indicate Copilot experiences are surfaced in repo and PR UIs; visible Copilot features imply that the service is enabled for those accounts and repositories."
          },
          {
            "step_id": 5,
            "description": "Use the organization security center and related REST APIs to enumerate where security‑oriented services (code scanning, Dependabot, secret scanning, and push protection) are enabled or disabled across repositories.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)",
              "REST API: Code security configurations (https://docs.github.com/en/rest/code-security/configurations)",
              "REST API: Code scanning alerts (https://docs.github.com/en/rest/code-scanning/code-scanning)",
              "REST API: Dependabot alerts (https://docs.github.com/en/rest/dependabot/alerts)",
              "REST API: Secret scanning (https://docs.github.com/en/rest/secret-scanning/secret-scanning)"
            ],
            "related_data": [
              "Per‑repository enablement of code scanning, Dependabot, secret scanning, and push protection",
              "Security configurations applied at org level and their repository coverage"
            ],
            "notes": "This extends service discovery into security services, similar to enumerating GuardDuty or CloudTrail in cloud environments."
          },
          {
            "step_id": 6,
            "description": "Inspect organization and enterprise settings to determine global enablement and restriction policies for GitHub Actions, Codespaces, and other features (for example, allowed actions/runners, whether Codespaces is blocked or restricted to certain repos).",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Organization settings UI (https://docs.github.com/en/organizations)",
              "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)"
            ],
            "related_data": [
              "Org‑ and enterprise‑level policies for Actions, Codespaces, and security products",
              "Feature flags indicating whether services are globally enabled, disabled, or restricted"
            ],
            "notes": "These high‑level settings show which services are strategically adopted and where potential constraints (e.g., disallowing GitHub‑hosted runners) exist."
          },
          {
            "step_id": 7,
            "description": "Query billing and usage dashboards and, where permitted, billing/usage REST APIs to understand consumption of metered GitHub services (Actions minutes, Codespaces hours, Copilot seats), inferring which services are not only enabled but heavily used.",
            "related_capabilities": [
              "Billing & Usage Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Billing dashboards UI (https://docs.github.com/en/billing)",
              "Billing concepts docs (https://docs.github.com/en/billing/get-started/introduction-to-billing, https://docs.github.com/en/billing/get-started/how-billing-works)",
              "REST API: Billing usage (https://docs.github.com/en/rest/billing/usage)"
            ],
            "related_data": [
              "Actions minutes consumption per org/enterprise",
              "Codespaces compute hours and quotas",
              "Copilot seat usage and other relevant metered product usage"
            ],
            "notes": "Usage data is analogous to cloud resource metering and helps prioritize which services and repos are operationally critical."
          },
          {
            "step_id": 8,
            "description": "Enumerate webhooks and GitHub Apps/OAuth apps integrations at repo, org, and enterprise scopes to discover external systems connected to GitHub and infer which internal services generate events (e.g., Actions runs, security alerts, pushes).",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Webhook configuration UIs and docs (https://docs.github.com/en/webhooks)",
              "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
              "REST API: Org webhooks (https://docs.github.com/en/rest/orgs/webhooks)",
              "GitHub Apps/OAuth apps UI (https://docs.github.com/en/apps)",
              "REST API: Apps (https://docs.github.com/en/rest/apps/apps)"
            ],
            "related_data": [
              "Webhook endpoint URLs and subscribed event types",
              "Installed apps, their permissions, and installation scopes",
              "Event categories in use (e.g., workflow, security_alert) that reveal active internal services"
            ],
            "notes": "Webhooks and apps effectively externalize the internal event model; by seeing which events are forwarded, the attacker infers which GitHub services are active and how they integrate with external systems."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Cloud Development Environments with GitHub Codespaces",
          "Projects & Codespaces Automation and Prebuilds",
          "Package Management with GitHub Packages",
          "Developer Assistance with GitHub Copilot",
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management",
          "GitHub REST API",
          "Webhook Event Delivery",
          "GitHub Apps & OAuth Apps Platform"
        ],
        "interfaces_used": [
          "Actions tab and workflows UI (https://docs.github.com/en/actions)",
          "REST API: Actions workflows/runs (https://docs.github.com/en/rest/actions/workflow-runs)",
          "Codespaces UI and prebuild configuration (https://docs.github.com/en/codespaces, https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces, https://docs.github.com/en/codespaces/prebuilding-your-codespaces)",
          "Codespaces with GitHub CLI (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)",
          "Packages UI (https://docs.github.com/en/packages)",
          "REST API: Packages (https://docs.github.com/en/rest/packages/packages)",
          "Copilot docs and UI surfaces (https://docs.github.com/en/copilot, https://docs.github.com/en/copilot/concepts/chat)",
          "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)",
          "REST API: Code security configurations (https://docs.github.com/en/rest/code-security/configurations)",
          "REST API: Code scanning (https://docs.github.com/en/rest/code-scanning/code-scanning)",
          "REST API: Dependabot alerts (https://docs.github.com/en/rest/dependabot/alerts)",
          "REST API: Secret scanning (https://docs.github.com/en/rest/secret-scanning/secret-scanning)",
          "Organization settings UI (https://docs.github.com/en/organizations)",
          "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
          "Billing dashboards UI (https://docs.github.com/en/billing)",
          "REST API: Billing usage (https://docs.github.com/en/rest/billing/usage)",
          "Webhook configuration UIs and APIs (https://docs.github.com/en/webhooks, https://docs.github.com/en/rest/orgs/webhooks, https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
          "GitHub Apps/OAuth apps UI and APIs (https://docs.github.com/en/apps, https://docs.github.com/en/rest/apps/apps)"
        ],
        "data_accessed": [
          "Workflow definitions, run metadata, logs, artifacts, and runner configuration for GitHub Actions",
          "Codespaces instances, prebuild configurations, and associated repositories/branches",
          "Package metadata and registries in use across the tenant",
          "Presence and scope of Copilot features for repositories and users (as visible to the compromised account)",
          "Per‑repository and org‑level enablement of code scanning, Dependabot, secret scanning, and push protection",
          "Org/enterprise policies governing Actions, Codespaces, and security services",
          "Usage metrics for Actions minutes, Codespaces hours, and Copilot seats",
          "Webhook endpoints, subscribed events, and app installations and permissions"
        ],
        "preconditions_required": [
          "Compromised identity must have at least read access to repositories in order to see Actions, Codespaces, Packages, and security tabs.",
          "To see org‑wide configuration of Actions, Codespaces, and some security features, the identity should be an organization owner/administrator.",
          "Enterprise‑wide service usage and policies require an enterprise owner/administrator account.",
          "Access to billing and usage dashboards/APIs requires billing manager or equivalent roles on the org/enterprise.",
          "IP Allowlisting must permit access from the attacker’s vantage point to GitHub UI and APIs.",
          "MFA Required and SSO-Only Authentication are already satisfied for the compromised identities used."
        ],
        "constraints_encountered": [
          "Role-based access: non‑admin users may only see service enablement for repos they can access, not global org/enterprise policies or billing usage.",
          "Billing data access is restricted to billing managers and similar roles, limiting direct visibility into usage metrics without such a compromise.",
          "IP Allowlisting: may prevent API/UI access from untrusted networks, forcing the attacker to route discovery through an allowed host or runner.",
          "Rate Limiting: heavy API‑based enumeration of workflows, codespaces, packages, and alerts must be rate‑limit aware."
        ],
        "evasion_considerations": [
          "Sample repositories and services first using UI inspection to narrow where deeper API enumeration is needed.",
          "Throttle API calls and distribute them over time and across tokens to avoid conspicuous spikes.",
          "Leverage existing automation (e.g., internal observability Actions workflows or security reporting tools) where compromised, rather than adding new noisy enumeration logic.",
          "Avoid enabling or disabling services; limit actions to read‑only inspection of where services are currently in use.",
          "Align discovery activity with normal reporting or maintenance windows when admin and DevOps teams commonly review CI/CD and billing dashboards."
        ],
        "information_discovered": "A comprehensive inventory of which GitHub SaaS services and integrations are in use for the tenant: where Actions, Codespaces, Packages, Copilot, and security products are enabled; which policies govern them; how heavily they are consumed; and which external systems are integrated via webhooks and apps. This gives the attacker a clear picture of the operational and integration surface of the tenant.",
        "comments": "This vector corresponds directly to Cloud Service Discovery in the SaaS matrix and also underpins later security‑focused discovery (for example, which defense services are active and where)."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Service Discovery (Security Posture Focus)",
        "technique_stix_id": "attack-pattern--e24fcba8-2557-4442-a139-1ee2f2e784db",
        "method_steps": [
          {
            "step_id": 1,
            "description": "As an organization security manager or owner, open the organization’s security center to view aggregated security configurations, secret risk assessments, vulnerability exposure metrics, and any configured remediation campaigns.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Org security center UI and docs (https://docs.github.com/en/code-security/securing-your-organization)"
            ],
            "related_data": [
              "Lists of repositories and their security feature status (code scanning, Dependabot, secret scanning, push protection)",
              "Secret risk assessment summaries",
              "Vulnerability exposure metrics and prioritized risk views",
              "Definitions and progress of security campaigns"
            ],
            "notes": "This step uses GitHub’s own dashboards as a consolidated view of the tenant’s security posture, similar to using a cloud security center dashboard to understand coverage and risk."
          },
          {
            "step_id": 2,
            "description": "Use the code security configurations REST API to enumerate all security configurations defined in the organization (or across orgs if enterprise‑level access is available) and list which repositories each configuration applies to.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "REST API: Code security configurations (https://docs.github.com/en/rest/code-security/configurations)",
              "REST API overview (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
            ],
            "related_data": [
              "Security configuration objects (code scanning, secret scanning, Dependabot, push protection policies)",
              "Repository lists attached to each configuration"
            ],
            "notes": "This provides a machine‑readable mapping of security policies to repos, enabling offline analysis of coverage gaps."
          },
          {
            "step_id": 3,
            "description": "Enumerate code scanning alerts across repositories using the code scanning REST API and per‑repository Security tabs to understand where vulnerabilities exist, their severities, and which repos are protected by merge protections based on scanning results.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Repository/organization Security tab for code scanning (https://docs.github.com/en/code-security/code-scanning)",
              "REST API: Code scanning alerts (https://docs.github.com/en/rest/code-scanning/code-scanning)",
              "Merge protection configuration docs (https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/set-code-scanning-merge-protection)"
            ],
            "related_data": [
              "Code scanning alerts (rule IDs, severity, location, state)",
              "Merge protection settings tied to code scanning results",
              "Repositories lacking or partially using code scanning"
            ],
            "notes": "This is akin to enumerating vulnerability management data from a central scanner; it highlights high‑value targets (critical vulnerabilities) and weak spots (unscanned repos)."
          },
          {
            "step_id": 4,
            "description": "Enumerate Dependabot alerts via the Dependabot REST API and security views to map dependency‑related vulnerabilities across repositories and understand where auto‑remediation jobs are running or failing.",
            "related_capabilities": [
              "Dependency & Supply Chain Management with Dependabot",
              "Automated Dependency & Security Remediation Jobs",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Dependabot alerts UI (https://docs.github.com/en/code-security/dependabot/dependabot-alerts/viewing-and-updating-dependabot-alerts)",
              "Dependabot configuration docs (https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuring-dependabot-version-updates)",
              "REST API: Dependabot alerts (https://docs.github.com/en/rest/dependabot/alerts)"
            ],
            "related_data": [
              "Dependabot vulnerability alerts (ecosystem, package, affected versions, severity, state)",
              "Repositories with and without Dependabot enabled",
              "Automated remediation PR presence and status"
            ],
            "notes": "This shows where dependency risk is concentrated and whether remediation workflows are active and effective."
          },
          {
            "step_id": 5,
            "description": "Enumerate secret scanning alerts and push protection data via the secret scanning UI and REST API to understand where sensitive credentials have been detected, which repositories are covered by push protection, and where bypasses have occurred.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Secret scanning overview and management UI (https://docs.github.com/en/code-security/secret-scanning)",
              "Push protection workflow docs (https://docs.github.com/en/code-security/secret-scanning/working-with-secret-scanning-and-push-protection)",
              "REST API: Secret scanning (https://docs.github.com/en/rest/secret-scanning/secret-scanning)"
            ],
            "related_data": [
              "Secret scanning alerts (secret types, locations, state)",
              "Push protection enablement per repository",
              "Bypass and dismissal metadata (e.g., who bypassed, reasons)"
            ],
            "notes": "This pinpoints where credentials have leaked historically and where controls are strongest or weakest, informing which repos may yield more secrets."
          },
          {
            "step_id": 6,
            "description": "Correlate branch protection and merge protection settings (including required checks) from repo settings with security scanning data to identify critical branches that lack strong protections or rely on weak checks.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines"
            ],
            "related_interfaces": [
              "Repository settings UI for branch protection and rulesets (https://docs.github.com/en/repositories)",
              "Code scanning merge protection docs (https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/set-code-scanning-merge-protection)"
            ],
            "related_data": [
              "Branch and ruleset configurations for protected branches",
              "Required status checks and their relation to security scanning results"
            ],
            "notes": "Combining this with alert data lets an attacker spot repos where vulnerable code can still be merged despite known issues."
          },
          {
            "step_id": 7,
            "description": "If org or enterprise global webhooks are configured to forward security‑related events, inspect these configurations and (if possible and acceptable from a stealth perspective) add or piggyback on endpoints to receive a live feed of security alerts and configuration changes.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
              "Org/enterprise webhook configuration UIs (https://docs.github.com/en/webhooks, https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)"
            ],
            "related_data": [
              "Webhook subscriptions for security‑relevant events (e.g., security_alert events where available)",
              "Webhook endpoints receiving those events",
              "Live streams of security alert notifications, if the attacker can access or configure endpoints"
            ],
            "notes": "This shifts from one‑time enumeration to continuous monitoring of the tenant’s security posture changes; configuration changes here are more detectable but powerful."
          }
        ],
        "capabilities_used": [
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines",
          "Repository Management & Source Code Hosting",
          "Webhook Event Delivery",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)",
          "REST API: Code security configurations (https://docs.github.com/en/rest/code-security/configurations)",
          "Code scanning UI and REST API (https://docs.github.com/en/code-security/code-scanning, https://docs.github.com/en/rest/code-scanning/code-scanning)",
          "Dependabot UIs and REST API (https://docs.github.com/en/code-security/dependabot, https://docs.github.com/en/rest/dependabot/alerts)",
          "Secret scanning and push protection UIs and REST API (https://docs.github.com/en/code-security/secret-scanning, https://docs.github.com/en/code-security/secret-scanning/working-with-secret-scanning-and-push-protection, https://docs.github.com/en/rest/secret-scanning/secret-scanning)",
          "Repository settings UI for branch protection/rulesets (https://docs.github.com/en/repositories)",
          "Webhook configuration and events docs (https://docs.github.com/en/webhooks, https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
          "Enterprise global webhooks UI (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)",
          "REST API overview (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
        ],
        "data_accessed": [
          "Cross‑repo security configurations and their repository coverage",
          "Code scanning alerts and SARIF‑based analysis results",
          "Dependabot vulnerability alerts, affected packages, and remediation status",
          "Secret scanning alerts, secret types, and push protection coverage and bypasses",
          "Branch and merge protection rule configurations, especially those tied to security checks",
          "Webhook subscriptions for security‑related events and their delivery endpoints"
        ],
        "preconditions_required": [
          "Attacker must control at least one organization owner or organization security manager account to access the org security center and related configuration APIs.",
          "Cross‑org or enterprise‑wide views require an enterprise owner/administrator account.",
          "Repositories must have GitHub Advanced Security features (code scanning, secret scanning) and/or Dependabot enabled for corresponding data to exist.",
          "Permissions to read security APIs (alerts and configurations) via REST require appropriately scoped tokens or app installations.",
          "To view or modify global webhooks, the compromised identity must have org/enterprise admin privileges.",
          "IP Allowlisting, if enabled, must allow access from the environment where enumeration is performed."
        ],
        "constraints_encountered": [
          "Feature licensing: some security features (e.g., Advanced Security) may only be enabled on a subset of repos; other repos will not yield data even if accessible.",
          "Role-based access control: only specific roles can access org security center, configuration APIs, or enterprise‑level policies; lower‑privileged accounts will see only per‑repo views.",
          "IP Allowlisting: may restrict access to security dashboards and APIs from non‑approved networks.",
          "Rate Limiting: large‑scale polling of security APIs must respect API quotas and may require batching.",
          "MFA Required and SSO-Only Authentication: restrict which admin accounts are realistically compromisable but do not significantly impede read‑only security posture enumeration once compromised."
        ],
        "evasion_considerations": [
          "Rely on existing dashboards for initial insight and only use APIs to export data when necessary, reducing the need for bulk API queries.",
          "Limit API calls to incremental updates (e.g., alerts modified since a recent timestamp) instead of full scans on every run.",
          "Hide continuous monitoring behind a legitimate‑looking GitHub App or internal security automation that already expects to receive security events.",
          "Avoid changing security configurations or campaigns; confine actions to viewing and exporting data.",
          "Schedule heavier data pulls for times when security teams are likely to run their own scans and exports, blending into expected traffic."
        ],
        "information_discovered": "A consolidated view of the tenant’s defensive posture: which repos are covered by which security configurations, where vulnerabilities and secrets have been detected (and in what volume/severity), how strongly branches are protected by security checks, and how security events are streamed externally. This lets the attacker prioritize weakly defended repositories and understand where security monitoring is strongest.",
        "comments": "This vector emphasizes Cloud Service Discovery applied specifically to GitHub’s security and risk‑management services and closely aligns with the SaaS discovery of logging and security services in other cloud providers."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Service Dashboard",
        "technique_stix_id": "attack-pattern--e49920b0-6c54-40c1-9571-73723653205f",
        "method_steps": [
          {
            "step_id": 1,
            "description": "With a compromised enterprise owner or admin account, access the Enterprise Cloud admin console to review high‑level dashboards summarizing organizations, policies, usage, and monitoring across the enterprise.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "Billing introduction docs (https://docs.github.com/en/billing/get-started/introduction-to-billing)"
            ],
            "related_data": [
              "List of organizations under the enterprise",
              "Enterprise‑wide policies for Actions, security, and repositories",
              "High‑level usage and billing summaries"
            ],
            "notes": "This is directly analogous to using a cloud provider’s management console or security center dashboard to gain a top‑down view of the tenant."
          },
          {
            "step_id": 2,
            "description": "Within the enterprise admin console, review monitoring and global webhook configurations to understand how activity is centrally observed and where event data (including security and membership events) is sent.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Enterprise monitoring and global webhooks UI (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)",
              "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)"
            ],
            "related_data": [
              "Global webhook endpoints and their destinations",
              "Event types subscribed at enterprise scope"
            ],
            "notes": "These dashboards reveal which events the organization considers important and which external systems are part of the observability stack."
          },
          {
            "step_id": 3,
            "description": "For each target organization, open the organization security center dashboard to view summarized security posture, including security feature coverage, secret risk, vulnerability exposure, and campaign status.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)"
            ],
            "related_data": [
              "Aggregate counts and percentages of repos with security features enabled",
              "Risk scores or categorizations per repository or feature area",
              "Campaign progress metrics"
            ],
            "notes": "This step provides an at‑a‑glance heat map of where repositories are most exposed without requiring raw alert exports."
          },
          {
            "step_id": 4,
            "description": "Access organization‑level settings dashboards for members, teams, repositories, and feature flags (Actions, Codespaces, security features) to understand structural configuration and which capabilities are broadly enabled or constrained.",
            "related_capabilities": [
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Organization settings UI (https://docs.github.com/en/organizations)"
            ],
            "related_data": [
              "Counts of members, teams, and outside collaborators",
              "Default repository permission settings",
              "Org‑level enablement or restriction of Actions, Codespaces, and other features"
            ],
            "notes": "These dashboards quickly reveal whether the org is permissive (e.g., broad base read access, Actions enabled for all repos) or tightly locked down."
          },
          {
            "step_id": 5,
            "description": "On selected high‑value repositories, use the repo overview, Security tab, Actions tab, Codespaces entry points, and Packages tab to visually confirm which features are enabled and to spot indicators such as frequent workflow runs, many security alerts, or active Codespaces usage.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)",
              "Cloud Development Environments with GitHub Codespaces",
              "Package Management with GitHub Packages",
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Repository overview and settings UI (https://docs.github.com/en/repositories)",
              "Repository Security tab (https://docs.github.com/en/code-security/code-scanning, https://docs.github.com/en/code-security/dependabot, https://docs.github.com/en/code-security/secret-scanning)",
              "Actions tab (https://docs.github.com/en/actions)",
              "Codespaces UI (https://docs.github.com/en/codespaces)",
              "Packages UI (https://docs.github.com/en/packages)"
            ],
            "related_data": [
              "Per‑repo visibility and collaborator summary",
              "Visible counts of security alerts and workflow runs",
              "Presence of Codespaces and prebuild indicators",
              "Presence of published packages associated with the repo"
            ],
            "notes": "This provides a rapid, visual triage of which repos are most active and potentially valuable, without having to parse raw API responses."
          },
          {
            "step_id": 6,
            "description": "Review billing and usage dashboards for organizations and the enterprise to quickly identify which services (Actions, Codespaces, Copilot) are consuming the most resources and which organizations or repos are associated with that spend.",
            "related_capabilities": [
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Billing dashboards and usage views (https://docs.github.com/en/billing, https://docs.github.com/en/billing/get-started/how-billing-works)"
            ],
            "related_data": [
              "Service‑specific usage trends (Actions minutes, Codespaces hours, Copilot seats)",
              "Breakdowns by organization or project where available"
            ],
            "notes": "Heavy usage often correlates with critical workloads and developer activity, helping prioritize where further detailed discovery should focus."
          },
          {
            "step_id": 7,
            "description": "For the compromised user account, open its authentication/security dashboard to visually assess how hardened the account is relative to organizational norms (2FA status, passkeys, active sessions, tokens), informing how risky continued use of that identity may be.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "User account security UI (https://docs.github.com/en/authentication)"
            ],
            "related_data": [
              "2FA status and methods for the compromised account",
              "Active sessions and recent security events",
              "List of tokens and SSH keys (metadata only)"
            ],
            "notes": "While already compromised, understanding the account’s visible strength helps gauge how likely defenders are to notice or reset it."
          }
        ],
        "capabilities_used": [
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Automation with GitHub Actions (User Perspective)",
          "Cloud Development Environments with GitHub Codespaces",
          "Package Management with GitHub Packages",
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection",
          "Billing & Usage Management",
          "Webhook Event Delivery",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Enterprise Cloud admin UI (https://docs.github.com/en/enterprise-cloud@latest/admin)",
          "Enterprise monitoring/global webhooks UI (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)",
          "Org security center UI (https://docs.github.com/en/code-security/securing-your-organization)",
          "Organization settings UI (https://docs.github.com/en/organizations)",
          "Repository overview/settings UI (https://docs.github.com/en/repositories)",
          "Security tab UIs for code scanning, Dependabot, and secret scanning (https://docs.github.com/en/code-security/code-scanning, https://docs.github.com/en/code-security/dependabot, https://docs.github.com/en/code-security/secret-scanning)",
          "Actions tab UI (https://docs.github.com/en/actions)",
          "Codespaces UI (https://docs.github.com/en/codespaces)",
          "Packages UI (https://docs.github.com/en/packages)",
          "Billing dashboards and docs (https://docs.github.com/en/billing, https://docs.github.com/en/billing/get-started/how-billing-works)",
          "User account security UI (https://docs.github.com/en/authentication)",
          "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)"
        ],
        "data_accessed": [
          "Enterprise organization inventory and high‑level policy summaries",
          "Global webhook destinations and event subscriptions",
          "Org‑level security coverage and risk summaries",
          "Org‑level counts of members, teams, and repositories and high‑level feature enablement",
          "Per‑repository high‑level indicators of security alerts, Actions usage, Codespaces enablement, and packages",
          "Billing and usage trends for Actions, Codespaces, Copilot, and other metered features",
          "Compromised account’s visible security posture and session state"
        ],
        "preconditions_required": [
          "To see enterprise dashboards and global monitoring, the attacker must control an Enterprise Cloud owner/administrator account.",
          "To see organization security center and org settings, the attacker must control an organization owner/admin or designated security manager account.",
          "To see detailed billing dashboards, the attacker must have billing manager or equivalent privileges.",
          "To access repository‑level dashboards, the attacker must have at least read access to the repositories in question.",
          "IP Allowlisting must allow access to admin and billing UIs from the attacker’s network location.",
          "MFA Required and SSO-Only Authentication controls must be satisfied for the high‑privilege accounts used."
        ],
        "constraints_encountered": [
          "Permissions are coarse at the dashboard level: users without enterprise/org admin or billing roles cannot see the most informative top‑level dashboards.",
          "IP Allowlisting may restrict access to admin and billing consoles from untrusted IPs.",
          "Admin Approval Required and Domain-Based Registration reduce the attacker’s ability to self‑provision new high‑privilege accounts to view dashboards, increasing dependence on existing compromised admins.",
          "Rate Limiting is less of a factor because dashboards are UI‑driven and aggregate, but underlying API calls may still be constrained if programmatically scraped."
        ],
        "evasion_considerations": [
          "Use dashboards interactively within normal business hours when legitimate admins are expected to access them.",
          "Avoid exporting large data sets from dashboards if possible; rely on visual inspection and selective screenshotting or note‑taking to prevent conspicuous download or API activity.",
          "Do not modify webhook destinations or enterprise/org settings from dashboard views; remain read‑only to limit detectable changes.",
          "Spread out visits across days or weeks to avoid creating a dense cluster of admin console access events."
        ],
        "information_discovered": "High‑level, rapidly digestible understanding of the entire tenant: which organizations exist and how they are governed, how security features and monitoring are deployed, where developer and security activity is concentrated, and the relative hardness of individual accounts and repos. This contextual view allows the attacker to prioritize detailed follow‑on discovery and potential future actions.",
        "comments": "This vector directly implements the Cloud Service Dashboard technique by abusing GitHub’s enterprise, organization, and repository dashboards instead of relying solely on raw APIs."
      }
    ],
    "summary": "Given GitHub’s documented capabilities, an attacker who has already obtained valid authenticated access (user account, token, or app) can achieve extensive Discovery across the tenant. They can enumerate user and app accounts and their memberships (Account/Cloud Account Discovery); map teams, enterprise teams, base permissions, branch protections, and app scopes (Permission Groups/Cloud Groups Discovery); understand authentication and account security posture including 2FA/SSO enforcement and complementary security features (Password Policy Discovery in a SaaS sense); inventory all major services and integrations in use such as Actions, Codespaces, Packages, Copilot, security products, webhooks, and apps (Cloud Service Discovery); and, via GitHub’s own enterprise/org/repo dashboards, obtain aggregated views of configuration, usage, and security risk (Cloud Service Dashboard). Environment constraints like MFA, SSO‑only login, IP allowlisting, rate limiting, and restricted registration primarily constrain which identities can be compromised and where enumeration traffic can originate, but do not prevent discovery once a suitably privileged, in‑scope identity and network vantage point are controlled. The net effect is that GitHub exposes rich, well‑documented administrative and security surfaces that, while essential for legitimate operations, also provide a powerful lens for adversarial discovery when abused by a compromised admin or automation identity."
  },
  "execution": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Serverless Execution",
        "technique_stix_id": "attack-pattern--e848506b-8484-4410-8017-3d235a52f5b3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain or compromise a GitHub identity (user account, personal access token, fine‑grained token, or GitHub App installation) that has write/maintain/admin access to the target repository so it can modify files under .github/workflows.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Organization & Team Administration",
              "GitHub Apps & OAuth Apps Platform",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "User security settings UI for managing passwords, 2FA, passkeys, SSH keys, and tokens (https://docs.github.com/en/authentication)",
              "Organization settings UI for managing members, teams, and repository access (https://docs.github.com/en/organizations)",
              "Git operations (SSH/HTTPS) to push commits to repositories (https://docs.github.com/en/get-started/git-basics/set-up-git)",
              "GitHub Apps registration/installation UI and APIs (https://docs.github.com/en/apps)"
            ],
            "related_data": [
              "User identities and credentials (tokens, SSH keys)",
              "Repository collaborator and team permissions",
              "Repositories and their contents, including .github/workflows"
            ],
            "notes": "Environment constraints such as MFA Required, SSO-Only Authentication, Domain-Based Registration, Email Verification Required, Admin Approval Required, IP Allowlisting, CAPTCHA Protection, and Rate Limiting primarily affect how this identity was obtained; this vector assumes those have already been satisfied or bypassed."
          },
          {
            "step_id": 2,
            "description": "Confirm that GitHub Actions is enabled for the organization and repository, and that GitHub-hosted runners are allowed for this repo.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Repository Actions tab in the web UI (https://docs.github.com/en/actions)",
              "Organization and enterprise settings UIs for Actions policies and feature flags (https://docs.github.com/en/organizations, https://docs.github.com/en/enterprise-cloud@latest/admin)"
            ],
            "related_data": [
              "Org- and enterprise-level Actions policies (allowed actions, runner types)",
              "Repository-level Actions configuration"
            ],
            "notes": "If org or enterprise policies disable Actions or GitHub-hosted runners for this repo, the attacker must first change those settings (requiring higher privileges) or choose a different target."
          },
          {
            "step_id": 3,
            "description": "Create or modify a workflow file under .github/workflows in the target repository, defining jobs that use GitHub-hosted runners (for example, runs-on labels pointing to ubuntu/macOS/Windows hosted runners) and steps that execute attacker-controlled shell commands or scripts.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Workflow YAML files under .github/workflows authored via Git push or the web editor (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
              "Repository code browser and file editor in the web UI (https://docs.github.com/en/repositories)"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Repository source files and scripts referenced by workflow steps"
            ],
            "notes": "Workflows can include inline shell commands in run: steps or invoke scripts from the repository, directly enabling arbitrary command execution on the selected GitHub-hosted runner images."
          },
          {
            "step_id": 4,
            "description": "Optionally configure the workflow to receive and use repository/org/environment secrets and the GITHUB_TOKEN, providing the executed commands with credentials and configuration they can abuse (for example, to reach external systems or modify other GitHub resources).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Actions workflow syntax for environment variables, secrets, and permissions (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
              "Repository and organization secrets configuration UIs in the Security/Settings areas"
            ],
            "related_data": [
              "Secrets and environment variables available to workflows",
              "GITHUB_TOKEN scoped to the repository or environment"
            ],
            "notes": "Secrets are not required for code execution but amplify impact. Secret misuse is constrained by Actions policies and repository/organization settings."
          },
          {
            "step_id": 5,
            "description": "Commit and push the modified or new workflow to a branch that is eligible to run Actions (for example, the default branch or another branch referenced by workflow triggers), merging via pull request if branch protection requires review.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Pull Requests & Code Review Workflow"
            ],
            "related_interfaces": [
              "Git push over SSH/HTTPS (https://docs.github.com/en/get-started/git-basics/set-up-git)",
              "Pull request creation and merge UI (https://docs.github.com/en/pull-requests)"
            ],
            "related_data": [
              "Commits and branches containing the workflow definitions",
              "Pull requests and review metadata"
            ],
            "notes": "Audit logs and PR history will reflect these changes; subtle edits to existing CI workflows are harder to spot than entirely new, obviously malicious workflows."
          },
          {
            "step_id": 6,
            "description": "Trigger the workflow so the runner executes the attacker-controlled commands—via an event (push, pull request), a scheduled trigger, or an explicit workflow_dispatch request from the Actions UI or REST API.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions run management UI (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)",
              "REST API endpoints for workflow runs and dispatches (https://docs.github.com/en/rest/actions/workflow-runs, https://docs.github.com/en/rest/actions/workflows)"
            ],
            "related_data": [
              "Job execution metadata and logs",
              "Artifacts or caches produced by the workflow"
            ],
            "notes": "From the MITRE ATT&CK perspective, this corresponds to creating and invoking a serverless-like workload; analogous to adversaries creating malicious cloud functions that run on provider-managed compute."
          },
          {
            "step_id": 7,
            "description": "Harvest outputs from the run (logs, artifacts, side effects on external systems) and, if desired, configure cron-style scheduled triggers or additional event triggers to obtain ongoing or periodic code execution.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Actions run logs and artifact download UI",
              "REST API for workflow runs and artifacts (https://docs.github.com/en/rest/actions/workflow-runs)",
              "Billing and usage dashboards for monitoring Actions minutes (https://docs.github.com/en/billing)"
            ],
            "related_data": [
              "Workflow logs and artifacts",
              "Billing and Actions usage metrics"
            ],
            "notes": "Repeated or long-running workloads may surface in billing or usage alerts; an attacker may keep runs short or align them with expected CI activity to reduce suspicion."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Pull Requests & Code Review Workflow",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management",
          "Billing & Usage Management"
        ],
        "interfaces_used": [
          "Git operations (SSH/HTTPS) to push commits to repositories",
          "Web UI: Repository code browser and file editor (https://docs.github.com/en/repositories)",
          "Web UI: Actions tab in repositories (https://docs.github.com/en/actions)",
          "Workflow YAML files under .github/workflows using the documented workflow syntax (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
          "REST API: Actions workflows endpoints (https://docs.github.com/en/rest/actions/workflows)",
          "REST API: Workflow runs and artifacts endpoints (https://docs.github.com/en/rest/actions/workflow-runs)",
          "Organization and enterprise Actions settings UIs (https://docs.github.com/en/organizations, https://docs.github.com/en/enterprise-cloud@latest/admin)"
        ],
        "data_accessed": [
          "Workflow definitions (YAML) stored under .github/workflows",
          "Repository source code, scripts, and configuration files",
          "Secrets and environment variables exposed to GitHub Actions workflows",
          "Job execution logs, artifacts, and caches in Actions storage",
          "Runner configuration and labels",
          "Org and enterprise Actions policy documents"
        ],
        "preconditions_required": [
          "Attacker controls or has compromised a GitHub identity (user, PAT, fine-grained token, or GitHub App) with write/maintain/admin rights on the target repository.",
          "GitHub Actions is enabled for the target organization and repository, and policies allow use of GitHub-hosted runners.",
          "The environment’s MFA, SSO-only authentication, domain-based registration, email verification, admin approval, CAPTCHA, and IP allowlisting requirements have been satisfied or bypassed for the compromised identity.",
          "Actions and billing quotas permit additional workflow runs without immediate hard stops."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Email Verification Required",
          "Admin Approval Required",
          "IP Allowlisting",
          "Rate Limiting",
          "CAPTCHA Protection"
        ],
        "evasion_considerations": [
          "Blend malicious steps into existing CI workflows (for example, extending build/test jobs) rather than adding obviously suspicious new workflows.",
          "Name workflows and jobs consistently with existing conventions and trigger them on normal events (push, pull_request) instead of unusual schedules to avoid attracting review.",
          "Minimize noisy output in workflow logs and avoid printing clear-text secrets; exfiltrate via outbound network connections instead of logs or artifacts.",
          "Use already-legitimate accounts and tokens rather than creating new ones, so access patterns look like normal developer or automation activity.",
          "Keep run durations modest to avoid standing out in Actions billing or usage reports."
        ],
        "comments": "This is the primary and most direct execution vector in GitHub: arbitrary command/script execution on GitHub-hosted runners via attacker-controlled Actions workflows. It closely matches MITRE’s Serverless Execution technique, where adversaries deploy and invoke provider-managed compute with custom code.",
        "execution_result": "Arbitrary attacker-controlled commands and scripts execute on GitHub-hosted Actions runners in the context of the target repository, with access to its contents and any configured workflow secrets."
      },
      {
        "can_achieve": true,
        "technique_name": "Serverless Execution",
        "technique_stix_id": "attack-pattern--e848506b-8484-4410-8017-3d235a52f5b3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use a GitHub account (for example, a normal contributor account) that can fork the target repository or create branches and open pull requests, without needing write access to the upstream default branch.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Pull Requests & Code Review Workflow",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Git operations for forking and pushing to forks (https://docs.github.com/en/get-started/git-basics/set-up-git)",
              "Pull request creation UI (https://docs.github.com/en/pull-requests)"
            ],
            "related_data": [
              "Forked repositories and branches",
              "Pull request metadata and diffs"
            ],
            "notes": "MFA, SSO-only authentication, domain-based registration, email verification, CAPTCHA, admin approval, IP allowlisting, and rate limiting all apply to obtaining and using this contributor account but do not prevent normal forking and PR creation once the account exists."
          },
          {
            "step_id": 2,
            "description": "Inspect the target repository’s existing workflows under .github/workflows (via the web UI or cloning) and Actions configuration to identify workflows triggered by events under attacker control, such as pull_request or pushes to branches reachable from a fork.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Repository code browser for .github/workflows/* (https://docs.github.com/en/repositories)",
              "Actions tab showing workflow list and triggers (https://docs.github.com/en/actions)"
            ],
            "related_data": [
              "Existing workflow YAML definitions",
              "Repository build/test scripts and configuration files used by workflows"
            ],
            "notes": "The background_jobs_and_automation description notes that misconfigured pull_request workflows, especially involving forks, can be abused; those are prime targets."
          },
          {
            "step_id": 3,
            "description": "Analyze the identified workflows to determine how they execute repository-controlled code (for example, running language-specific test commands, build scripts, or tooling from the branch’s code) and whether they use GitHub-hosted runners with access to secrets or powerful GITHUB_TOKEN scopes.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Code Scanning for Static Application Security Testing"
            ],
            "related_interfaces": [
              "Workflow syntax and Actions concepts documentation (https://docs.github.com/en/actions/concepts/workflows-and-actions, https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)"
            ],
            "related_data": [
              "Workflow job and step definitions",
              "Secrets configuration referenced by workflows",
              "Repository build/test tooling invoked by workflows"
            ],
            "notes": "Even if secrets are not exposed to fork-based workflows, any code path that runs untrusted repository content on a GitHub-hosted runner can be hijacked for arbitrary command execution within that job."
          },
          {
            "step_id": 4,
            "description": "Modify code, scripts, or configuration files in the attacker-controlled branch or fork that are used by the workflow (for example, test scripts, build scripts, or custom tooling) so that when the workflow runs it executes additional attacker-specified commands on the GitHub-hosted runner.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Git commit and push from attacker’s local environment to their fork or branch"
            ],
            "related_data": [
              "Repository source code, build/test scripts, configuration files"
            ],
            "notes": "The workflow YAML itself remains unchanged; the attacker instead abuses the fact that workflows trust and execute repository code from untrusted branches."
          },
          {
            "step_id": 5,
            "description": "Open a pull request or otherwise trigger the event that causes the existing workflow to run against the attacker-controlled branch or fork, ensuring that CI is enabled for contributions from that source.",
            "related_capabilities": [
              "Pull Requests & Code Review Workflow",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Pull request creation UI and related REST APIs (https://docs.github.com/en/pull-requests, https://docs.github.com/en/rest/pulls/pulls)",
              "Actions run management UI to observe triggered runs (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)"
            ],
            "related_data": [
              "Pull request records",
              "Workflow run metadata and status"
            ],
            "notes": "Repository or organization policies may restrict whether Actions run automatically for forks (for example, requiring manual approval); if so, the attacker relies on maintainers approving the run."
          },
          {
            "step_id": 6,
            "description": "Allow the normal CI workflow to execute on GitHub-hosted runners; during the run, the modified scripts or tooling from the attacker-controlled branch execute arbitrary commands within the job context.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Actions run logs and artifacts view",
              "REST API for workflow runs (https://docs.github.com/en/rest/actions/workflow-runs)"
            ],
            "related_data": [
              "Job logs and artifacts",
              "Any secrets or tokens made available to the job (depending on org policies)"
            ],
            "notes": "This mirrors real-world abuses of misconfigured CI pipelines on untrusted contributions: the workflow appears legitimate but executes attacker-controlled logic embedded in repository code."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Pull Requests & Code Review Workflow",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "GitHub REST API",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Git forking and pushing over SSH/HTTPS",
          "Web UI: Pull request creation and review",
          "Web UI: Actions tab and workflow run details",
          "Repository code browser for viewing .github/workflows and project scripts"
        ],
        "data_accessed": [
          "Existing workflow definitions under .github/workflows",
          "Repository scripts and build/test tooling invoked by workflows",
          "Pull request metadata and diffs",
          "Workflow logs and artifacts",
          "Any workflow-exposed secrets or tokens, if policies permit"
        ],
        "preconditions_required": [
          "Target repository accepts contributions from the attacker (for example, via forks or direct branches) and uses GitHub Actions for CI on those contributions.",
          "Existing workflows execute repository-controlled code (tests, builds, scripts) on GitHub-hosted runners when triggered by attacker-controllable events.",
          "Organization/repository Actions policies permit workflows to run for the attacker’s contribution path (for example, forks), even if they do not expose secrets.",
          "Attacker has an authenticated GitHub account that satisfies MFA/SSO, domain, email, CAPTCHA, and IP restrictions in the environment."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Email Verification Required",
          "Admin Approval Required",
          "IP Allowlisting",
          "Rate Limiting",
          "CAPTCHA Protection"
        ],
        "evasion_considerations": [
          "Submit changes that look like normal test or build modifications to reduce the chance that reviewers inspect them closely.",
          "Target popular public repositories where many external pull requests and CI runs are expected, so malicious runs blend into normal volume.",
          "Avoid obviously malicious code in repository files; for example, hide payloads inside complex build or test tooling that appears legitimate.",
          "Limit the number and frequency of triggered CI runs to avoid drawing attention from maintainers or billing/usage monitoring."
        ],
        "comments": "This vector achieves code execution on GitHub-hosted runners without needing direct write access to workflow YAML by abusing how existing workflows run untrusted repository code on CI. It is particularly relevant for public/open-source repositories and reflects common CI abuse patterns.",
        "execution_result": "Attacker-controlled logic embedded in repository code executes on GitHub-hosted Actions runners when existing CI workflows run on attacker-triggered events such as pull requests."
      },
      {
        "can_achieve": true,
        "technique_name": "Software Deployment Tools",
        "technique_stix_id": "attack-pattern--92a78814-b191-47ca-909c-1ccfe3777414",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify repositories or organizations that use self-hosted GitHub Actions runners, which typically appear in Actions runner settings or in workflow configuration specifying self-hosted or custom runner labels.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Actions runner configuration and settings in the repository or organization UI (part of https://docs.github.com/en/actions and org settings)",
              "Workflow YAML definitions referencing self-hosted runner labels"
            ],
            "related_data": [
              "Runner configuration and labels",
              "Workflow definitions indicating which runners jobs target"
            ],
            "notes": "Self-hosted runners extend the GitHub Actions control plane into the victim’s own infrastructure, analogous to endpoint management or deployment tools used in other environments."
          },
          {
            "step_id": 2,
            "description": "Obtain or compromise an identity (user, PAT, or GitHub App) with permission to modify repository content or workflows in at least one repository that uses these self-hosted runners.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Repository Management & Source Code Hosting",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "User security settings UI for tokens and keys (https://docs.github.com/en/authentication)",
              "GitHub Apps management UI/APIs (https://docs.github.com/en/apps)",
              "Git push or REST API for repository content modification (https://docs.github.com/en/rest)"
            ],
            "related_data": [
              "Authentication tokens and keys",
              "Repository access control lists and collaborator roles"
            ],
            "notes": "Environment MFA, SSO, IP allowlisting, and related controls all affect how this identity is obtained but not the mechanics of workflow modification once it is available."
          },
          {
            "step_id": 3,
            "description": "Create or modify a workflow under .github/workflows so that at least one job runs on a self-hosted runner label and executes attacker-controlled commands or scripts.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Workflow YAML files in the repository (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
              "Repository code editor or Git push"
            ],
            "related_data": [
              "Workflow definitions specifying self-hosted runner labels and steps",
              "Repository-hosted scripts invoked by workflow steps"
            ],
            "notes": "This mirrors how adversaries in other environments repurpose software deployment or endpoint management tools to run arbitrary code across managed endpoints."
          },
          {
            "step_id": 4,
            "description": "Commit and push the workflow changes to a branch that will run on the self-hosted runner, merging via pull request if necessary, and ensure that the relevant self-hosted runner is online and associated with the repository/organization.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Pull Requests & Code Review Workflow",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Git push operations",
              "Pull request creation and merge UI (https://docs.github.com/en/pull-requests)",
              "Actions runners status view in the UI"
            ],
            "related_data": [
              "Commits, branches, and PRs containing the modified workflow",
              "Runner registration and status information"
            ],
            "notes": "If the runner is offline or unregistered, the job may queue or fail; the attacker may need to wait until it is available."
          },
          {
            "step_id": 5,
            "description": "Trigger the workflow (via push, pull request, schedule, or manual dispatch) so that the job is scheduled on the self-hosted runner and executes the attacker’s commands on that machine within the victim’s network.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions run UI and logs (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)",
              "REST API for workflow dispatch and runs (https://docs.github.com/en/rest/actions/workflows, https://docs.github.com/en/rest/actions/workflow-runs)"
            ],
            "related_data": [
              "Job logs and artifacts from runs on self-hosted runners",
              "Any secrets or environment variables made available to the workflow"
            ],
            "notes": "From the defender’s perspective, this is equivalent to a centralized software deployment system being used to push and execute malicious scripts on internal endpoints."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "Pull Requests & Code Review Workflow",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Organization & Team Administration",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Web UI: Actions runner configuration at repository/org scope",
          "Workflow YAML under .github/workflows",
          "Git push over SSH/HTTPS",
          "Web UI: Pull request creation/merge",
          "REST API: Actions workflows and workflow runs"
        ],
        "data_accessed": [
          "Workflow definitions specifying self-hosted runner targets",
          "Repository scripts and configuration executed by workflows",
          "Runner configuration and labels for self-hosted runners",
          "Workflow execution logs and artifacts",
          "Secrets and environment variables exposed to jobs on self-hosted runners"
        ],
        "preconditions_required": [
          "Target organization uses self-hosted GitHub Actions runners for at least one repository the attacker can influence.",
          "Attacker controls an identity with permissions to modify workflows or repository content in that repository.",
          "Self-hosted runners are online and associated with the repository/organization.",
          "Attacker’s identity satisfies environment MFA, SSO, IP allowlisting, and related constraints."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Email Verification Required",
          "Admin Approval Required",
          "IP Allowlisting",
          "Rate Limiting",
          "CAPTCHA Protection"
        ],
        "evasion_considerations": [
          "Target repositories and workflows where use of self-hosted runners is already common, so additional jobs appear routine.",
          "Embed malicious actions into existing deployment or test workflows that already run on self-hosted runners.",
          "Keep job names, labels, and schedules consistent with legitimate workflows to avoid attracting attention in the Actions UI.",
          "Minimize overtly suspicious commands in logs; prefer short-lived commands that stage further tools via network channels invisible to GitHub."
        ],
        "comments": "This vector uses GitHub Actions as a centralized orchestration layer to execute commands on self-hosted runners within the victim’s infrastructure, analogous to abusing enterprise software deployment or endpoint management tools.",
        "execution_result": "Attacker-controlled commands execute on victim-managed self-hosted Actions runners, potentially across many internal endpoints, orchestrated via GitHub repositories and workflows."
      },
      {
        "can_achieve": true,
        "technique_name": "Serverless Execution",
        "technique_stix_id": "attack-pattern--e848506b-8484-4410-8017-3d235a52f5b3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Gain write access to a repository that is or could be used with GitHub Codespaces, including permission to modify dev container configuration files such as Dockerfiles and devcontainer.json.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Cloud Development Environments with GitHub Codespaces",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Repository code browser and editor (https://docs.github.com/en/repositories)",
              "Git operations to push dev container configuration files",
              "User authentication and token management (https://docs.github.com/en/authentication)"
            ],
            "related_data": [
              "Repository contents including Dockerfiles and devcontainer.json",
              "Repository access control lists"
            ],
            "notes": "MFA, SSO, IP allowlisting, and related environment constraints govern how this access is obtained but not the mechanics of editing dev container configuration once access exists."
          },
          {
            "step_id": 2,
            "description": "Modify or add dev container configuration (Dockerfile and/or devcontainer.json) so that during container build or initialization, attacker-specified commands or scripts are executed (for example, via build steps or post-create/start commands).",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Projects & Codespaces Automation and Prebuilds"
            ],
            "related_interfaces": [
              "Codespaces and dev container documentation (https://docs.github.com/en/codespaces, https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces)",
              "Dev container configuration files stored in the repository"
            ],
            "related_data": [
              "Dev container configuration (Dockerfiles, devcontainer.json)",
              "Any scripts or binaries added to the dev container image"
            ],
            "notes": "Dev container configuration defines how the Codespace’s container image is built and what runs when it is created or started; these hooks provide a natural place to embed malicious commands."
          },
          {
            "step_id": 3,
            "description": "Ensure that Codespaces and, if desired, prebuilds are enabled for the repository and organization so that dev containers will actually be built and reused.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Projects & Codespaces Automation and Prebuilds",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Codespaces enablement and settings in repository/org UIs (https://docs.github.com/en/codespaces)",
              "Codespaces prebuild configuration UI (https://docs.github.com/en/codespaces/prebuilding-your-codespaces)"
            ],
            "related_data": [
              "Codespaces prebuild configurations and images",
              "Org-level policies controlling Codespaces usage, machine types, and regions"
            ],
            "notes": "If org/enterprise policies disable Codespaces for the repo, the attacker must either adjust those policies (requiring higher privileges) or target a different repo where Codespaces is allowed."
          },
          {
            "step_id": 4,
            "description": "Cause Codespaces to build or rebuild the dev container—either by the attacker creating/opening a codespace via the web UI or GitHub CLI, or by relying on legitimate developers to open a codespace or on configured prebuilds to run automatically.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Projects & Codespaces Automation and Prebuilds"
            ],
            "related_interfaces": [
              "Codespaces entry points in repository and user menus (https://docs.github.com/en/codespaces)",
              "GitHub CLI support for Codespaces (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)",
              "IDE integrations for opening Codespaces in VS Code (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code)"
            ],
            "related_data": [
              "Codespace instances and their filesystem state",
              "Codespaces build logs and status"
            ],
            "notes": "From the attacker’s perspective, any event that triggers a codespace build or prebuild is sufficient to achieve execution of the embedded initialization logic."
          },
          {
            "step_id": 5,
            "description": "When the dev container is built or initialized, allow the configured build and initialization commands to run inside the Codespaces container on GitHub-managed infrastructure, executing attacker-controlled code with access to the checked-out repository and any configured Codespaces secrets.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "Codespaces runtime and terminal interfaces (browser or IDE)",
              "Codespaces prebuild execution as documented at https://docs.github.com/en/codespaces/prebuilding-your-codespaces"
            ],
            "related_data": [
              "Repository source code mounted into the container",
              "Codespaces development environment secrets and environment variables",
              "Codespaces storage volumes and snapshots"
            ],
            "notes": "This is analogous to creating a serverless or containerized workload whose startup logic contains malicious commands; execution occurs whenever the environment is built or opened."
          }
        ],
        "capabilities_used": [
          "Cloud Development Environments with GitHub Codespaces",
          "Projects & Codespaces Automation and Prebuilds",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Repository code editor and Git push for dev container files",
          "Codespaces web UI entry points (https://docs.github.com/en/codespaces)",
          "GitHub CLI for Codespaces (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)",
          "VS Code remote development integration with Codespaces",
          "Codespaces prebuild configuration UI (https://docs.github.com/en/codespaces/prebuilding-your-codespaces)"
        ],
        "data_accessed": [
          "Dev container configuration (Dockerfiles, devcontainer.json)",
          "Repository source code and configuration files",
          "Codespace instances, including filesystem and open ports",
          "Codespaces prebuild images and caches",
          "Codespaces development secrets and environment variables",
          "Org and enterprise Codespaces policy settings"
        ],
        "preconditions_required": [
          "Target organization and repository have Codespaces enabled, with permissions allowing the attacker or targeted developers to create/open codespaces.",
          "Attacker has write access to repository dev container configuration files.",
          "Codespaces billing and quotas permit creation and (if used) prebuilding of codespaces for the target repository.",
          "Attacker’s identity satisfies MFA, SSO, IP allowlisting, and related environmental constraints."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Email Verification Required",
          "Admin Approval Required",
          "IP Allowlisting",
          "Rate Limiting",
          "CAPTCHA Protection"
        ],
        "evasion_considerations": [
          "Embed malicious logic into plausible build or toolchain setup steps in the dev container configuration so it appears as normal environment initialization.",
          "Keep initialization commands relatively lightweight to avoid noticeably slowing down Codespaces startup, which could trigger investigation.",
          "Rely on legitimate developers opening codespaces so that malicious activity is attributed to their accounts and normal workflows.",
          "Avoid writing obvious indicators (such as suspicious file names or clear-text exfiltration URLs) into the repository or Codespaces logs."
        ],
        "comments": "Codespaces provides a full containerized development environment; by controlling dev container configuration and prebuild behavior, an attacker can ensure their code runs automatically whenever a codespace is built or opened, matching the pattern of adversaries deploying malicious serverless/container workloads.",
        "execution_result": "Attacker-controlled commands execute inside GitHub Codespaces dev containers (during build/initialization and potentially at each start), with access to repository contents and any configured Codespaces secrets."
      },
      {
        "can_achieve": true,
        "technique_name": "Serverless Execution",
        "technique_stix_id": "attack-pattern--e848506b-8484-4410-8017-3d235a52f5b3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Register a GitHub App or configure a repository/organization webhook whose target URL points to attacker-controlled infrastructure (for example, a cloud function or web service).",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "GitHub Apps registration and configuration UI (https://docs.github.com/en/apps)",
              "Webhook configuration UI and APIs at repo/org/enterprise scope (https://docs.github.com/en/webhooks, https://docs.github.com/en/rest/orgs/webhooks)"
            ],
            "related_data": [
              "App registrations and metadata (permissions, webhook URL)",
              "Webhook endpoint URLs and shared secrets"
            ],
            "notes": "Creating or modifying apps/webhooks may require repository admin, org owner, or enterprise admin privileges, depending on scope and policies."
          },
          {
            "step_id": 2,
            "description": "Select and subscribe to relevant GitHub events (such as push, pull_request, issues, or workflow_run) for the App or webhook so that future activity in the target repositories will generate HTTP POST payloads to the attacker-controlled endpoint.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Webhook events and payloads documentation (https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
              "GitHub Apps permissions and event subscription configuration (https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps)"
            ],
            "related_data": [
              "Webhook event payload schemas",
              "App installation records and event scopes"
            ],
            "notes": "Choosing high-volume events like push and pull_request ensures frequent triggers without appearing unusual in many development environments."
          },
          {
            "step_id": 3,
            "description": "Deploy custom code on external infrastructure (for example, serverless functions or application servers) that receives these webhook or GitHub App callback requests, validates signatures if needed, and executes arbitrary attacker-defined logic.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub App webhook handler guidance (https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events)",
              "REST API index for subsequent API calls from the external code (https://docs.github.com/en/rest)"
            ],
            "related_data": [
              "Webhook payloads describing repository/org/user activity",
              "GitHub App tokens or OAuth tokens used by the external code"
            ],
            "notes": "Although execution occurs off GitHub, it is entirely driven by GitHub’s eventing infrastructure and App/webhook platform and can call back into GitHub’s APIs with powerful permissions."
          },
          {
            "step_id": 4,
            "description": "Install the GitHub App on target organizations and repositories or attach the webhook configuration at the desired scopes so that events from those targets reach the attacker-controlled endpoint.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "GitHub Apps installation flows in the web UI",
              "Organization and enterprise global webhooks configuration (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks)"
            ],
            "related_data": [
              "App installation records across orgs and repositories",
              "Global webhook configuration state"
            ],
            "notes": "Admin approval may be required for new apps or webhooks depending on enterprise governance; compromised admins can silently expand app or webhook coverage."
          },
          {
            "step_id": 5,
            "description": "Generate or wait for subscribed events (for example, by pushing commits, opening pull requests, or relying on normal user activity). Each event causes GitHub’s Webhook Delivery Service to send a payload to the attacker’s endpoint, where the deployed code executes.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Normal Git and web UI workflows that produce events",
              "Webhook delivery logs and redelivery tools (https://docs.github.com/en/webhooks)"
            ],
            "related_data": [
              "Webhook delivery logs including timestamps, response codes, and payloads"
            ],
            "notes": "From GitHub’s perspective these are standard webhook or app deliveries; all custom logic is hidden within the external handler."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "Webhook Event Delivery",
          "GitHub REST API",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "GitHub Apps registration and configuration UI/APIs (https://docs.github.com/en/apps)",
          "Repository/organization/enterprise webhook configuration UIs and REST APIs (https://docs.github.com/en/webhooks, https://docs.github.com/en/rest/orgs/webhooks)",
          "Webhook events and payload reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
          "GitHub App webhook handler guidance (https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events)",
          "GitHub REST API endpoints used by external code with app or OAuth tokens"
        ],
        "data_accessed": [
          "Webhook payloads describing repository, organization, and user activity",
          "GitHub App registrations, permissions, and installation records",
          "App and OAuth tokens used by external code to call back into GitHub",
          "Webhook endpoint URLs and shared secrets",
          "Webhook delivery logs and troubleshooting metadata"
        ],
        "preconditions_required": [
          "Attacker can register or control a GitHub App and/or configure repository, organization, or enterprise webhooks.",
          "Organization or enterprise policies allow installation of the attacker-controlled app or creation of the webhook on desired scopes.",
          "Attacker controls external infrastructure capable of receiving HTTPS webhook callbacks and executing arbitrary code.",
          "Attacker’s administrative or maintainer identities satisfy MFA, SSO, IP allowlisting, and related environmental constraints."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Email Verification Required",
          "Admin Approval Required",
          "IP Allowlisting",
          "Rate Limiting",
          "CAPTCHA Protection"
        ],
        "evasion_considerations": [
          "Request minimal-looking permissions for the GitHub App and add scopes gradually to avoid scrutiny.",
          "Use benign-appearing app or webhook names and documentation to blend in with common integrations.",
          "Throttle external processing of events and API calls to stay within expected usage patterns and rate limits.",
          "Host the app on reputable cloud platforms and use TLS certificates matching the app’s branding to reduce suspicion."
        ],
        "comments": "This vector executes attacker-controlled code off-platform but entirely orchestrated by GitHub’s webhook and Apps infrastructure; it closely resembles serverless-style integrations where cloud SaaS events trigger custom code.",
        "execution_result": "Attacker-controlled code executes on external infrastructure (for example, serverless functions or web services) whenever configured GitHub events occur, with the ability to act back on GitHub using app or OAuth tokens."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud API",
        "technique_stix_id": "attack-pattern--55bb4471-ff1f-43b4-88c1-c9384ec47abf",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain a personal access token, fine-grained token, or GitHub App installation token with scopes that allow repository content modification, Actions workflow management, and/or Codespaces operations.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "User security settings UI and PAT management (https://docs.github.com/en/authentication)",
              "GitHub Apps REST API for installation/access tokens (https://docs.github.com/en/rest/apps/apps)",
              "REST API authentication guidance (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
            ],
            "related_data": [
              "Authentication tokens and scopes",
              "App installation records"
            ],
            "notes": "MFA, SSO, domain-based registration, email verification, admin approval, CAPTCHA, IP allowlisting, and rate limiting constrain how such tokens are obtained but not their subsequent use once compromised."
          },
          {
            "step_id": 2,
            "description": "Use the GitHub REST API (or SDKs/CLI built on it) to inspect target repositories for existing workflows and dev container configurations and to confirm whether Actions and Codespaces are enabled.",
            "related_capabilities": [
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)",
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "REST API index and resource docs (https://docs.github.com/en/rest)",
              "Libraries for the REST API such as Octokit (https://docs.github.com/en/rest/using-the-rest-api/libraries-for-the-rest-api)"
            ],
            "related_data": [
              "Repository metadata and file trees",
              "Workflow and Codespaces-related configuration where exposed via API"
            ],
            "notes": "This mirrors real-world use of cloud management APIs and SDKs by tools like Pacu to enumerate and prepare cloud environments for later execution."
          },
          {
            "step_id": 3,
            "description": "Programmatically create or modify workflow YAML files under .github/workflows via the REST API (for example, using contents endpoints) so that jobs execute attacker-specified commands on GitHub-hosted or self-hosted runners.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Repository contents REST endpoints for creating/updating files (under https://docs.github.com/en/rest)",
              "Actions workflows REST endpoints (https://docs.github.com/en/rest/actions/workflows)"
            ],
            "related_data": [
              "Workflow definitions stored in the repository",
              "Repository commit history and file contents"
            ],
            "notes": "All changes happen via API calls rather than interactive Git pushes, but the resulting workflows behave identically to those created via the UI or Git."
          },
          {
            "step_id": 4,
            "description": "Trigger execution surfaces via the REST API—for example, using workflow dispatch endpoints to start Actions workflows or Codespaces-related endpoints/CLI to create codespaces that will build modified dev containers.",
            "related_capabilities": [
              "GitHub REST API",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "REST API: workflow dispatch and workflow run endpoints (https://docs.github.com/en/rest/actions/workflows, https://docs.github.com/en/rest/actions/workflow-runs)",
              "Codespaces-related APIs/CLI for creating codespaces (https://docs.github.com/en/codespaces and related REST endpoints where available)"
            ],
            "related_data": [
              "Workflow run metadata and logs",
              "Codespace instances and build logs"
            ],
            "notes": "This step uses the cloud control plane (REST API) as the primary interface for initiating code execution, aligning directly with MITRE’s Cloud API execution technique."
          },
          {
            "step_id": 5,
            "description": "Retrieve workflow run logs, artifacts, and, where applicable, Codespaces information via the REST API to confirm execution and harvest outputs, using additional API calls from the same compromised token.",
            "related_capabilities": [
              "GitHub REST API",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "REST API: workflow runs and artifacts endpoints (https://docs.github.com/en/rest/actions/workflow-runs)"
            ],
            "related_data": [
              "Actions logs and artifacts",
              "Any data exfiltrated or staged by executed workflows"
            ],
            "notes": "Automated tooling can loop over multiple repositories and organizations, scaling execution across the tenant via the API."
          }
        ],
        "capabilities_used": [
          "GitHub REST API",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Cloud Development Environments with GitHub Codespaces",
          "Repository Management & Source Code Hosting",
          "GitHub Apps & OAuth Apps Platform",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "HTTPS-based REST API at api.github.com (https://docs.github.com/en/rest)",
          "REST API authentication mechanisms (PATs, fine-grained tokens, GitHub App tokens)",
          "Official SDKs such as Octokit libraries (https://docs.github.com/en/rest/using-the-rest-api/libraries-for-the-rest-api)",
          "GitHub CLI built on the REST API where used to script these operations"
        ],
        "data_accessed": [
          "Repository file contents, including workflow YAML and dev container configs",
          "Workflow configuration and run metadata",
          "Codespaces configurations and instances, where exposed via API",
          "Authentication tokens and their scopes",
          "Logs and artifacts from executed workflows"
        ],
        "preconditions_required": [
          "Attacker has a compromised or maliciously created token (PAT, fine-grained token, or GitHub App token) with scopes sufficient to modify repository contents and interact with Actions and/or Codespaces APIs.",
          "Actions and/or Codespaces are enabled and policy-allowed for the targeted repositories and organizations.",
          "Attacker’s API clients operate from IP ranges that satisfy any IP allowlisting and do not violate rate limiting policies."
        ],
        "constraints_encountered": [
          "MFA Required",
          "SSO-Only Authentication",
          "Domain-Based Registration",
          "Email Verification Required",
          "Admin Approval Required",
          "IP Allowlisting",
          "Rate Limiting",
          "CAPTCHA Protection"
        ],
        "evasion_considerations": [
          "Use official SDKs or GitHub CLI with common user-agent strings so API traffic resembles legitimate automation.",
          "Throttle API calls to stay within normal rate limits and avoid triggering abuse detection.",
          "Distribute modifications and workflow dispatches over time and across repositories to avoid obvious spikes in Actions or Codespaces usage.",
          "Reuse existing automation tokens or app installations when possible so activity appears consistent with known integrations."
        ],
        "comments": "This vector emphasizes use of GitHub’s REST API as the primary control plane for creating and invoking execution surfaces (Actions workflows and Codespaces), directly mapping to MITRE’s Cloud API execution technique. The underlying execution environment is the same as in other vectors; what changes is that all control proceeds through cloud APIs.",
        "execution_result": "Attacker-controlled workflows and/or Codespaces are created and triggered entirely via the GitHub REST API, resulting in arbitrary code execution on GitHub-hosted or self-hosted runners and in Codespaces dev containers."
      }
    ],
    "summary": "Given the documented capabilities, GitHub clearly supports multiple realistic execution methods for an attacker with sufficient access. The dominant surfaces are GitHub Actions (on GitHub-hosted and self-hosted runners) and GitHub Codespaces dev containers, both of which execute user-defined commands and scripts. Attackers can:\n\n• Define or modify Actions workflows to run arbitrary commands on GitHub-hosted runners (Serverless Execution), including via scheduled workflows and at scale through the REST API.\n• Abuse existing CI workflows that run on untrusted contributions (for example, pull requests from forks) so that repository-controlled code executes on GitHub-hosted runners, even without workflow-edit privileges.\n• Target self-hosted Actions runners as a software deployment tool, using workflows to run code on victim-managed infrastructure.\n• Manipulate dev container configuration and prebuilds in GitHub Codespaces so that attacker-controlled commands execute whenever Codespaces environments are built or opened.\n• Use GitHub Apps and webhooks to drive execution of arbitrary code on external infrastructure in response to GitHub events, and orchestrate further actions via the REST API.\n• Leverage the GitHub REST API as a cloud control plane to programmatically create/modify workflows and Codespaces and dispatch runs (Cloud API), scaling execution across repositories and organizations.\n\nGeneric environmental safeguards such as MFA, SSO-only authentication, domain-based registration, admin approval, IP allowlisting, CAPTCHA, email verification, and rate limiting primarily constrain how attackers obtain and use the necessary identities and tokens but do not prevent execution once those permissions are in hand. The main mitigations against these execution vectors are GitHub’s own configuration controls (Actions and Codespaces policies, runner restrictions, app/webhook governance) and downstream monitoring of Actions, Codespaces, and API usage patterns."
  },
  "persistence": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Additional Cloud Credentials",
        "technique_stix_id": "attack-pattern--8a2f40cf-8325-47f9-96e4-b1ca4c7389bd",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use the already-compromised GitHub user account (with MFA/SSO satisfied and from an allowlisted IP) to access the account security settings UI and REST API for credentials management.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "User account security settings UI for managing passwords, 2FA, passkeys, SSH keys, and tokens (https://docs.github.com/en/authentication).",
              "REST API endpoints for authentication, credential scopes, and token permissions (https://docs.github.com/en/rest/authentication)."
            ],
            "related_data": [
              "User identities and account metadata.",
              "Authentication credentials (password hashes, passkeys, SSH keys, tokens).",
              "Security logs of sessions, sign-in attempts, credential updates, and token usage."
            ],
            "notes": "Environment constraints MFA Required, SSO-Only Authentication, IP Allowlisting, and CAPTCHA/Rate Limiting apply at login and high-risk UI operations, so the attacker must already be past these (e.g., via stolen session or full account takeover)."
          },
          {
            "step_id": 2,
            "description": "Create one or more new personal access tokens (classic or fine-grained) with scopes granting at least read (and optionally write/admin) access to target repositories and APIs, labeling them to resemble legitimate CI or automation tokens.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "User account security settings UI for creating and managing tokens (https://docs.github.com/en/authentication).",
              "Global GitHub REST API surface that accepts PATs and fine-grained tokens for authenticated access (https://docs.github.com/en/rest)."
            ],
            "related_data": [
              "Personal access tokens and fine-grained tokens with scoped permissions.",
              "Token metadata such as scopes and creation timestamps.",
              "Security logs recording token creation."
            ],
            "notes": "Tokens bypass MFA on each use once created. Creating them may require re-entering credentials under sudo/MFA, but the attacker already controls the account during this window."
          },
          {
            "step_id": 3,
            "description": "Copy and exfiltrate the new PAT values to attacker-controlled storage outside GitHub, then delete any local traces from the compromised host.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "User account security settings UI where PAT values are initially displayed (https://docs.github.com/en/authentication)."
            ],
            "related_data": [
              "Plaintext personal access token strings.",
              "Local shell/browser history on the compromised device (outside GitHub)."
            ],
            "notes": "Once exfiltrated, PATs can be used from any environment that satisfies IP Allowlisting and other network constraints."
          },
          {
            "step_id": 4,
            "description": "Add one or more new SSH public keys to the compromised user account to enable SSH-based Git operations without further interactive authentication.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "User account security settings UI for managing SSH keys (https://docs.github.com/en/authentication).",
              "Git CLI/SSH interface for interacting with GitHub repositories via the SSH transport (https://docs.github.com/en/get-started/git-basics/set-up-git)."
            ],
            "related_data": [
              "SSH public keys associated with the user account.",
              "Underlying private keys stored by the attacker outside GitHub.",
              "Security logs noting new SSH key additions."
            ],
            "notes": "SSH keys are long-lived and commonly used by developers; extra keys can be made to look like standard workstation keys."
          },
          {
            "step_id": 5,
            "description": "For repositories where the compromised identity has admin or maintainer rights, create new deploy keys on specific repositories and retain the corresponding private keys for persistent repository-level access.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Repository settings UI for configuring deploy keys (within https://docs.github.com/en/repositories).",
              "Repository REST API endpoints under /repos for managing deploy keys and settings (https://docs.github.com/en/rest/repos/repos)."
            ],
            "related_data": [
              "Deploy key public keys attached to repositories.",
              "Private deploy keys controlled by the attacker.",
              "Repository visibility and collaborator permissions affected by deploy keys."
            ],
            "notes": "Deploy keys can be scoped as read-only to appear benign while still enabling persistent cloning and monitoring; write-enabled keys provide full code modification capability."
          },
          {
            "step_id": 6,
            "description": "Verify that PATs, SSH keys, and deploy keys work from an attacker-controlled environment that is within the allowed IP ranges by performing benign-looking API calls or repository clones.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "REST API endpoints accessed with the new PATs (https://docs.github.com/en/rest).",
              "Git SSH/HTTPS endpoints for cloning and fetching repositories."
            ],
            "related_data": [
              "Rate limit and authentication headers returned by the REST API.",
              "Repository metadata and commit history accessed via Git operations."
            ],
            "notes": "Low-volume, normal-looking activity helps avoid rate-limiting and anomalous-usage alerts in billing or security monitoring."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Repository Management & Source Code Hosting"
        ],
        "interfaces_used": [
          "User account security settings UI for managing passwords, 2FA, passkeys, SSH keys, and tokens (https://docs.github.com/en/authentication).",
          "REST API endpoints for authentication, credential scopes, and token permissions (https://docs.github.com/en/rest/authentication).",
          "Global GitHub REST API surface (https://docs.github.com/en/rest).",
          "Repository REST API endpoints under /repos for managing repositories and deploy keys (https://docs.github.com/en/rest/repos/repos).",
          "Git CLI/SSH interface for interacting with GitHub remotes (https://docs.github.com/en/get-started/git-basics/set-up-git)."
        ],
        "data_accessed": [
          "User identities and account metadata.",
          "Authentication credentials, including SSH keys, deploy keys, and personal access tokens.",
          "Repository metadata, including visibility and collaborator permissions.",
          "Security and account-level logs that record credential creation and use."
        ],
        "preconditions_required": [
          "Attacker controls at least one GitHub user account that already has the desired repository/organization access.",
          "That account can successfully authenticate under MFA Required and SSO-Only Authentication and from an IP range allowed by IP Allowlisting.",
          "The account has permission to manage its own tokens and SSH keys via Authentication & Account Security Management.",
          "For deploy keys, the compromised identity must have administrative/maintainer rights on target repositories."
        ],
        "constraints_encountered": [
          "MFA Required: creating or modifying sensitive credentials may trigger re-authentication; attacker must have a valid second factor or a hijacked session already past MFA.",
          "SSO-Only Authentication: interactive logins must go through the configured IdP; stolen local passwords alone are insufficient without SSO access.",
          "IP Allowlisting: use of PATs and SSH/deploy keys will be blocked from non-allowlisted IPs; attacker must operate from or tunnel through an approved network.",
          "Rate Limiting and CAPTCHA Protection: limit automated brute-force attempts but do not impede a small number of credential-creation actions."
        ],
        "evasion_considerations": [
          "Name PATs and deploy keys to match existing automation or workstation naming conventions (e.g., \"ci-runner-2\"), reducing suspicion in manual reviews.",
          "Request the minimal necessary scopes (often read-only) to avoid drawing attention; create separate, narrowly scoped tokens per use-case.",
          "Avoid creating many keys or tokens at once, which could trigger alerts based on unusual credential lifecycle activity.",
          "Prefer deploy keys on high-value repositories where automated access is expected, making them blend into normal CI/CD configuration."
        ],
        "comments": "Once created and exfiltrated, additional PATs, SSH keys, and deploy keys provide durable access channels that typically remain valid even if passwords are rotated or interactive SSO sessions expire, until explicitly revoked or the owning account is disabled.",
        "persistence_mechanism": "Extra long-lived personal access tokens, SSH keys, and deploy keys tied to a compromised user or repository that remain valid independent of the user’s interactive login sessions."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Account",
        "technique_stix_id": "attack-pattern--a009cb25-4801-4116-9105-80a91cf15c1b",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised high-privilege account (user with org-owner or enterprise-admin rights), navigate to the GitHub Apps & OAuth Apps configuration UI to register a new GitHub App or OAuth app under attacker control.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "GitHub Apps and OAuth app registration & installation UI (https://docs.github.com/en/apps).",
              "User account security and authorized application settings (https://docs.github.com/en/authentication)."
            ],
            "related_data": [
              "App registrations and metadata (name, description, permissions, callback URL, webhook URL).",
              "Owner account identity for the new app."
            ],
            "notes": "This step creates a new application identity in GitHub that functions as a service account, distinct from any human user."
          },
          {
            "step_id": 2,
            "description": "Configure the app’s permissions with fine-grained scopes that allow it to read and, where desired, modify repositories, issues, pull requests, Actions, and organization settings on targeted resources.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub App permissions and events configuration UI (within https://docs.github.com/en/apps).",
              "REST API documentation describing resources available to app tokens (https://docs.github.com/en/rest)."
            ],
            "related_data": [
              "App permission configuration, including read/write access over code, issues, pull requests, and administration features.",
              "Installation targets (specific repositories or entire organizations)."
            ],
            "notes": "Attackers may request broader permissions than strictly necessary to maximize their future options while still appearing like a typical automation app."
          },
          {
            "step_id": 3,
            "description": "Set the app’s webhook URL to an HTTPS endpoint controlled by the attacker to receive continuous event payloads (pushes, pull requests, security events) from all installations of the app.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "GitHub App webhook configuration (https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events).",
              "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)."
            ],
            "related_data": [
              "Webhook endpoint URL and shared secret.",
              "Webhook event payloads containing repository, organization, and activity data."
            ],
            "notes": "This provides a persistent telemetry and potential command channel; while webhooks alone do not grant write access, they keep the attacker informed and can drive automated responses."
          },
          {
            "step_id": 4,
            "description": "Install the malicious or over-privileged app onto the target organization and repositories, using org-owner or repo-admin rights to approve the requested permissions.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Organization settings UI for managing installed apps and selecting repositories (https://docs.github.com/en/organizations).",
              "REST API for GitHub Apps installations (https://docs.github.com/en/rest/apps/apps)."
            ],
            "related_data": [
              "Installation records linking the app to organizations and repositories.",
              "Organization membership and repository lists used during installation."
            ],
            "notes": "Installations can be scoped narrowly (selected repositories) or broadly (all repositories), influencing the persistence footprint."
          },
          {
            "step_id": 5,
            "description": "From attacker-controlled infrastructure, periodically obtain short-lived installation access tokens for the app via the REST API and use them to interact with GitHub resources within the app’s granted scopes.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "REST API for GitHub Apps authentication and installation access tokens (https://docs.github.com/en/rest/apps/apps).",
              "Global GitHub REST API surface used by app tokens (https://docs.github.com/en/rest)."
            ],
            "related_data": [
              "App private key or client secret stored by the attacker outside GitHub.",
              "Installation access tokens and their expiration times.",
              "Repository content, issues, pull requests, and configuration accessible via app scopes."
            ],
            "notes": "These tokens allow ongoing read/write access without needing any human user to log in again or re-consent, as long as the app remains installed."
          },
          {
            "step_id": 6,
            "description": "Optionally, configure or co-opt an existing enterprise or organization webhook to point to attacker-controlled infrastructure, providing a second, broader data stream and redundancy if the app is removed.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Enterprise global webhooks configuration (https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks).",
              "Organization webhook configuration and REST API endpoints (https://docs.github.com/en/rest/orgs/webhooks)."
            ],
            "related_data": [
              "Enterprise and organization webhook configurations.",
              "Cross-organization webhook payloads for monitored events."
            ],
            "notes": "Global or org webhooks can survive removal of a single compromised user, acting as a persistent monitoring channel even if app tokens are revoked."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Webhook Event Delivery",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "GitHub Apps and OAuth app registration & installation UI (https://docs.github.com/en/apps).",
          "REST API for GitHub Apps and installations (https://docs.github.com/en/rest/apps/apps).",
          "Webhook configuration and delivery documentation (https://docs.github.com/en/webhooks).",
          "Webhook events and payload schemas (https://docs.github.com/en/webhooks/webhook-events-and-payloads).",
          "Organization settings UI for managing members, repositories, and installed apps (https://docs.github.com/en/organizations).",
          "Enterprise admin settings for managing global webhooks and monitoring (https://docs.github.com/en/enterprise-cloud@latest/admin).",
          "Authentication and token management docs (https://docs.github.com/en/authentication)."
        ],
        "data_accessed": [
          "App registrations and metadata (name, permissions, callback and webhook URLs).",
          "Installation records across users and organizations.",
          "App tokens and OAuth access tokens used to call the REST API.",
          "Webhook payloads carrying repository, issue, pull request, and security-related activity.",
          "Organization and repository metadata and contents available through the app’s scopes."
        ],
        "preconditions_required": [
          "Attacker controls a GitHub account that can register new GitHub Apps or OAuth apps.",
          "To install the app on target organizations/repositories, the attacker must control an organization owner or repository administrator account, or convince such an admin to approve the installation.",
          "Attacker can host and manage an HTTPS endpoint to receive webhooks and securely store app secrets/private keys.",
          "Access to GitHub must originate from IP ranges allowed by IP Allowlisting, and any interactive admin actions must satisfy MFA Required and SSO-Only Authentication."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication restrict who can register and install apps but do not constrain ongoing token-based API access once the app is installed.",
          "IP Allowlisting applies to REST API calls made with app tokens; attacker infrastructure must appear to originate from allowed IP ranges (for example, via corporate VPN or a compromised host).",
          "Admin Approval Required may apply to app installations in tightly managed enterprises, requiring the attacker to perform these steps from a compromised admin account or social-engineer approval.",
          "Rate Limiting constrains high-volume API use from app tokens but does not prevent low-and-slow persistent access."
        ],
        "evasion_considerations": [
          "Name the app and describe it to resemble a legitimate CI/CD or reporting integration already in use in the organization.",
          "Request the minimal set of permissions necessary while still allowing effective persistence (for example, read-only repository and org metadata plus Actions logs).",
          "Scope installations to a subset of repositories that still contain valuable assets to reduce visibility in enterprise-wide app audits.",
          "Use webhook endpoints hosted on reputable cloud providers and TLS certificates to avoid obvious indicators of malicious infrastructure."
        ],
        "comments": "GitHub Apps and OAuth apps act as separate cloud identities whose installations and tokens often outlive individual user sessions. A malicious or compromised app with persistent installation across critical organizations or repositories can provide durable API and event-stream access until explicitly uninstalled or its permissions are revoked.",
        "persistence_mechanism": "Malicious or over-privileged GitHub App/OAuth app registered and installed on organizations and repositories, with renewable installation tokens and webhooks that maintain persistent programmatic access independent of any one user account."
      },
      {
        "can_achieve": true,
        "technique_name": "Event Triggered Execution",
        "technique_stix_id": "attack-pattern--b6301b64-ef57-4cce-bb0b-77026f14a8db",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify a repository where GitHub Actions is enabled and where the compromised identity has at least write access to push workflow files under .github/workflows.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository web UI for viewing Actions configuration and workflow runs (https://docs.github.com/en/actions).",
              "Repository web UI and Git/CLI interfaces for modifying source and .github/workflows files (https://docs.github.com/en/repositories)."
            ],
            "related_data": [
              "Repository contents including .github/workflows YAML files.",
              "Repository visibility and Actions configuration.",
              "Organization policies governing Actions usage."
            ],
            "notes": "The more central the repository (for example, a shared CI or infrastructure repo), the more durable the persistence."
          },
          {
            "step_id": 2,
            "description": "Create or modify a workflow YAML file in .github/workflows that runs on a schedule (cron) and/or on common events such as push or pull_request to ensure regular execution.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Workflow syntax for GitHub Actions (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax).",
              "Actions concepts documentation (https://docs.github.com/en/actions/concepts/workflows-and-actions)."
            ],
            "related_data": [
              "Workflow definitions (YAML) including triggers, jobs, and steps.",
              "Event payloads associated with each workflow run."
            ],
            "notes": "Scheduled triggers (cron) are particularly valuable for persistence because they do not depend on specific user actions."
          },
          {
            "step_id": 3,
            "description": "Configure the workflow to use a stored secret (for example, a PAT or GitHub App token) or the default GITHUB_TOKEN to call the GitHub REST API and enforce attacker-chosen state (such as re-adding a backup collaborator or recreating a malicious webhook).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions secrets management and environment variables (via repository/organization settings, documented at https://docs.github.com/en/actions).",
              "REST API endpoints for repositories, collaborators, webhooks, and org membership (https://docs.github.com/en/rest).",
              "REST API for workflow runs (https://docs.github.com/en/rest/actions/workflow-runs)."
            ],
            "related_data": [
              "Secrets and environment variables exposed to workflows.",
              "Installation or personal access tokens used by the workflow.",
              "Repository collaborators, teams, and webhook configurations manipulated via the API."
            ],
            "notes": "MITRE examples of event-triggered execution in cloud environments mirror this pattern by using event-driven serverless code to enforce backdoor state."
          },
          {
            "step_id": 4,
            "description": "Implement idempotent logic in the workflow that, on each run, checks whether an attacker-controlled account, team, or app installation has the desired access and re-adds or repairs it if missing.",
            "related_capabilities": [
              "GitHub REST API",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "REST API for organizations, members, and teams (https://docs.github.com/en/rest/orgs/orgs, https://docs.github.com/en/rest/teams/teams).",
              "REST API for repository collaborators and webhooks (https://docs.github.com/en/rest/repos/repos, https://docs.github.com/en/rest/orgs/webhooks)."
            ],
            "related_data": [
              "Organization membership and team hierarchies.",
              "Repository collaborator lists and webhook configurations."
            ],
            "notes": "This ensures that even if defenders remove malicious accounts or webhooks once, the automation recreates them on the next run."
          },
          {
            "step_id": 5,
            "description": "Commit and push the workflow file to a branch that is actually executed (typically the default branch) and ensure Actions run successfully with the configured triggers.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Git/CLI and web UI for committing and pushing workflow files (https://docs.github.com/en/repositories).",
              "Actions run history and logs UI (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)."
            ],
            "related_data": [
              "Git history including workflow file commits.",
              "Actions workflow run logs, artifacts, and status."
            ],
            "notes": "The attacker can initially disguise the workflow as part of a legitimate CI/CD pipeline to reduce scrutiny."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "GitHub REST API",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration"
        ],
        "interfaces_used": [
          "Actions tab and workflow run views in repositories (https://docs.github.com/en/actions).",
          "Workflow syntax and configuration docs (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax).",
          "REST API for workflows and workflow runs (https://docs.github.com/en/rest/actions/workflows, https://docs.github.com/en/rest/actions/workflow-runs).",
          "REST API for repos, collaborators, and org membership (https://docs.github.com/en/rest/repos/repos, https://docs.github.com/en/rest/orgs/orgs, https://docs.github.com/en/rest/teams/teams).",
          "Repository web UI and Git/CLI for editing .github/workflows (https://docs.github.com/en/repositories)."
        ],
        "data_accessed": [
          "Workflow definitions (YAML), triggers, and Actions configuration.",
          "Secrets and tokens used by workflows, including GITHUB_TOKEN and stored PATs.",
          "Organization membership, team structures, and repository collaborator lists.",
          "Webhook configurations attached to repositories and organizations.",
          "Actions logs and artifacts generated by each run."
        ],
        "preconditions_required": [
          "Attacker controls an account or token with write access to at least one repository where Actions is enabled.",
          "Organization Actions policies allow workflows from that repository and are not locked down to prevent arbitrary scripts.",
          "Attacker has access to at least one secret or token within the workflow context that can perform the desired administrative or access-restoring actions.",
          "Access to GitHub’s web UI or API must comply with MFA Required, SSO-Only Authentication, and IP Allowlisting for initial workflow creation."
        ],
        "constraints_encountered": [
          "Organization or enterprise policies may restrict which Actions or runner types can be used, limiting where arbitrary scripts can run.",
          "Code scanning or security review processes may flag obviously malicious workflow content, especially in protected branches.",
          "Rate Limiting applies to API calls made by workflows; the automation must stay within normal usage patterns.",
          "Billing limits and monitoring for Actions minutes can reveal unexpectedly frequent or long-running workflows."
        ],
        "evasion_considerations": [
          "Embed persistence logic inside an otherwise legitimate-looking CI/CD workflow, such as a nightly build job, so it is harder to distinguish from normal automation.",
          "Schedule runs infrequently (for example, daily or weekly) to reduce noise in run history while still re-establishing access if removed.",
          "Use minimal and carefully-scoped tokens and API operations so workflow logs do not obviously show administrative actions.",
          "Name workflow files and jobs using existing naming conventions to blend into the repository’s automation ecosystem."
        ],
        "comments": "GitHub Actions workflows are effectively cloud-hosted, event-triggered code. A malicious workflow that reasserts attacker-controlled access via the REST API provides a powerful persistence mechanism as long as the workflow file and Actions capability remain in place.",
        "persistence_mechanism": "Malicious scheduled or event-driven GitHub Actions workflow that periodically re-creates attacker-controlled access (accounts, roles, webhooks) using stored credentials and the REST API."
      },
      {
        "can_achieve": true,
        "technique_name": "Additional Cloud Roles",
        "technique_stix_id": "attack-pattern--2dbbdcd5-92cf-44c0-aea2-fe24783a6bc3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "From a compromised organization owner or enterprise admin account, enumerate existing members, teams, and their roles to identify where new high-privilege assignments can be added with minimal visibility.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization settings UI for viewing members, teams, and roles (https://docs.github.com/en/organizations).",
              "REST API endpoints for organizations and members (https://docs.github.com/en/rest/orgs/orgs).",
              "REST API for teams and team memberships (https://docs.github.com/en/rest/teams/teams)."
            ],
            "related_data": [
              "Organization member lists and roles (owners, admins, members).",
              "Team hierarchies and repository access mappings.",
              "Enterprise account metadata and org list (for multi-org environments)."
            ],
            "notes": "This reconnaissance step mirrors IAM enumeration in cloud environments used to plan role-based persistence."
          },
          {
            "step_id": 2,
            "description": "Add an attacker-controlled account (which may be a compromised legitimate user or a secondary GitHub account with an approved email domain) as an additional owner or administrator in one or more organizations.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Organization member management UI for promoting members to owner/admin (https://docs.github.com/en/organizations).",
              "REST API for updating organization membership and roles (https://docs.github.com/en/rest/orgs/orgs)."
            ],
            "related_data": [
              "Organization membership records and role assignments.",
              "User identities associated with the new high-privilege roles."
            ],
            "notes": "This directly parallels cloud IAM abuse where adversaries grant themselves global administrator roles."
          },
          {
            "step_id": 3,
            "description": "Create or repurpose a team with broad repository access (for example, write/admin on many repositories), add attacker-controlled accounts to this team, and ensure it remains part of normal team hierarchies.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Organization teams UI for creating and managing teams (https://docs.github.com/en/organizations).",
              "REST API for teams and repositories (https://docs.github.com/en/rest/teams/teams, https://docs.github.com/en/rest/repos/repos)."
            ],
            "related_data": [
              "Team definitions and membership lists.",
              "Repository access policies granted to the team."
            ],
            "notes": "Using teams rather than direct collaborator assignments makes the persistence more scalable and less obvious."
          },
          {
            "step_id": 4,
            "description": "For especially sensitive repositories, add attacker-controlled accounts as direct collaborators or admins, independent of organization or team memberships, to create redundancy if role policies are tightened.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository settings UI for managing collaborators and permissions (https://docs.github.com/en/repositories).",
              "REST API for repository collaborators (https://docs.github.com/en/rest/repos/repos)."
            ],
            "related_data": [
              "Repository collaborator lists and role levels (read, write, admin).",
              "Repository visibility and branch protection configuration."
            ],
            "notes": "Direct collaborator access may persist even if organization-wide roles or teams are restructured."
          }
        ],
        "capabilities_used": [
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Organization settings UI for managing members, teams, and repository access (https://docs.github.com/en/organizations).",
          "REST API endpoints for organizations and members (https://docs.github.com/en/rest/orgs/orgs).",
          "REST API endpoints for teams and team memberships (https://docs.github.com/en/rest/teams/teams).",
          "Repository settings UI for collaborators and permissions (https://docs.github.com/en/repositories).",
          "REST API for repository collaborators and permissions (https://docs.github.com/en/rest/repos/repos).",
          "Enterprise Cloud admin portal for cross-org governance (https://docs.github.com/en/enterprise-cloud@latest/admin)."
        ],
        "data_accessed": [
          "Organization member and role assignments (owners, admins, members).",
          "Team definitions, hierarchies, and repository access mappings.",
          "Repository collaborator lists and permission levels.",
          "Enterprise account metadata and organization lists."
        ],
        "preconditions_required": [
          "Attacker controls at least one account with organization owner or equivalent administrative rights; enterprise admin rights increase blast radius.",
          "The environment’s Domain-Based Registration and Admin Approval Required constraints must already be satisfied for any attacker-controlled secondary accounts (for example, they use accounts with approved email domains).",
          "SSO-Only Authentication and MFA Required must be satisfied to perform role changes via the UI or API."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication may require re-authentication to perform sensitive role changes, limiting what can be done with partial credential theft.",
          "Domain-Based Registration may prevent adding attacker-controlled accounts that use unapproved email domains as full organization members, though outside collaborators on specific repositories may still be possible depending on org policy.",
          "Organization audit logs will record membership and role changes, making overt changes to owner roles detectable.",
          "Rate Limiting on the REST API constrains bulk role changes but not a few carefully chosen assignments."
        ],
        "evasion_considerations": [
          "Assign attacker-controlled accounts to existing teams or create teams with innocuous names that align with existing naming conventions (for example, \"build-automation\" or \"infra-admin\").",
          "Prefer team-based elevated access rather than adding many direct repository admins, which may stand out more in individual repo settings.",
          "Distribute added roles across multiple accounts rather than concentrating excessive privileges on a single obviously anomalous user.",
          "Make changes gradually and during periods of legitimate administrative activity to blend into normal audit-log patterns."
        ],
        "comments": "Elevating one or more attacker-controlled identities to privileged organization or repository roles ensures long-term access even if some compromised accounts are revoked, mirroring cloud IAM persistence patterns such as adding new global admins.",
        "persistence_mechanism": "Redundant privileged roles (organization owners, high-privilege teams, and direct repo admins) assigned to attacker-controlled accounts so that at least one identity retains powerful access even after cleanup of the original compromise."
      },
      {
        "can_achieve": true,
        "technique_name": "Valid Accounts",
        "technique_stix_id": "attack-pattern--b17a1a56-e99c-403c-8948-561df0cffe81",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Retain full credential and MFA control over one or more compromised GitHub user or app identities, ensuring the attacker can continue to authenticate normally via SSO and MFA flows.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "User account security settings UI for managing passwords, passkeys, and 2FA (https://docs.github.com/en/authentication).",
              "REST API authentication surface using tokens (https://docs.github.com/en/rest/authentication)."
            ],
            "related_data": [
              "User credentials (passwords, passkeys) and MFA configuration.",
              "Tokens and SSH keys already assigned to the account.",
              "Account-level security logs of sign-ins and credential use."
            ],
            "notes": "This represents the simplest persistence case: continued use of a fully compromised valid account without creating additional backdoors."
          },
          {
            "step_id": 2,
            "description": "Minimize overtly malicious configuration changes, instead using the compromised account to perform normal-looking repository and project activity over time, while leveraging existing access to code, issues, and administrative features as needed.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Web UI for repositories, issues, and organization settings (https://docs.github.com/en/repositories, https://docs.github.com/en/issues, https://docs.github.com/en/organizations).",
              "Git CLI/SSH and REST API for day-to-day repository access (https://docs.github.com/en/rest)."
            ],
            "related_data": [
              "Repositories, issues, and pull requests accessible to the account.",
              "Organization and team memberships associated with the account."
            ],
            "notes": "By avoiding configuration drift (e.g., no new tokens, roles, or webhooks), the attacker leverages the account’s existing privileges as a low-noise persistence channel."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Repository Management & Source Code Hosting",
          "Issue Tracking & Work Management with GitHub Issues",
          "Organization & Team Administration"
        ],
        "interfaces_used": [
          "User account authentication and security settings (https://docs.github.com/en/authentication).",
          "Global REST API and auth docs (https://docs.github.com/en/rest, https://docs.github.com/en/rest/authentication).",
          "Web UI for repositories and issues (https://docs.github.com/en/repositories, https://docs.github.com/en/issues).",
          "Organization settings UI for membership and access (https://docs.github.com/en/organizations).",
          "Git CLI/SSH for repository operations."
        ],
        "data_accessed": [
          "All repositories, issues, pull requests, and organization resources the compromised account legitimately has access to.",
          "Authentication tokens, SSH keys, and related credentials associated with the account.",
          "Organization and team membership metadata for that account."
        ],
        "preconditions_required": [
          "Attacker has fully compromised at least one user or app identity, including its primary credentials and MFA mechanisms, or has a long-lived session that bypasses re-authentication requirements.",
          "The account remains active in the identity provider and GitHub (no deprovisioning via SCIM or manual deactivation)."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication significantly reduce the chance of initial credential theft but, once bypassed, do not prevent ongoing legitimate logins.",
          "IP Allowlisting forces the attacker to operate from approved networks, potentially limiting where persistence activity can originate.",
          "Audit and security logs can reveal anomalous behavior from the account (unusual IPs, times, or actions), even if no new backdoors are created."
        ],
        "evasion_considerations": [
          "Align login times and IP locations with the victim’s normal patterns (for example, via a compromised workstation or VPN) to avoid anomalies.",
          "Limit administrative changes, especially around tokens, SSH keys, and roles, to reduce obvious indicators of persistence.",
          "Throttle activity volumes and avoid large, sudden data access spikes that could trigger monitoring based on billing, usage, or security analytics."
        ],
        "comments": "Many campaigns rely primarily on continued use of valid compromised accounts rather than explicit backdoors. In GitHub, this can provide long-term persistence if identity governance and anomaly detection are weak, even without creating new tokens or roles.",
        "persistence_mechanism": "Ongoing use of one or more fully compromised GitHub user or app accounts, authenticated normally via SSO and MFA, to maintain access without additional configuration changes."
      },
      {
        "can_achieve": true,
        "technique_name": "Multi-Factor Authentication",
        "technique_stix_id": "attack-pattern--b4409cd8-0da9-46e1-a401-a241afd4d1cc",
        "method_steps": [
          {
            "step_id": 1,
            "description": "While logged into a compromised GitHub user account with an active, MFA-validated session, navigate to the account’s security settings to manage multi-factor authentication methods.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "User account security settings UI for 2FA, passkeys, and recovery codes (https://docs.github.com/en/authentication)."
            ],
            "related_data": [
              "2FA configuration (TOTP apps, SMS numbers, passkeys).",
              "Recovery codes associated with the account.",
              "Security logs of MFA changes."
            ],
            "notes": "Similar to real-world campaigns where attackers register their own MFA devices after gaining access."
          },
          {
            "step_id": 2,
            "description": "Register an attacker-controlled MFA method, such as a new WebAuthn passkey or authenticator app, ensuring that it can be used independently of the victim’s existing device.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "2FA/passkey enrollment flow in the authentication docs (https://docs.github.com/en/authentication)."
            ],
            "related_data": [
              "New passkey or TOTP seed bound to the attacker’s device.",
              "Updated MFA enrollment metadata stored with the account."
            ],
            "notes": "This mirrors cases where adversaries bind their own MFA tokens to victim accounts, effectively hijacking MFA rather than bypassing it."
          },
          {
            "step_id": 3,
            "description": "Capture and store updated recovery codes, if GitHub exposes them during MFA changes, in attacker-controlled storage to provide an additional way to bypass loss of the attacker’s MFA device.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Recovery code generation and display in the security settings UI (https://docs.github.com/en/authentication)."
            ],
            "related_data": [
              "Printed or downloaded recovery codes.",
              "Account-level metadata showing that recovery codes were regenerated."
            ],
            "notes": "Recovery codes can sometimes be used to satisfy MFA even if all authenticators are reset."
          },
          {
            "step_id": 4,
            "description": "Optionally, remove or disable existing MFA methods that are not under attacker control (if allowed by policy), forcing all future MFA challenges to rely on attacker-owned methods or recovery codes.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Security settings UI for removing MFA devices (https://docs.github.com/en/authentication)."
            ],
            "related_data": [
              "Updated list of registered MFA factors for the account.",
              "Security log entries documenting MFA changes."
            ],
            "notes": "This increases persistence risk but may be more noticeable to the legitimate user if they are still active."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "User account security settings for 2FA, passkeys, and recovery codes (https://docs.github.com/en/authentication)."
        ],
        "data_accessed": [
          "MFA enrollment data (TOTP seeds, passkey metadata).",
          "Recovery codes tied to the account.",
          "Account-level security logs for MFA changes."
        ],
        "preconditions_required": [
          "Attacker has an active authenticated session for the target GitHub user account that has already passed MFA Required and SSO-Only Authentication.",
          "The environment allows users to manage their own MFA methods in GitHub’s security settings (as documented under Authentication & Account Security Management)."
        ],
        "constraints_encountered": [
          "MFA Required means initial compromise is harder, but once inside, attackers can still register new factors if they satisfy any re-auth prompts.",
          "SSO-Only Authentication may centralize some MFA enforcement at the IdP, so MFA manipulation may also require or be constrained by IdP-side policies outside GitHub.",
          "Account security logs and organization/enterprise audit logs will record MFA enrollment and removal events, providing defenders with detection opportunities."
        ],
        "evasion_considerations": [
          "Add attacker-controlled MFA methods without removing existing ones to reduce the chance the legitimate user is immediately locked out and raises an incident.",
          "Perform MFA changes during times the legitimate user is unlikely to be active to avoid real-time prompts or confusion.",
          "Limit the number of MFA changes to avoid creating an anomalous pattern in audit and security logs."
        ],
        "comments": "By binding attacker-controlled MFA devices and/or recovery codes to a compromised GitHub account, the attacker can preserve access even if passwords change, converting MFA from a defensive barrier into part of their persistence strategy.",
        "persistence_mechanism": "Attacker-registered MFA methods and recovery codes on compromised accounts that allow the attacker to continue passing MFA challenges and logging in even as other credentials change."
      },
      {
        "can_achieve": true,
        "technique_name": "Modify Authentication Process",
        "technique_stix_id": "attack-pattern--f4c1826f-a322-41cd-9557-562100848c84",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised enterprise owner or delegated IAM administrator account, access the GitHub Enterprise Cloud admin portal to manage IAM settings, including SAML/OIDC SSO and Enterprise Managed Users.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management",
              "Identity & Authentication Service"
            ],
            "related_interfaces": [
              "Enterprise Cloud admin portal for IAM configuration (https://docs.github.com/en/enterprise-cloud@latest/admin).",
              "Enterprise IAM management documentation (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)."
            ],
            "related_data": [
              "Enterprise IAM configuration, including SAML/OIDC SSO, EMU, and SCIM provisioning settings.",
              "Enterprise roles and delegations controlling IAM changes."
            ],
            "notes": "This is analogous to modifying cloud IAM or federation services to backdoor authentication flows."
          },
          {
            "step_id": 2,
            "description": "Adjust SAML/OIDC SSO configuration or Enterprise Managed Users mappings so that identities controlled by the attacker (for example, accounts in an attacker-controlled IdP tenant or SCIM source) are recognized as valid users within the enterprise and mapped to desired organizations and roles.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management",
              "Organizations & Enterprise Admin Service"
            ],
            "related_interfaces": [
              "IAM configuration UI for SAML/OIDC SSO and EMU (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam).",
              "Organization settings where SSO and membership policies intersect (https://docs.github.com/en/organizations)."
            ],
            "related_data": [
              "SSO and SAML assertion metadata linking IdP identities to GitHub users.",
              "SCIM provisioning rules and EMU configuration.",
              "Organization membership records for SSO/EMU-provisioned identities."
            ],
            "notes": "This may involve pointing GitHub at an attacker-controlled IdP or modifying group/attribute mappings so attacker identities are provisioned into privileged GitHub roles."
          },
          {
            "step_id": 3,
            "description": "Ensure that new attacker-controlled identities, once authenticated via the modified SSO process, are automatically assigned to privileged roles or teams (for example, via SAML group-to-team mappings or EMU provisioning rules).",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Organization membership and team configuration UI (https://docs.github.com/en/organizations).",
              "Enterprise and org-level IAM/SSO mapping configuration (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)."
            ],
            "related_data": [
              "Team and role assignment rules tied to SSO/EMU groups.",
              "Organization and repository access granted to provisioned identities."
            ],
            "notes": "Once configured, this provides an automatic on-ramp: any time the attacker logs into the IdP with a matching identity, GitHub will grant them the mapped privileges."
          }
        ],
        "capabilities_used": [
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management",
          "Identity & Authentication Service",
          "Organization & Team Administration",
          "Organizations & Enterprise Admin Service"
        ],
        "interfaces_used": [
          "Enterprise Cloud admin IAM configuration UI (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam).",
          "Enterprise admin overview and settings (https://docs.github.com/en/enterprise-cloud@latest/admin/overview/about-github-for-enterprises).",
          "Organization settings UI for membership and SSO-related behavior (https://docs.github.com/en/organizations)."
        ],
        "data_accessed": [
          "SSO and SAML assertion metadata and configuration.",
          "SCIM provisioning and Enterprise Managed Users data.",
          "Enterprise IAM and role configuration.",
          "Organization membership and team mapping rules."
        ],
        "preconditions_required": [
          "Attacker has compromised an account with enterprise-level IAM administration rights in GitHub Enterprise Cloud.",
          "Attacker controls or can influence an external IdP or SCIM source used for SAML/OIDC/EMU, or can introduce a new, attacker-controlled IdP into the configuration.",
          "SSO-Only Authentication is enabled, so SSO configuration fully gates login to enterprise organizations."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication significantly restrict who can access and change enterprise IAM settings; only fully compromised enterprise admins can perform these changes.",
          "Domain-Based Registration and Admin Approval Required may also apply at the IdP or enterprise level, constraining which external identities can be provisioned.",
          "Enterprise and organization audit logs will record IAM configuration changes, providing a strong detection point for defenders.",
          "Any misconfiguration may cause noticeable authentication outages, drawing attention to changes."
        ],
        "evasion_considerations": [
          "Prefer subtle modifications, such as adding an extra SSO group-to-team mapping or EMU provisioning rule, rather than changing the primary IdP or disabling security controls outright.",
          "Align new attacker-controlled identities with naming and domain patterns that look legitimate within the enterprise.",
          "Stage changes during planned maintenance windows or other expected configuration-change periods to reduce suspicion."
        ],
        "comments": "By modifying how GitHub trusts external identity providers and provisions Enterprise Managed Users, an attacker can ensure that identities they control will always be able to authenticate and receive appropriate privileges, even if specific compromised user accounts are later disabled.",
        "persistence_mechanism": "Backdoored SSO/EMU/SCIM configuration that causes attacker-controlled external identities to be recognized and provisioned as valid, often privileged, GitHub Enterprise users whenever they authenticate via the configured IdP."
      }
    ],
    "summary": "Within GitHub as described, multiple realistic persistence mechanisms exist. The strongest revolve around identity and automation: adding extra long-lived PATs, SSH keys, and deploy keys (Additional Cloud Credentials); registering and installing attacker-controlled GitHub Apps or OAuth apps that retain scoped API and webhook access independent of any one user (Cloud Account); embedding malicious scheduled or event-driven GitHub Actions workflows that automatically re-add access or repair backdoors (Event Triggered Execution); quietly granting redundant privileged roles to attacker-controlled accounts via organization owners, teams, and direct collaborators (Additional Cloud Roles); continuing to use fully compromised valid accounts without further configuration changes (Valid Accounts); and manipulating MFA enrollment and enterprise IAM/SSO configuration so that attacker-controlled identities can always authenticate and receive privileges even after remediation attempts (Multi-Factor Authentication and Modify Authentication Process). Environment constraints such as MFA Required, SSO-Only Authentication, IP Allowlisting, Domain-Based Registration, and Admin Approval Required raise the bar for initial compromise and some administrative actions, but do not fundamentally prevent these persistence paths once an attacker has obtained sufficiently privileged identities and can operate from allowlisted networks."
  },
  "privilege_escalation": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Additional Cloud Roles",
        "technique_stix_id": "attack-pattern--2dbbdcd5-92cf-44c0-aea2-fe24783a6bc3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use a compromised organization owner or enterprise owner account (or an app/token with equivalent admin scopes) to authenticate to GitHub and access the relevant organization or enterprise administration surfaces.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/organizations",
              "https://docs.github.com/en/organizations/collaborating-with-groups-in-organizations/accessing-your-organizations-settings",
              "https://docs.github.com/en/enterprise-cloud@latest/admin",
              "https://docs.github.com/en/rest/orgs/orgs",
              "https://docs.github.com/en/rest/enterprise-teams/enterprise-teams"
            ],
            "related_data": [
              "Organization accounts and profiles",
              "Members, outside collaborators, and roles",
              "Enterprise account metadata",
              "Enterprise roles and delegations",
              "User identities and authentication credentials (including personal access tokens and GitHub App tokens)"
            ],
            "notes": "This assumes the attacker has already bypassed MFA/SSO/IP restrictions on at least one high-privilege identity via other tactics (for example, stolen session, token, or IdP compromise)."
          },
          {
            "step_id": 2,
            "description": "Enumerate existing organization members, their roles, teams, and (if applicable) enterprise teams to identify one or more attacker-controlled accounts (for example, a personal account or managed user) that currently have low or no privileges but can be promoted.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/organizations/managing-membership-in-your-organization",
              "https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/roles-in-an-organization",
              "https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams",
              "https://docs.github.com/en/rest/orgs/orgs",
              "https://docs.github.com/en/rest/teams/teams"
            ],
            "related_data": [
              "Organization members and outside collaborators, with associated roles",
              "Teams and team hierarchies",
              "Repository-level collaborator and team permissions",
              "Enterprise-wide lists of organizations and enterprise teams"
            ],
            "notes": "Real-world campaigns abusing Additional Cloud Roles commonly inventory IAM objects to find or create low-visibility admin principals before promotion."
          },
          {
            "step_id": 3,
            "description": "If necessary, ensure there is at least one additional attacker-controlled GitHub account that can be associated with the enterprise or organization (for example, an existing Enterprise Managed User or a previously approved member account), so it can be promoted to a privileged role.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/authentication",
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim",
              "https://docs.github.com/en/organizations/managing-membership-in-your-organization/inviting-users-to-join-your-organization"
            ],
            "related_data": [
              "User identities and account metadata",
              "Enterprise Managed User accounts and their provisioning state",
              "Organization membership lists"
            ],
            "notes": "Environment constraints like SSO-only authentication, domain-based registration, and admin approval usually mean the attacker must either leverage an existing managed account or abuse IdP/SCIM (see Cloud Accounts vector) to get an attacker-controlled identity recognized by GitHub."
          },
          {
            "step_id": 4,
            "description": "Promote the attacker-controlled account to a high-privilege organization role (for example, owner or a custom org role with admin capabilities) or add it to a team that has admin access to many repositories.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/using-organization-roles",
              "https://docs.github.com/en/organizations/managing-user-access-to-your-organizations-repositories/managing-repository-roles/managing-an-individuals-access-to-an-organization-repository",
              "https://docs.github.com/en/organizations/organizing-members-into-teams/adding-organization-members-to-a-team",
              "https://docs.github.com/en/rest/orgs/orgs",
              "https://docs.github.com/en/rest/teams/teams",
              "https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Roles in an organization (owners, admins, members, billing managers, security managers, etc.)",
              "Team memberships and associated repository permissions",
              "Repository visibility and collaborator permissions"
            ],
            "notes": "This is the core Additional Cloud Roles action: assign high-level org roles or team-based admin access to attacker-controlled accounts, as seen in many cloud IAM abuse cases."
          },
          {
            "step_id": 5,
            "description": "If the compromised identity has enterprise-level privileges, grant the same attacker-controlled account enterprise owner or admin rights and/or add it to privileged enterprise teams that span multiple organizations.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/enterprise-cloud@latest/admin/overview/about-github-for-enterprises",
              "https://docs.github.com/en/enterprise-cloud@latest/admin",
              "https://docs.github.com/en/rest/enterprise-teams/enterprise-teams"
            ],
            "related_data": [
              "Enterprise roles and delegations",
              "List of organizations and their settings",
              "Enterprise-wide teams and their organization/repository mappings"
            ],
            "notes": "This step turns a single compromised owner into a durable, attacker-controlled enterprise-wide admin principal."
          },
          {
            "step_id": 6,
            "description": "Optionally demote or remove some legitimate owners/admins while leaving at least one attacker-controlled owner or admin in place, to reduce the chance that defenders can easily revoke all elevated access.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/organizations/managing-membership-in-your-organization/removing-a-member-from-your-organization",
              "https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/maintaining-ownership-continuity-for-your-organization",
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/managing-recovery-codes-for-your-enterprise"
            ],
            "related_data": [
              "Organization membership lists and roles",
              "Enterprise owners and admins",
              "Organization and enterprise audit logs"
            ],
            "notes": "This is more about persistence and defense evasion, but it cements the new elevated roles as the attacker’s long-term foothold."
          }
        ],
        "capabilities_used": [
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Repository Management & Source Code Hosting",
          "Authentication & Account Security Management",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Organizations & Enterprise Admin Service",
          "Identity & Authentication Service"
        ],
        "interfaces_used": [
          "https://docs.github.com/en/organizations",
          "https://docs.github.com/en/organizations/managing-membership-in-your-organization",
          "https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/roles-in-an-organization",
          "https://docs.github.com/en/organizations/organizing-members-into-teams/about-teams",
          "https://docs.github.com/en/organizations/managing-organization-settings/transferring-organization-ownership",
          "https://docs.github.com/en/enterprise-cloud@latest/admin",
          "https://docs.github.com/en/enterprise-cloud@latest/admin/overview/about-github-for-enterprises",
          "https://docs.github.com/en/rest/orgs/orgs",
          "https://docs.github.com/en/rest/teams/teams",
          "https://docs.github.com/en/rest/enterprise-teams/enterprise-teams",
          "https://docs.github.com/en/rest/repos/repos",
          "https://docs.github.com/en/authentication"
        ],
        "data_accessed": [
          "Organization accounts and profiles",
          "Members, outside collaborators, and roles",
          "Teams and team hierarchies",
          "Repository-level collaborator and team permissions",
          "Org-level feature flags and base permissions",
          "Enterprise account metadata",
          "Enterprise roles and delegations",
          "Org and enterprise audit logs"
        ],
        "preconditions_required": [
          "Attacker controls at least one identity or token with sufficient privileges to manage organization or enterprise membership and roles (for example, an organization owner, an enterprise owner, or an app/token with equivalent admin scopes).",
          "The target environment uses standard GitHub organizations and/or an enterprise account (GitHub Enterprise Cloud) with role-based access control over members, teams, and repositories.",
          "If SSO-only authentication, domain-based registration, or admin approval for accounts is enforced, the attacker must already possess or create (via IdP/SCIM abuse) at least one approved, enterprise-recognized account they fully control."
        ],
        "constraints_encountered": [
          "MFA Required: Changes to membership and roles made via the web UI may require a prior MFA-authenticated session ('sudo' mode). However, once a high-privilege session or token is compromised, GitHub does not require MFA for each individual admin API call.",
          "SSO-Only Authentication: Enterprise SSO and SAML/OIDC enforcement limit which identities can sign in and be granted owner/enterprise roles, so attacker-controlled accounts must be provisioned through the IdP or SCIM integration (see Cloud Accounts vector).",
          "Domain-Based Registration and Admin Approval Required: New GitHub accounts often must belong to approved domains and may require admin approval. This restricts creating arbitrary personal 'shadow admin' accounts, pushing the attacker toward reusing existing managed users or abusing identity integrations.",
          "IP Allowlisting: If org/enterprise IP allowlists are in place, admin operations from unusual IPs may be blocked; the attacker may need to operate from an allowlisted network or through existing automation (for example, a GitHub App or Actions runner already permitted).",
          "Rate Limiting: Bulk role changes via the REST API may trigger rate limits; an attacker may need to batch or stage changes."
        ],
        "evasion_considerations": [
          "Stage promotions over time and avoid mass changes in a single burst to blend into normal administrative activity patterns.",
          "Name attacker-controlled accounts and teams to resemble legitimate service or admin accounts, reducing the chance of manual review catching them.",
          "Prefer API-based changes using existing automation tokens or GitHub Apps so that role changes appear as routine automation rather than direct interactive admin actions.",
          "Leave at least some legitimate owners/admins in place to avoid obvious outages or governance alarms that might trigger an immediate audit of roles."
        ],
        "comments": "This vector directly matches the MITRE Additional Cloud Roles technique: abusing GitHub’s org and enterprise role-management surfaces to add high-privilege roles (such as org owner or enterprise admin) to attacker-controlled accounts, creating 'shadow admins' and significantly elevating access.",
        "escalated_access": "One or more attacker-controlled GitHub accounts are granted organization owner and/or enterprise admin roles (or equivalent via teams), giving them full administrative control over members, repositories, security settings, and policies across the organization or enterprise."
      },
      {
        "can_achieve": true,
        "technique_name": "Event Triggered Execution",
        "technique_stix_id": "attack-pattern--b6301b64-ef57-4cce-bb0b-77026f14a8db",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Review repositories where the attacker has at least write or pull-request rights to identify GitHub Actions workflows that run on privileged branches and use secrets or the default GITHUB_TOKEN to call the GitHub REST API or administer resources.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/actions",
              "https://docs.github.com/en/actions/concepts/workflows-and-actions",
              "https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
              "https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "https://docs.github.com/en/rest/actions/workflows",
              "https://docs.github.com/en/repositories"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Secrets and environment variable references used by workflows",
              "GITHUB_TOKEN behavior and permissions",
              "Repository branches and workflow configuration"
            ],
            "notes": "The security traits explicitly note that misconfigured triggers (for example, certain pull_request scenarios) can be abused for secret exfiltration. The same pattern can be used to execute privileged API calls."
          },
          {
            "step_id": 2,
            "description": "Analyze workflow triggers and job configuration to find a workflow that (a) runs with high-privilege credentials (such as a PAT or GitHub App token stored as a secret, or an unrestricted GITHUB_TOKEN) and (b) can be executed based on events the attacker can cause (for example, pushing to a branch they control or opening a pull request).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/actions/concepts/workflows-and-actions/workflows",
              "https://docs.github.com/en/actions/concepts/workflows-and-actions/variables",
              "https://docs.github.com/en/actions/concepts/workflows-and-actions/contexts",
              "https://docs.github.com/en/rest/actions/workflows"
            ],
            "related_data": [
              "Workflow triggers and event types",
              "Environment variables and secrets injected into jobs",
              "Org-level Actions policies controlling token scopes and secret exposure"
            ],
            "notes": "Real-world cloud attacks (for example, malicious Lambdas triggered by storage events) mirror this step: find an event source that executes code with higher IAM privileges than the attacker currently has."
          },
          {
            "step_id": 3,
            "description": "Modify a targeted workflow (or code invoked by it) in a branch that will be executed with those high-privilege credentials, injecting a step that runs arbitrary commands and uses available secrets/tokens to call GitHub’s REST API.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/actions/concepts/workflows-and-actions/custom-actions",
              "https://docs.github.com/en/actions/concepts/workflows-and-actions/reusing-workflow-configurations",
              "https://docs.github.com/en/rest/actions/workflows",
              "https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Workflow definitions (YAML) and custom actions code",
              "Repository source files and scripts invoked by workflows",
              "Secrets and environment variables available to the job"
            ],
            "notes": "This typically requires at least write access on the affected branch or on code that the privileged workflow executes (for example, build scripts). In misconfigured pull_request or similar scenarios, untrusted code from forks can also be executed with secrets."
          },
          {
            "step_id": 4,
            "description": "Trigger the modified workflow by performing the appropriate action (for example, pushing the modified workflow or code to the target branch, or opening/updating a pull request that causes the privileged workflow to run).",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "https://docs.github.com/en/actions/concepts/workflows-and-actions/notifications-for-workflow-runs"
            ],
            "related_data": [
              "Job execution metadata and logs",
              "Workflow run events and status"
            ],
            "notes": "At this point, the attacker’s code is executed automatically by the Actions service under the security context (tokens/secrets) configured for the workflow, not the attacker’s own account."
          },
          {
            "step_id": 5,
            "description": "Within the running workflow, execute commands that use the injected secrets (for example, a PAT with admin:org scope or a GitHub App installation token) or a powerful GITHUB_TOKEN to call GitHub REST APIs that directly escalate privileges—such as adding the attacker’s account as an admin collaborator on sensitive repositories, adding them to high-privilege teams, or granting them organization owner roles if the token allows.",
            "related_capabilities": [
              "GitHub REST API",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting",
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/rest/repos/repos",
              "https://docs.github.com/en/rest/teams/teams",
              "https://docs.github.com/en/rest/orgs/orgs",
              "https://docs.github.com/en/rest/apps/apps",
              "https://docs.github.com/en/rest/authentication"
            ],
            "related_data": [
              "Personal access tokens and GitHub App tokens exposed to the workflow",
              "Organization members and roles",
              "Teams and their repository access mappings",
              "Repository collaborator permissions"
            ],
            "notes": "Instead of exfiltrating tokens, the malicious step can directly perform the role-adding API calls during the job, leaving the attacker with newly elevated privileges on their own account."
          },
          {
            "step_id": 6,
            "description": "Optionally, revert or minimize the malicious workflow changes (for example, force-push a cleanup commit or restore the previous workflow version) to make the escalation appear as if performed via normal admin activity while retaining the elevated permissions.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/repositories/creating-and-managing-repositories/about-repositories",
              "https://docs.github.com/en/actions/how-tos/manage-workflow-runs"
            ],
            "related_data": [
              "Git commit history and workflow file revisions",
              "Actions logs and artifacts"
            ],
            "notes": "Audit logs and Actions run logs will still show that the privileged workflow executed and changed membership/repo settings, but the workflow file itself may no longer contain obviously malicious code."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "Organization & Team Administration",
          "GitHub Apps & OAuth Apps Platform",
          "Authentication & Account Security Management",
          "Webhook Event Delivery"
        ],
        "interfaces_used": [
          "https://docs.github.com/en/actions",
          "https://docs.github.com/en/actions/concepts/workflows-and-actions",
          "https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
          "https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
          "https://docs.github.com/en/rest/actions/workflows",
          "https://docs.github.com/en/rest/actions/workflow-runs",
          "https://docs.github.com/en/rest/repos/repos",
          "https://docs.github.com/en/rest/orgs/orgs",
          "https://docs.github.com/en/rest/teams/teams",
          "https://docs.github.com/en/rest/apps/apps"
        ],
        "data_accessed": [
          "Workflow YAML definitions and associated scripts",
          "Secrets and environment variables available to Actions jobs (including GITHUB_TOKEN, PATs, and app tokens)",
          "Job execution logs and artifacts",
          "Repository configuration and collaborator permissions",
          "Organization members, teams, and roles"
        ],
        "preconditions_required": [
          "Attacker has at least write access to a repository (or the ability to alter code executed by a privileged workflow) so they can influence what runs in an Actions job.",
          "There exists at least one workflow that runs with credentials (PATs, GitHub App tokens, or an unrestricted GITHUB_TOKEN) whose effective permissions exceed the attacker’s original account privileges (for example, tokens with repo admin or org admin scopes).",
          "Organization/enterprise policies allow GitHub Actions to run with these tokens and do not fully restrict token scopes or workflow sources for the relevant events."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication mainly affect interactive logins; once workflows are configured, Actions jobs run non-interactively with injected tokens, so MFA/SSO do not block this technique.",
          "IP Allowlisting may restrict where PATs or app tokens can be used; the attack depends on those tokens being usable from GitHub-hosted or self-hosted runners that are already allowed by policy.",
          "Rate Limiting on the REST API may constrain how many administrative changes the malicious job can make in a single run; an attacker may focus on a small number of high-value changes (for example, adding a single owner).",
          "Org-level policies that 'disable or limit GitHub Actions for your organization' can prevent this vector entirely if privileged tokens are never exposed to workflows that untrusted users can influence."
        ],
        "evasion_considerations": [
          "Minimize the number of malicious API calls and carry them out in a single workflow run to reduce noisy logs and abnormal patterns.",
          "Embed the malicious step in an existing custom action or build script rather than adding an obviously suspicious new step to the workflow.",
          "Schedule or trigger the workflow during times when CI/CD activity is expected, so additional runs do not appear anomalous.",
          "After escalation, restore the original workflow content to make code review less likely to reveal the malicious changes."
        ],
        "comments": "This maps directly to Event Triggered Execution for SaaS: abusing GitHub Actions workflows that automatically run in response to repository events with elevated tokens, so attacker-supplied code executes privileged GitHub API calls to grant the attacker higher roles or permissions.",
        "escalated_access": "The attacker’s own GitHub account is granted higher privileges (for example, repository admin, membership in powerful teams, or even organization owner), via API calls executed inside a privileged GitHub Actions workflow that they were able to influence."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Accounts",
        "technique_stix_id": "attack-pattern--f232fa7a-025c-4d43-abc7-318e81a73d65",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using compromised enterprise IAM or IdP/SCIM administrative access, examine how GitHub Enterprise Cloud is integrated with the identity provider, focusing on Enterprise Managed Users, SAML/OIDC SSO, and SCIM-based provisioning and group-to-team mappings.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises",
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim",
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim/managing-team-memberships-with-identity-provider-groups",
              "https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "SSO and SAML/OIDC configuration for the enterprise",
              "Enterprise Managed User identities and provisioning settings",
              "Mappings between IdP groups and GitHub organizations/teams",
              "Org membership and team membership derived from IdP groups"
            ],
            "notes": "The IAM docs explicitly describe Enterprise Managed Users and managing team memberships with identity provider groups, which allows IdP-side group changes to translate into GitHub role changes."
          },
          {
            "step_id": 2,
            "description": "Identify IdP groups or SCIM-provisioned groups that correspond to high-privilege GitHub roles, such as groups that map to organization owners, security managers, or teams with admin access to many repositories.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim/managing-team-memberships-with-identity-provider-groups",
              "https://docs.github.com/en/organizations/managing-peoples-access-to-your-organization-with-roles/roles-in-an-organization"
            ],
            "related_data": [
              "Identity provider groups and their SCIM mappings",
              "Team definitions and associated repository permissions",
              "Organization roles and role assignments"
            ],
            "notes": "This mirrors cloud campaigns where adversaries locate IAM groups that imply powerful roles (for example, global admins) and then add their own accounts to those groups."
          },
          {
            "step_id": 3,
            "description": "Add a compromised or attacker-controlled IdP identity to one or more of these high-privilege IdP groups, or modify SCIM group mappings so that the attacker’s identity is included in a group mapped to a privileged GitHub team or organization role.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim/provisioning-users-and-groups-with-scim-using-the-rest-api",
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim/configuring-scim-provisioning-for-users"
            ],
            "related_data": [
              "SCIM user and group objects",
              "Provisioning rules for EMU accounts",
              "Mappings from IdP groups to GitHub teams and org memberships"
            ],
            "notes": "SCIM APIs and IdP consoles are external to GitHub but are explicitly supported integration points that determine which cloud accounts (GitHub EMUs) exist and what access they receive."
          },
          {
            "step_id": 4,
            "description": "Wait for SCIM and SSO synchronization to propagate, causing GitHub to automatically provision (or update) the attacker-controlled Enterprise Managed User account and add it to the corresponding organizations and privileged teams/roles.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim",
              "https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "Enterprise Managed User accounts and their org memberships",
              "Team memberships derived from IdP groups",
              "Org-level roles associated with EMU accounts"
            ],
            "notes": "Once the mapping is in place, GitHub treats the attacker’s EMU as a legitimate, centrally managed cloud account with whatever privileges the IdP groups confer."
          },
          {
            "step_id": 5,
            "description": "Authenticate to GitHub via SSO using the attacker-controlled identity, now backed by the privileged group memberships, and verify elevated GitHub access (for example, seeing that the account is an org owner, security manager, or a member of admin teams across multiple organizations).",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/using-saml-for-enterprise-iam",
              "https://docs.github.com/en/authentication",
              "https://docs.github.com/en/organizations/collaborating-with-groups-in-organizations/about-organizations"
            ],
            "related_data": [
              "Authenticated GitHub sessions for EMU identities",
              "Organization membership and role assignments for the attacker’s account",
              "Team memberships across organizations"
            ],
            "notes": "At this point, privilege escalation has occurred entirely via manipulation of cloud identity mappings—GitHub believes the attacker’s account is legitimately entitled to the new roles."
          }
        ],
        "capabilities_used": [
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "GitHub REST API",
          "Organizations & Enterprise Admin Service",
          "Identity & Authentication Service"
        ],
        "interfaces_used": [
          "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam",
          "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/understanding-iam-for-enterprises",
          "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim",
          "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim/managing-team-memberships-with-identity-provider-groups",
          "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/provisioning-user-accounts-with-scim/provisioning-users-and-groups-with-scim-using-the-rest-api",
          "https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam/using-saml-for-enterprise-iam",
          "https://docs.github.com/en/authentication",
          "https://docs.github.com/en/organizations"
        ],
        "data_accessed": [
          "SSO and SAML/OIDC assertion metadata",
          "Enterprise Managed User accounts and their provisioning state",
          "SCIM user and group objects",
          "Mappings between IdP groups and GitHub teams/organizations",
          "Org membership lists and roles"
        ],
        "preconditions_required": [
          "The target is using GitHub Enterprise Cloud with Enterprise Managed Users and SCIM/SAML/OIDC-based identity integrations.",
          "Attacker has compromised the enterprise’s identity provider (IdP) or the SCIM provisioning application/credentials sufficiently to modify group memberships or SCIM mappings.",
          "High-privilege GitHub roles (such as owner or admin teams) are in fact driven by IdP groups or SCIM-provisioned groups, which is a documented and common configuration."
        ],
        "constraints_encountered": [
          "SSO-Only Authentication: When all GitHub access must go through SSO, local account creation is not a viable escalation path; instead the attacker must manipulate cloud accounts and IdP mappings as described in this vector.",
          "MFA Required and Conditional Access Policies: These are enforced by the IdP; a successful attacker must either control the IdP configuration or also obtain the necessary MFA factors, but once done, GitHub will accept the resulting SSO sessions as valid.",
          "Domain-Based Registration and Admin Approval: EMU and SCIM provisioning inherently respect enterprise domain restrictions and approval workflows; the attacker must operate from within those trusted mechanisms (for example, by creating a new EMU via SCIM).",
          "IP Allowlisting: If conditional access policies restrict SSO logins by IP, the attacker must either operate from an allowed IP range or relax those policies at the IdP."
        ],
        "evasion_considerations": [
          "Add the attacker-controlled identity to existing high-privilege IdP groups whose membership occasionally changes, rather than creating obviously suspicious new groups.",
          "Use display names and email addresses for the attacker’s EMU that resemble service or automation accounts, making their presence in admin groups less conspicuous.",
          "Avoid aggressive changes to IAM or SCIM mappings that would trigger wide-scale reprovisioning or draw attention in identity governance reviews."
        ],
        "comments": "This vector reflects the Cloud Accounts technique applied to GitHub Enterprise Cloud: by abusing SAML/OIDC and SCIM-based provisioning, an attacker can cause GitHub to recognize an attacker-controlled cloud identity as a high-privilege managed user, thereby escalating privileges inside GitHub without directly compromising any existing GitHub admin account.",
        "escalated_access": "An attacker-controlled Enterprise Managed User account gains organization owner or equivalent administrative/team-based privileges across one or more organizations within the enterprise GitHub environment."
      },
      {
        "can_achieve": true,
        "technique_name": "Valid Accounts",
        "technique_stix_id": "attack-pattern--b17a1a56-e99c-403c-8948-561df0cffe81",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use previously obtained credentials or tokens (for example, a personal access token, SSH key, OAuth token, or GitHub App private key) belonging to a more-privileged GitHub user or app than the attacker’s original account.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/authentication",
              "https://docs.github.com/en/rest/authentication",
              "https://docs.github.com/en/apps",
              "https://docs.github.com/en/rest/apps/apps"
            ],
            "related_data": [
              "Personal access tokens (classic and fine-grained)",
              "SSH keys and deploy keys",
              "GitHub App private keys and installation tokens",
              "OAuth app client secrets and user tokens"
            ],
            "notes": "The acquisition of these credentials (for example, via code leaks, logs, or other systems) is outside this privilege escalation step and corresponds to other tactics (Credential Access, Initial Access)."
          },
          {
            "step_id": 2,
            "description": "Authenticate to GitHub’s APIs or Git transport as the more-privileged principal by presenting the stolen token/key, thereby assuming that account’s identity for all authorized operations.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/rest",
              "https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api",
              "https://docs.github.com/en/get-started/git-basics/set-up-git"
            ],
            "related_data": [
              "Authenticated API sessions tied to the compromised account",
              "Git operations (clone, fetch, push) authorized by the compromised credentials"
            ],
            "notes": "From GitHub’s perspective, all actions now appear to originate from the legitimate highly privileged account or app."
          },
          {
            "step_id": 3,
            "description": "Enumerate the effective privileges of the compromised account or app by listing accessible organizations, repositories, teams, and security data, using the REST API or the web UI under the assumed identity.",
            "related_capabilities": [
              "GitHub REST API",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/rest/orgs/orgs",
              "https://docs.github.com/en/rest/repos/repos",
              "https://docs.github.com/en/rest/teams/teams",
              "https://docs.github.com/en/code-security/securing-your-organization"
            ],
            "related_data": [
              "Organization memberships and roles of the compromised account",
              "Repositories and their permissions for that account/app",
              "Teams and security configurations the account can see or manage"
            ],
            "notes": "This confirms that the attacker has effectively escalated from their original low-privilege context to that of a more-privileged cloud account."
          },
          {
            "step_id": 4,
            "description": "Leverage the compromised account’s elevated access to perform actions that were previously impossible for the attacker’s own account, such as reading or modifying private repositories, adjusting security settings, or administering workflows and tokens.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)",
              "Organization & Team Administration",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "https://docs.github.com/en/repositories",
              "https://docs.github.com/en/actions",
              "https://docs.github.com/en/organizations",
              "https://docs.github.com/en/code-security/securing-your-organization",
              "https://docs.github.com/en/rest"
            ],
            "related_data": [
              "Private repository content and branches",
              "Workflow definitions and secrets",
              "Org-level security configurations and policies",
              "Org and repo membership/permissions"
            ],
            "notes": "Further escalation of roles (for example, creating additional owners or shadow admins) can then be performed via the Additional Cloud Roles vector using these now-valid elevated credentials."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "GitHub Apps & OAuth Apps Platform",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
        ],
        "interfaces_used": [
          "https://docs.github.com/en/authentication",
          "https://docs.github.com/en/rest/authentication",
          "https://docs.github.com/en/rest",
          "https://docs.github.com/en/rest/orgs/orgs",
          "https://docs.github.com/en/rest/repos/repos",
          "https://docs.github.com/en/rest/teams/teams",
          "https://docs.github.com/en/apps",
          "https://docs.github.com/en/rest/apps/apps"
        ],
        "data_accessed": [
          "Stolen or misused authentication credentials (PATs, SSH keys, OAuth tokens, GitHub App private keys)",
          "Organization memberships and roles associated with the compromised account",
          "Private repositories and their contents",
          "Workflow and security configurations accessible to the compromised account"
        ],
        "preconditions_required": [
          "Attacker has successfully obtained valid credentials or tokens for a GitHub user or app whose privileges exceed those of the attacker’s original foothold.",
          "Any MFA, SSO, IP-allowlisting, or conditional access restrictions that apply to the compromised account either do not apply to the stolen token type or have already been bypassed (for example, via app tokens or PATs that operate without re-prompting MFA)."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication can significantly hinder reuse of username/password credentials but may not fully protect against misuse of long-lived PATs, SSH keys, or GitHub App tokens once those are stolen.",
          "IP Allowlisting may limit where stolen tokens can be used; tokens bound to specific IP ranges will only function from allowed networks or from existing runners already on those networks.",
          "Rate Limiting and anomaly detection may expose very noisy or large-scale abuse of a compromised high-privilege account, encouraging attackers to act selectively."
        ],
        "evasion_considerations": [
          "Use the compromised account in a low-and-slow manner that mirrors the normal activity profile of that user or app (for example, same set of repositories, similar times of day).",
          "Prefer API-based interactions over direct UI logins when using stolen tokens to avoid triggering additional authentication challenges or user-visible login alerts.",
          "Where possible, restrict operations to a subset of high-value repositories and organizations to minimize the forensic footprint."
        ],
        "comments": "This vector applies the Valid Accounts technique in a GitHub-specific way: once an attacker acquires credentials for a more-privileged GitHub user or app, they can immediately assume that cloud account’s permissions to access organizations, repositories, and security configuration that were previously unavailable to them.",
        "escalated_access": "The attacker transitions from a low-privilege or external user to operating as a more-privileged GitHub account (such as an organization owner, security manager, or powerful GitHub App), gaining whatever access that account already had to repositories, organizations, and configuration."
      },
      {
        "can_achieve": false,
        "technique_name": "Additional Cloud Credentials",
        "technique_stix_id": "attack-pattern--8a2f40cf-8325-47f9-96e4-b1ca4c7389bd",
        "method_steps": [],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Automation with GitHub Actions (User Perspective)",
          "Cloud Development Environments with GitHub Codespaces"
        ],
        "interfaces_used": [
          "https://docs.github.com/en/authentication",
          "https://docs.github.com/en/rest/authentication",
          "https://docs.github.com/en/apps",
          "https://docs.github.com/en/rest/apps/apps",
          "https://docs.github.com/en/actions",
          "https://docs.github.com/en/codespaces"
        ],
        "data_accessed": [
          "Personal access tokens and fine-grained PATs",
          "GitHub App private keys and installation tokens",
          "OAuth app client secrets and access tokens",
          "Runtime tokens and secrets in Actions and Codespaces"
        ],
        "preconditions_required": [
          "Attacker would already need control of a GitHub account or app with the high privileges they desire, as GitHub’s credential-creation flows do not grant permissions beyond those already assigned to the underlying principal."
        ],
        "constraints_encountered": [
          "PAT and app token scopes are constrained by the privileges of the underlying user or app; creating new tokens cannot exceed those underlying permissions.",
          "Organization-level policies can restrict PAT creation and app installation scopes, requiring owner approval for high-privilege tokens.",
          "MFA and SSO enforcement apply when accessing the UI to create or manage credentials, so an attacker must already have overcome those controls for the high-privilege account."
        ],
        "evasion_considerations": [
          "If used for persistence rather than privilege escalation, attackers may create innocuous-looking tokens or GitHub Apps and store their credentials in automation or CI secrets to blend into normal patterns."
        ],
        "comments": "While GitHub provides rich mechanisms for creating additional credentials (PATs, GitHub App keys, OAuth tokens, and runtime tokens in Actions/Codespaces), these credentials inherit permissions from the underlying user or app and do not, by themselves, grant new or higher privileges within GitHub. Any actual escalation of what the principal can do must still occur through role or membership changes (captured by Additional Cloud Roles and Cloud Accounts) or by compromising more-privileged accounts (captured by Valid Accounts). Therefore, as a standalone privilege escalation technique in GitHub, Additional Cloud Credentials is not achievable.",
        "escalated_access": "None beyond the permissions already assigned to the compromised user or app; additional credentials merely provide alternate or more persistent ways to exercise existing access."
      },
      {
        "can_achieve": false,
        "technique_name": "Default Accounts",
        "technique_stix_id": "attack-pattern--6151cbea-819b-455a-9fa6-99a1cc58797d",
        "method_steps": [],
        "capabilities_used": [],
        "interfaces_used": [],
        "data_accessed": [],
        "preconditions_required": [
          "GitHub would need to expose vendor-created, hard-coded administrator or service accounts with default passwords or keys that customers cannot fully manage or delete, analogous to factory default accounts on appliances or cloud root users."
        ],
        "constraints_encountered": [
          "The documented GitHub account model is based on user, organization, and enterprise accounts created and managed by customers; administrator roles are assigned to these accounts, not to hidden or factory default users.",
          "Enterprise IAM and SSO/SSO-only constraints, domain-based registration, and admin approval flows further reinforce that new high-privilege identities must be explicitly provisioned and approved, not inherited from default credentials."
        ],
        "evasion_considerations": [],
        "comments": "The ApplicationCapabilityAnalysis and GitHub documentation do not describe any built-in default administrator accounts with preset credentials that could be hijacked. All privileged roles (organization owners, enterprise owners, security managers, etc.) are attached to regular GitHub accounts managed via IAM and membership flows. As a result, the Default Accounts technique does not provide a realistic privilege escalation path within GitHub.",
        "escalated_access": "None; GitHub does not expose default high-privilege accounts that can be taken over for escalation."
      }
    ],
    "summary": "Privilege escalation in GitHub is realistically achievable via (1) abusing organization and enterprise role-management to assign attacker-controlled accounts as organization owners or enterprise admins (Additional Cloud Roles), (2) leveraging misconfigured or over-privileged GitHub Actions workflows to run attacker-supplied code with powerful tokens that then call the REST API to grant higher roles (Event Triggered Execution), (3) manipulating SAML/OIDC and SCIM-based identity integrations so that Enterprise Managed User accounts controlled by the attacker are automatically granted high-privilege roles via IdP groups (Cloud Accounts), and (4) operating directly as more-privileged users or apps after obtaining their credentials or tokens (Valid Accounts). Additional Cloud Credentials and Default Accounts do not introduce distinct privilege escalation paths in GitHub: extra tokens and keys inherit existing permissions, and GitHub does not expose factory default admin accounts. Environment constraints like MFA, SSO-only authentication, domain-based registration, admin approval, IP allowlisting, and rate limiting primarily affect how the initial foothold or identity compromise is achieved, but once a high-privilege identity or token is controlled, the described vectors remain feasible through documented administration, automation, and IAM features."
  },
  "defense_evasion": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Disable or Modify Cloud Logs",
        "technique_stix_id": "attack-pattern--cacc40da-4c9e-462c-80d5-fd70a178b12d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "From an already-compromised organization owner or security-manager account (authenticated via SSO/MFA from an allowlisted IP), open the organization’s **“Securing your organization”** security center to view existing security configurations and repository coverage.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Org security center UI – Securing your organization",
              "Organization settings UI – Organization & Team Administration"
            ],
            "related_data": [
              "Lists of repositories and their security feature status",
              "Security configurations applied to repositories",
              "Organization account metadata and member roles"
            ],
            "notes": "Assumes the attacker already has valid high-privilege org credentials and can satisfy SSO/MFA/IP constraints."
          },
          {
            "step_id": 2,
            "description": "Edit or detach security configurations so that **code scanning** and **secret scanning** are disabled or not required for sensitive repositories (for example, removing them from the configuration’s target set or turning off Advanced Security features).",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Code Scanning for Static Application Security Testing",
              "Secret Scanning & Push Protection",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines"
            ],
            "related_interfaces": [
              "Org security center UI – manage security configurations",
              "REST Code security configurations API"
            ],
            "related_data": [
              "Security configuration objects (which features are enabled where)",
              "Per-repository flags for code scanning and secret scanning",
              "Organization audit log entries for configuration changes"
            ],
            "notes": "Mirrors real-world attacks (e.g., APT29 disabling M365 audit) by turning off or narrowing central security tooling before performing further actions."
          },
          {
            "step_id": 3,
            "description": "Lower the scope or frequency of **Dependabot** checks by editing org-level Dependabot settings and per-repository dependabot.yml files so that only non-critical ecosystems or paths are monitored, or by disabling Dependabot on selected repositories.",
            "related_capabilities": [
              "Dependency & Supply Chain Management with Dependabot",
              "Automated Dependency & Security Remediation Jobs",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Repository security UI – Dependabot settings",
              "Org security center UI – Dependabot coverage",
              "Dependabot configuration files (dependabot.yml)"
            ],
            "related_data": [
              "Dependabot configuration files and settings",
              "Dependabot alert and job metadata",
              "Org audit log entries for security/feature changes"
            ],
            "notes": "Reduces generation of new vulnerability alerts that might reveal risky code or dependencies."
          },
          {
            "step_id": 4,
            "description": "For repositories using Actions-based code scanning (e.g., CodeQL workflows), modify or remove the **.github/workflows** scanning workflows so that scans no longer run on key branches or events (for example, restricting to a rarely used branch).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Code Scanning for Static Application Security Testing"
            ],
            "related_interfaces": [
              "Repository code browser / Settings for workflows",
              ".github/workflows YAML editing via Git or web UI",
              "REST Actions workflows API"
            ],
            "related_data": [
              "Workflow definitions (YAML) for code scanning",
              "Workflow run metadata and logs",
              "Branch protection configuration referencing scanning checks"
            ],
            "notes": "Imitates cloud tooling like Pacu that programmatically disables logging/scanning by modifying configuration rather than deleting logs."
          },
          {
            "step_id": 5,
            "description": "If an enterprise account exists, use **Enterprise Cloud** admin settings to loosen or remove enterprise policies that mandate Advanced Security features for child organizations, letting org owners keep protections off without violating enterprise policy.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Enterprise admin UI – policies and security",
              "Enterprise REST admin APIs (where available)"
            ],
            "related_data": [
              "Enterprise-wide policy objects for Actions, security, and repositories",
              "Lists of organizations and their policy assignments",
              "Enterprise audit log entries"
            ],
            "notes": "This extends the downgrade across many orgs in a similar fashion to APT29’s tenant-wide logging changes in Microsoft 365."
          },
          {
            "step_id": 6,
            "description": "Optionally automate the above changes via **GitHub REST API** calls or a malicious GitHub App, so that large numbers of repositories are reconfigured quickly and the activity appears as routine bot or admin automation.",
            "related_capabilities": [
              "GitHub REST API",
              "GitHub Apps & OAuth Apps Platform",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "REST Code security configurations API",
              "REST Code scanning and Dependabot APIs",
              "GitHub Apps installation and token APIs"
            ],
            "related_data": [
              "App tokens and PATs with admin/security scopes",
              "REST request metadata and rate-limit data",
              "Org and enterprise audit logs for API-driven configuration changes"
            ],
            "notes": "Real campaigns (e.g., APT29, Pacu in AWS) routinely script cloud log/scanner downgrades; same pattern applies here via GitHub’s APIs."
          }
        ],
        "capabilities_used": [
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Code Scanning for Static Application Security Testing",
          "Secret Scanning & Push Protection",
          "Dependency & Supply Chain Management with Dependabot",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "Org “Securing your organization” security center UI",
          "Repository Security tab (Code scanning, Dependabot, Secret scanning)",
          "Enterprise Cloud admin policies UI",
          "GitHub REST API – Code security configurations",
          "GitHub REST API – Code scanning, Dependabot, secret scanning endpoints",
          "GitHub Actions workflow YAML files under .github/workflows",
          "GitHub Apps management and installation UIs"
        ],
        "data_accessed": [
          "Security configurations applied to repositories",
          "Per-repository flags for code scanning, secret scanning, and Dependabot",
          "Code scanning and secret scanning alert metadata",
          "Dependabot alert and configuration data",
          "Workflow definitions and run metadata",
          "Organization and enterprise audit logs describing security configuration changes"
        ],
        "preconditions_required": [
          "Attacker controls at least one organization owner or organization security-manager account in the target org, or an enterprise owner account for enterprise-wide changes.",
          "Attacker can satisfy SSO-only authentication and MFA at least once (or already possesses a valid session or token), and can operate from an IP range allowed by IP allowlisting.",
          "Advanced Security features (code scanning, secret scanning, Dependabot) are enabled somewhere; otherwise there is nothing to downgrade.",
          "The compromised account or app has sufficient scopes/permissions to modify security configurations and repository settings."
        ],
        "constraints_encountered": [
          "MFA Required: Initial compromise and any sensitive configuration edits may require MFA re-prompt or sudo-mode verification.",
          "SSO-Only Authentication: All access must flow through the IdP; attackers cannot bypass SSO using local GitHub passwords.",
          "IP Allowlisting: Administrative and API access must originate from allowlisted IPs (e.g., via a compromised on-prem/VDI host).",
          "Rate Limiting: Large-scale API changes must be paced or parallelized across tokens/apps to avoid throttling."
        ],
        "evasion_considerations": [
          "Stage configuration downgrades gradually and target only specific high-value repositories to avoid an obvious, global drop in security posture.",
          "Use GitHub Apps or service-style tokens so that configuration changes appear as automated administration rather than a human logged into the web UI.",
          "Retain some limited scanning/alerts on less-important repositories to preserve the appearance of normal security operations.",
          "Document benign-sounding dismissal reasons or configuration names (e.g., “temporary performance tuning”) to reduce suspicion during casual review."
        ],
        "comments": "This vector mirrors documented cloud campaigns where adversaries first degrade or disable logging/scanning (e.g., APT29 disabling M365 audit) before operating. On GitHub, the same pattern manifests as centrally switching off or narrowing Advanced Security and related protections.",
        "evasion_achieved": "Substantial reduction of security alerts and automated protections (code scanning, secret scanning, Dependabot) across targeted repositories, shrinking the volume and visibility of security signals available to defenders and SIEMs even though core audit logs still exist."
      },
      {
        "can_achieve": true,
        "technique_name": "Disable or Modify Cloud Logs",
        "technique_stix_id": "attack-pattern--cacc40da-4c9e-462c-80d5-fd70a178b12d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using compromised repository administrator or organization owner permissions, open the repository’s **Branches/Rulesets** settings and enumerate existing branch protection rules and required status checks (including code scanning checks).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Pull Requests & Code Review Workflow",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository settings UI – branches/rulesets",
              "Pull request UI showing required checks and protections"
            ],
            "related_data": [
              "Branch protection and ruleset configurations",
              "List of required status checks and review requirements",
              "Org audit log entries for branch protection changes"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Edit branch protection for sensitive branches (e.g., main, release) to remove **code scanning** and other high-signal status checks from the list of required checks, or to reduce the number of required reviews.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Code Scanning for Static Application Security Testing",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines"
            ],
            "related_interfaces": [
              "Repository settings UI – protected branch configuration",
              "REST Repos/Branches protection APIs (where available)"
            ],
            "related_data": [
              "Branch protection rule definitions",
              "Mapping of status checks to protections",
              "Audit entries capturing rule changes"
            ],
            "notes": "This effectively disables enforcement of code scanning findings without touching the scanner itself."
          },
          {
            "step_id": 3,
            "description": "Optionally introduce a new, weaker ruleset that applies only to less-critical branches while leaving sensitive branches formally protected but no longer gated on meaningful security checks (e.g., require only a trivial CI check that always passes).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Pull Requests & Code Review Workflow",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Rulesets configuration UI",
              "Actions workflow definition UI / Git editor for trivial checks"
            ],
            "related_data": [
              "Ruleset configuration objects",
              "Workflow definitions for required checks"
            ],
            "notes": "This preserves the appearance of “protected branches” in UI while neutering their effect."
          },
          {
            "step_id": 4,
            "description": "For organizations enforcing code scanning merge protection via security configurations, adjust those configurations so that merge protection is no longer tied to code scanning alert state, or is applied only to a subset of less sensitive repositories.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Org security center UI – code scanning merge protection",
              "REST Code security configurations API"
            ],
            "related_data": [
              "Code scanning merge protection policies",
              "Repository-to-configuration assignments",
              "Org audit logs for security configuration changes"
            ],
            "notes": null
          },
          {
            "step_id": 5,
            "description": "Use the weakened branch rules to merge pull requests that contain risky changes (including code that would normally trigger code scanning alerts) directly into formerly protected branches, relying on the absence of blocking checks to avoid automated detection.",
            "related_capabilities": [
              "Pull Requests & Code Review Workflow",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Pull request UI and merge controls",
              "REST Pull Requests API"
            ],
            "related_data": [
              "Pull request metadata and merge history",
              "Commit history on protected branches",
              "Audit entries for merges and rule bypasses (if any)"
            ],
            "notes": "From a logging perspective, merges now look routine because no failing checks are present to highlight risk."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Pull Requests & Code Review Workflow",
          "Code Scanning for Static Application Security Testing",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Organization & Team Administration"
        ],
        "interfaces_used": [
          "Repository settings – branches and rulesets UI",
          "Repository Security tab – code scanning merge protection settings",
          "Org security center – code scanning configuration UI",
          "REST API – repository/branch protection and code security configuration endpoints",
          "Pull request web UI and REST API"
        ],
        "data_accessed": [
          "Branch protection and ruleset definitions",
          "Required status check configuration (including code scanning checks)",
          "Code scanning merge protection policies",
          "Pull request and merge metadata",
          "Organization audit logs for configuration and merge events"
        ],
        "preconditions_required": [
          "Attacker controls a repository administrator/maintainer account or an organization owner that can edit branch protection and rulesets.",
          "Target repositories currently use branch protection and/or code scanning merge protection; otherwise there is nothing to weaken.",
          "Attacker can successfully authenticate via SSO/MFA or use an existing authenticated session or token from an allowlisted IP."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication: Editing protection settings may trigger re-auth/sudo flows, which must be satisfied using the compromised account.",
          "IP Allowlisting: Configuration changes must be made from within allowed IP ranges.",
          "Rate Limiting: Bulk API changes to many repos must be paced to avoid throttling but are otherwise feasible."
        ],
        "evasion_considerations": [
          "Adjust rules to remain superficially strict (e.g., keep review requirements) while quietly removing the most informative security checks.",
          "Apply weaker protections only to a subset of repositories or branches to avoid obvious global policy changes.",
          "Make changes via automation (GitHub App or scripted API client) with commit messages and rule names that resemble routine maintenance.",
          "Rely on reviewers’ trust in green status checks; once security checks are removed, merges appear clean in PR UI and logs."
        ],
        "comments": "This vector focuses on converting hard security gates into soft or cosmetic ones so that risky merges complete without generating failing checks or blocked-merge events that would attract attention.",
        "evasion_achieved": "By weakening or removing branch and code scanning merge protection, risky changes can be merged into previously protected branches without failing checks or blocked-merge records, reducing security signal in both UI and audit data."
      },
      {
        "can_achieve": true,
        "technique_name": "Disable or Modify Cloud Logs",
        "technique_stix_id": "attack-pattern--cacc40da-4c9e-462c-80d5-fd70a178b12d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "As a repository admin or organization security manager, review **Secret scanning & push protection** settings at the repo and org level to confirm that push protection is enforced for the target repositories.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Repository Security tab – secret scanning settings",
              "Org security center – secret scanning and push protection UI"
            ],
            "related_data": [
              "Secret scanning configuration per repository",
              "Org-level security configuration for secret scanning and push protection"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Relax or disable **push protection** by changing configuration so that pushes only generate warnings, or by turning push protection off for targeted repositories (either directly or by detaching them from strict org-level configurations).",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Secret scanning/push protection UI at repo/org scope",
              "REST Secret scanning and code security configuration APIs"
            ],
            "related_data": [
              "Push protection configuration objects",
              "Repository lists attached to each configuration",
              "Audit entries for secret scanning configuration changes"
            ],
            "notes": "This mirrors cloud attackers who disable DLP/secret-detection controls before exfiltrating or committing credentials."
          },
          {
            "step_id": 3,
            "description": "If direct configuration changes are too obvious, rely on delegated **bypass** during git push: when push protection blocks a commit, respond to the CLI prompt with an allowed bypass reason (for example, asserting the secret is a false positive) to force the push through.",
            "related_capabilities": [
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Git push client interaction with push protection prompts",
              "Secret scanning push protection backend"
            ],
            "related_data": [
              "Push protection event and bypass logs",
              "Repository commit history containing newly-added secrets"
            ],
            "notes": "Bypasses are logged, but repeated use may blend in if many developers legitimately bypass for test data or non-sensitive tokens."
          },
          {
            "step_id": 4,
            "description": "After pushing secrets, use the **Secret scanning** alerts UI or REST API to quickly dismiss or downgrade any resulting alerts (for example, marking them as revoked or acceptable), ensuring dashboards and reports show little or no outstanding exposure.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Secret scanning alerts UI",
              "REST Secret scanning alerts API"
            ],
            "related_data": [
              "Secret scanning alerts and triage state",
              "Bypass/dismissal reason metadata",
              "Org and repo security dashboards"
            ],
            "notes": null
          }
        ],
        "capabilities_used": [
          "Secret Scanning & Push Protection",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "GitHub REST API",
          "Organization & Team Administration"
        ],
        "interfaces_used": [
          "Repo/Org Security tab – secret scanning & push protection configuration UI",
          "Secret scanning alerts UI",
          "REST API – secret scanning configuration and alerts",
          "Git push client-side prompts for push protection bypass"
        ],
        "data_accessed": [
          "Secret scanning configuration (enabled/disabled state, patterns, push protection behavior)",
          "Push protection bypass events and metadata",
          "Secret scanning alert objects and triage state",
          "Repository commits and file contents containing sensitive tokens"
        ],
        "preconditions_required": [
          "Attacker controls a repository administrator/maintainer or organization security-manager account that can configure secret scanning and push protection and/or dismiss alerts.",
          "Target repositories are covered by secret scanning/push protection; otherwise there is nothing to bypass.",
          "Attacker can push code to the target repository (directly or via a compromised developer workflow) from within IP allowlists and after satisfying MFA/SSO at least once."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication: The attacker must operate under an already-authenticated identity; push protection prompts themselves do not bypass MFA requirements.",
          "IP Allowlisting: git pushes and UI/API interactions must originate from allowlisted networks.",
          "Rate Limiting: Automated mass-dismissal of alerts via API must respect rate limits to avoid detection by throttling.",
          "Admin Approval/Change Control (organizational): configuration changes may be subject to out-of-band review processes even if not enforced by GitHub itself."
        ],
        "evasion_considerations": [
          "Prefer configuration changes that downgrade push protection to warnings over complete disabling, to reduce suspicion.",
          "Use bypass reasons that align with legitimate developer workflows (e.g., test credentials, non-production keys) and space out bypasses over time.",
          "Dismiss alerts selectively and gradually, focusing on the most damaging exposures first to avoid large, sudden drops in alert counts.",
          "Combine with use of app or PAT tokens so that most of the activity appears as routine automation instead of unusual manual pushes."
        ],
        "comments": "This vector focuses specifically on reducing or bypassing GitHub’s secret scanning and push protection so that secrets can be committed with minimal persistent alerting.",
        "evasion_achieved": "Secrets can be pushed into repositories and left in history while push protection is downgraded or bypassed and resulting alerts are quickly dismissed, significantly reducing visible secret-related risk indicators in security dashboards."
      },
      {
        "can_achieve": true,
        "technique_name": "Disable or Modify Cloud Logs",
        "technique_stix_id": "attack-pattern--cacc40da-4c9e-462c-80d5-fd70a178b12d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify which **repository, organization, and enterprise/global webhooks** are used to feed SIEM/monitoring systems by reviewing webhook URLs, names, and subscribed events.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Repository and organization Webhooks settings UI",
              "Enterprise global webhooks management UI",
              "REST Org webhooks API"
            ],
            "related_data": [
              "Webhook configuration metadata (URLs, secrets, event filters)",
              "Webhook delivery logs and response codes"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "As an org owner or enterprise admin, **disable or delete** key webhooks that deliver security-relevant events (e.g., pushes, pull requests, security alerts, audit-like events) to external monitoring endpoints, or narrow their event subscriptions to remove high-signal events.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Org and enterprise webhook UIs",
              "REST Org webhooks API"
            ],
            "related_data": [
              "Webhook configuration objects and event filters",
              "Audit log entries for webhook configuration changes"
            ],
            "notes": "Analogous to disabling CloudTrail/SIEM exports in cloud environments, but here at the GitHub webhook layer."
          },
          {
            "step_id": 3,
            "description": "Optionally **repoint** webhooks to attacker-controlled infrastructure or change their secrets so that legitimate receivers can no longer validate events, causing them to silently drop webhook deliveries.",
            "related_capabilities": [
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Webhook configuration UI",
              "REST Org/Repo webhooks API"
            ],
            "related_data": [
              "Webhook secrets and target URLs",
              "Delivery logs showing new endpoints and failures at the original receiver"
            ],
            "notes": "This can create a man-in-the-middle view of events for the attacker while blinding legitimate monitoring."
          },
          {
            "step_id": 4,
            "description": "If monitoring is implemented via a GitHub App, modify the **App’s webhook URL or event subscriptions** so that it no longer receives, or selectively receives, relevant events for certain orgs/repositories.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "GitHub App configuration UI",
              "GitHub Apps REST API"
            ],
            "related_data": [
              "App registration metadata (webhook URL, events)",
              "App installation records by org/repo"
            ],
            "notes": null
          },
          {
            "step_id": 5,
            "description": "Allow normal repository and security activity to continue; events will still be recorded in GitHub’s internal audit logs but will no longer reach external SIEM/SOC systems that depend solely on webhooks.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Security & Audit Logs"
            ],
            "related_interfaces": [
              "Standard GitHub UI and APIs for daily operations",
              "Webhook delivery dashboards (to observe failure patterns)"
            ],
            "related_data": [
              "Ongoing event payloads that are now undelivered or redirected",
              "Org/enterprise audit logs showing only a small number of configuration changes"
            ],
            "notes": "Real attacks against SaaS often rely on this pattern: disable or misconfigure export of logs while leaving core functionality untouched."
          }
        ],
        "capabilities_used": [
          "Webhook Event Delivery",
          "GitHub Apps & OAuth Apps Platform",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organization & Team Administration",
          "GitHub REST API",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "Repository Webhooks settings UI",
          "Organization Webhooks settings UI",
          "Enterprise global webhooks management UI",
          "REST API – org webhooks and related webhook endpoints",
          "GitHub App configuration UI and APIs"
        ],
        "data_accessed": [
          "Webhook configuration (scope, event types, target URLs, secrets)",
          "Webhook delivery logs, response codes, and redelivery metadata",
          "App registration metadata for GitHub Apps used as monitoring integrations",
          "Organization and enterprise audit logs recording webhook configuration changes"
        ],
        "preconditions_required": [
          "Attacker controls an organization owner or enterprise administrator account (or equivalent app/token) with rights to manage webhooks and apps.",
          "External monitoring relies heavily on GitHub webhooks or app webhooks rather than direct log export or continuous audit-log polling.",
          "Attacker can authenticate via SSO/MFA and operate from allowlisted IPs."
        ],
        "constraints_encountered": [
          "MFA Required / SSO-Only Authentication: Administrative changes to org/global webhooks may require strong auth; attacker must already control such an account.",
          "IP Allowlisting: Webhook configuration changes must come from allowed networks.",
          "Rate Limiting: Frequent programmatic changes via REST must be rate-aware, but webhook management is relatively low volume.",
          "Potential out-of-band monitoring: Some environments may independently monitor webhook health; failures could be noticed."
        ],
        "evasion_considerations": [
          "Quietly narrow event subscriptions instead of deleting webhooks outright so that integrations still receive some traffic and appear healthy.",
          "Stagger changes across organizations and repositories to mimic routine maintenance rather than a single, large reconfiguration.",
          "If repointing webhooks, forward a subset of low-sensitivity events to the original destination to maintain the illusion of normal operation.",
          "Leverage known webhook failure modes (e.g., persistent 5xx from endpoints) to mask intentional misconfiguration as integration instability."
        ],
        "comments": "This vector specifically targets the pipeline between GitHub and external monitoring systems by abusing legitimate webhook and app configuration surfaces.",
        "evasion_achieved": "External SIEMs and monitoring platforms are partially or completely blinded to GitHub activity because critical events are no longer delivered or are selectively filtered, while internal GitHub operations and limited audit logs remain intact."
      },
      {
        "can_achieve": true,
        "technique_name": "Disable or Modify Cloud Logs",
        "technique_stix_id": "attack-pattern--cacc40da-4c9e-462c-80d5-fd70a178b12d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "From a compromised security-manager or admin account, enumerate existing **code scanning, secret scanning, and Dependabot alerts** via the repository/organization Security UI or REST APIs.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "Secret Scanning & Push Protection",
              "Dependency & Supply Chain Management with Dependabot"
            ],
            "related_interfaces": [
              "Security tab – code scanning alerts UI",
              "Security tab – secret scanning alerts UI",
              "Security tab – Dependabot alerts UI",
              "REST Code scanning, Secret scanning, and Dependabot alerts APIs"
            ],
            "related_data": [
              "Current open security alerts and their metadata",
              "Historical alerts and triage states"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Use the UI or APIs to **bulk-dismiss** alerts, supplying benign-sounding reasons (e.g., false positive, won’t fix, acceptable risk) so that dashboards show dramatically fewer outstanding issues.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "Secret Scanning & Push Protection",
              "Dependency & Supply Chain Management with Dependabot",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Security UIs for each alert type",
              "REST alerts APIs for batch updates"
            ],
            "related_data": [
              "Alert state and dismissal reason fields",
              "Org and repo security dashboards"
            ],
            "notes": "Many real intrusions leverage large-scale dismissal/ignore operations to hide signals without turning tools off."
          },
          {
            "step_id": 3,
            "description": "Reconfigure **auto-triage and auto-dismissal** rules (especially for Dependabot) so that future alerts matching attacker-relevant patterns (e.g., specific libraries or severities) are automatically ignored or marked as low priority.",
            "related_capabilities": [
              "Dependency & Supply Chain Management with Dependabot",
              "Automated Dependency & Security Remediation Jobs",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns"
            ],
            "related_interfaces": [
              "Org/Repo Dependabot configuration UIs",
              "Dependabot configuration files and settings"
            ],
            "related_data": [
              "Dependabot alert and rule configuration",
              "Auto-dismissal/ignore rule definitions"
            ],
            "notes": null
          },
          {
            "step_id": 4,
            "description": "Adjust **org-level security configurations** to exclude certain repositories from security tooling entirely, ensuring that future alerts for those repos are never generated.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Code Scanning for Static Application Security Testing",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Org security center UI – configuring coverage",
              "REST Code security configurations API"
            ],
            "related_data": [
              "Assignments of repositories to security configurations",
              "Coverage reports and risk assessments"
            ],
            "notes": null
          },
          {
            "step_id": 5,
            "description": "Optionally automate ongoing suppression by running a periodic **GitHub Actions workflow or GitHub App** that reviews new alerts via the REST API and dismisses those matching attacker-chosen criteria.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions workflows (.github/workflows) using REST calls",
              "GitHub App backend calling REST security endpoints"
            ],
            "related_data": [
              "Workflow logs showing automated triage events",
              "REST call metadata for alert updates"
            ],
            "notes": "This turns suppression into a continuous background process, analogous to custom tooling that auto-suppresses cloud security alerts."
          }
        ],
        "capabilities_used": [
          "Code Scanning for Static Application Security Testing",
          "Secret Scanning & Push Protection",
          "Dependency & Supply Chain Management with Dependabot",
          "Automated Dependency & Security Remediation Jobs",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform"
        ],
        "interfaces_used": [
          "Repository/Org Security tab – code scanning, secret scanning, Dependabot views",
          "REST APIs – code scanning alerts, secret scanning alerts, Dependabot alerts",
          "Org “Securing your organization” security center",
          "Actions workflow definitions and run UI",
          "GitHub App webhook and backend APIs"
        ],
        "data_accessed": [
          "Current and historical security alerts (code scanning, secret scanning, Dependabot)",
          "Alert triage states and dismissal reasons",
          "Auto-triage and auto-dismissal rules for alerts",
          "Assignments of repositories to security configurations",
          "Workflow run metadata and logs from automated suppression jobs"
        ],
        "preconditions_required": [
          "Attacker controls an account or app with permissions to read and update security alerts and to edit security configurations (e.g., org security manager or repo admin with Advanced Security access).",
          "Security features are enabled for at least some repositories so that alerts exist and can be dismissed or suppressed.",
          "Attacker can operate within MFA, SSO-only, and IP-allowlisting constraints using compromised credentials, sessions, or tokens."
        ],
        "constraints_encountered": [
          "MFA Required / SSO-Only Authentication: Access to Security UIs and APIs requires SSO-backed accounts; automation typically uses tokens obtained after such authentication.",
          "Rate Limiting: Bulk API operations for dismissing large numbers of alerts must be paced.",
          "Potential governance processes: Some organizations may review unusual spikes in dismissed alerts out-of-band."
        ],
        "evasion_considerations": [
          "Hide behind legitimate-sounding dismissal reasons and distribute dismissals over time to avoid sudden, obvious drops in alert counts.",
          "Target only alerts tied to attacker-relevant code paths or dependencies, leaving benign alerts open to maintain the perception of active security posture.",
          "Run automated suppression jobs at low frequency and outside peak hours to blend with routine maintenance.",
          "Combine with downgrading of security configurations so that new alerts are less likely to be generated in the first place."
        ],
        "comments": "Rather than disabling tools, this vector erases or de-prioritizes their output so that dashboards and reports understate real risk.",
        "evasion_achieved": "Security dashboards, risk reports, and alert queues show few or no outstanding issues for targeted repositories, masking vulnerabilities or leaked secrets that remain present in code and history."
      },
      {
        "can_achieve": true,
        "technique_name": "Application Access Token",
        "technique_stix_id": "attack-pattern--f005e783-57d4-4837-88ad-dbe7faee1c51",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised developer or admin account that has passed SSO and MFA, register a new **GitHub App** or OAuth app with a name and description that fit existing tooling (e.g., “CI Sync Bot” or “DevOps Helper”).",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "GitHub Apps creation UI",
              "Apps platform documentation and configuration pages"
            ],
            "related_data": [
              "App registration metadata (name, description, permissions, webhook URL)",
              "Account security logs showing app creation"
            ],
            "notes": "Real campaigns (e.g., APT28’s malicious OAuth apps) use innocuous names to avoid scrutiny."
          },
          {
            "step_id": 2,
            "description": "Request **fine-grained permissions** sufficient for planned malicious operations (e.g., read/write repository contents, workflows, issues) while avoiding overly broad scopes that might trigger review.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "App permission configuration UI",
              "REST Apps APIs (for verification)"
            ],
            "related_data": [
              "Declared app permissions per resource type",
              "Installation scope (repositories, organizations)"
            ],
            "notes": null
          },
          {
            "step_id": 3,
            "description": "As an org owner or repo admin, **install the app** on selected repositories or the entire organization, granting access only where needed to reduce the visible blast radius.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Organization Apps settings UI",
              "Repository Apps settings UI"
            ],
            "related_data": [
              "App installation records and target repositories",
              "Org audit logs for app installations"
            ],
            "notes": null
          },
          {
            "step_id": 4,
            "description": "From attacker-controlled infrastructure (preferably within allowlisted IP ranges), obtain **installation access tokens** for the app and call GitHub’s REST API to perform operations (e.g., modifying workflows, merging PRs, or changing repo settings) under the app identity.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "REST Apps API – create installation tokens",
              "General REST API – repos, pulls, actions, security endpoints"
            ],
            "related_data": [
              "Short-lived app installation tokens",
              "REST request and response metadata for app-scoped actions"
            ],
            "notes": "This mirrors tooling like Peirates and real intrusions where OAuth/service principals are used for stealthy, long-lived access."
          },
          {
            "step_id": 5,
            "description": "Optionally configure **webhooks** for the app so that it reacts to events (e.g., push, pull_request, workflow_run) and automatically performs follow-up actions, further embedding malicious changes in what appears to be normal automation.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "App webhook configuration UI",
              "GitHub App webhook delivery APIs"
            ],
            "related_data": [
              "App webhook payloads and logs",
              "Automation logic in the app backend"
            ],
            "notes": null
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Webhook Event Delivery",
          "Organization & Team Administration",
          "Authentication & Account Security Management",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "GitHub Apps registration and configuration UI",
          "Organization/Repository Apps installation UIs",
          "REST API – GitHub Apps and general resource endpoints",
          "GitHub App webhook configuration and delivery endpoints"
        ],
        "data_accessed": [
          "App registration metadata and permissions",
          "App installation records and scopes",
          "App and installation access tokens",
          "Repository contents, workflows, and settings modified via app tokens",
          "Audit logs attributing actions to the app identity"
        ],
        "preconditions_required": [
          "Attacker has compromised a user account with rights to create and install GitHub Apps or OAuth apps within the target organization.",
          "The environment permits GitHub Apps/OAuth apps (they have not been globally disabled by enterprise policy).",
          "Attacker can operate from within IP allowlists and has satisfied SSO/MFA at least once to configure the app."
        ],
        "constraints_encountered": [
          "MFA Required / SSO-Only Authentication: App registration and installation actions require strong authentication; the attacker relies on a compromised account to perform them.",
          "IP Allowlisting: App management and API usage must originate from allowlisted networks (or via compromised infrastructure inside those networks).",
          "Admin Approval Required (organizational policy): Some environments require manual review of new apps; the attacker must choose benign-looking names and scopes to avoid rejection.",
          "Rate Limiting: High-volume API activity under the app token must be rate-aware."
        ],
        "evasion_considerations": [
          "Select app names, icons, and descriptions consistent with existing tooling (e.g., matching vendor naming) so that appearances in audit logs and settings pages do not raise suspicion.",
          "Use minimal necessary permissions and scope installations to a limited set of repositories to avoid standing out.",
          "Schedule or trigger app actions based on normal events (push, PR open) so that activity patterns align with typical development workflows.",
          "Use app tokens instead of repeated user logins, reducing sign-in/audit noise tied to human accounts while maintaining full API-level control."
        ],
        "comments": "This vector uses GitHub’s first-class app model to shift activity from human identities to an integration identity, echoing OAuth-token abuse seen in major SaaS intrusions.",
        "evasion_achieved": "Most malicious operations appear as actions performed by a legitimate-looking GitHub App rather than by a user, reducing suspicious user login activity and blending attacker behavior into normal integration traffic and automation logs."
      },
      {
        "can_achieve": true,
        "technique_name": "Application Access Token",
        "technique_stix_id": "attack-pattern--f005e783-57d4-4837-88ad-dbe7faee1c51",
        "method_steps": [
          {
            "step_id": 1,
            "description": "After compromising a developer or admin account (for example via phishing or stolen cookie), access **Account security settings** and create one or more **personal access tokens (PATs) or fine-grained tokens** with scopes limited to the target organizations and repositories.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "User security settings UI – tokens",
              "REST Authentication API (for token management where available)"
            ],
            "related_data": [
              "Token metadata (scopes, expiration)",
              "Account security logs capturing token creation"
            ],
            "notes": "Creation typically requires MFA/sudo but results in credentials that can be used non-interactively thereafter."
          },
          {
            "step_id": 2,
            "description": "Store the tokens on attacker-controlled infrastructure that resides on or tunnels through **allowlisted IP ranges**, and use them to perform Git and REST operations (e.g., cloning, pushing, modifying workflows, or reading security data) without additional interactive logins.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "REST API endpoints – repos, pulls, security, admin as allowed by scopes",
              "Git over HTTPS authenticated with PAT"
            ],
            "related_data": [
              "REST request metadata associated with the token",
              "Repository code and metadata accessed or modified by token"
            ],
            "notes": "Like service principals in cloud campaigns, these tokens act as long-lived alternate auth material."
          },
          {
            "step_id": 3,
            "description": "Where possible, script operations using **GitHub CLI or custom API clients** so that behavior resembles automated tooling (e.g., periodic syncs, workflow updates) rather than ad-hoc manual actions.",
            "related_capabilities": [
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "REST API clients (e.g., Octokit, GitHub CLI)"
            ],
            "related_data": [
              "Automation scripts and logs on attacker infrastructure",
              "API rate-limit and usage patterns"
            ],
            "notes": null
          },
          {
            "step_id": 4,
            "description": "Avoid logging into the web UI with the compromised user wherever possible; rely primarily on tokens so that **new web sessions and MFA events are minimized**, concentrating evidence into less-monitored token-usage logs.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "API-only usage; minimal browser sessions"
            ],
            "related_data": [
              "Account security logs (few new interactive logins)",
              "REST/audit logs showing token use instead of repeated sign-ins"
            ],
            "notes": "This aligns with real-world use of OAuth/API tokens in SaaS to bypass MFA and reduce conspicuous login events."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Repository Management & Source Code Hosting",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "User account security settings – tokens management UI",
          "REST Authentication API",
          "REST API – general resource endpoints",
          "Git over HTTPS using PATs or fine-grained tokens"
        ],
        "data_accessed": [
          "Token credentials and metadata",
          "Repository contents and settings accessed via tokens",
          "Security alerts and configuration data accessed via API",
          "Account security and audit logs recording token creation and usage"
        ],
        "preconditions_required": [
          "Attacker has already compromised a user account with rights to create tokens (and not restricted by enterprise policy forbidding PATs).",
          "Attacker can complete at least one MFA/SSO challenge or hijack an existing session to access token-management settings.",
          "Attacker can execute API and Git operations from allowlisted IP addresses."
        ],
        "constraints_encountered": [
          "MFA Required / SSO-Only Authentication: Token creation itself enforces MFA; this must be satisfied once, but subsequent token usage generally does not.",
          "IP Allowlisting: API calls using tokens must originate from permitted IP ranges.",
          "Rate Limiting: Automated token-based operations must respect REST/Git rate limits.",
          "Enterprise policies may restrict PAT creation or require fine-grained tokens only, which the attacker must adapt to."
        ],
        "evasion_considerations": [
          "Use fine-grained, short-lived tokens that match organizational best practices, making them less suspicious.",
          "Name tokens and scripts in line with existing automation (e.g., “build-bot”, “ci-sync”) so token activity appears expected.",
          "Distribute operations across multiple tokens and time windows to avoid abnormal rate spikes.",
          "Avoid unnecessary changes in account security settings (e.g., frequent token revocations) that might draw attention."
        ],
        "comments": "This vector leverages PATs and fine-grained tokens as alternate authentication material to minimize visible interactive login activity and MFA prompts.",
        "evasion_achieved": "Malicious activity is carried out largely via API and Git operations authenticated with application-style tokens, significantly reducing the number of new interactive logins and MFA challenges that defenders may monitor for anomalies."
      },
      {
        "can_achieve": true,
        "technique_name": "Disable or Modify Cloud Logs",
        "technique_stix_id": "attack-pattern--cacc40da-4c9e-462c-80d5-fd70a178b12d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "As a maintainer or admin on a repository, create or modify a **GitHub Actions workflow** in .github/workflows that encapsulates malicious or sensitive activity (e.g., large-scale data access or transformation) inside jobs labeled as routine CI/CD (e.g., “build”, “test”).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Repository code editor for workflow YAML",
              "Actions workflow syntax and concepts docs"
            ],
            "related_data": [
              "Workflow definitions (jobs, steps, triggers)",
              "Repository code and configuration under automation"
            ],
            "notes": "The goal is to hide high-impact steps among legitimate-looking CI tasks rather than to delete logs outright."
          },
          {
            "step_id": 2,
            "description": "Configure workflows to run on **common events** (e.g., push to main, scheduled nightly runs) so that executions coincide with normal development activity and do not stand out in the Actions run history.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Workflow triggers in YAML (on: push, schedule, workflow_dispatch)",
              "Actions run history UI"
            ],
            "related_data": [
              "Workflow run metadata (timestamps, triggering events)",
              "Job execution logs"
            ],
            "notes": null
          },
          {
            "step_id": 3,
            "description": "Use **GITHUB_TOKEN** and repository/organization secrets within the workflow to access internal resources and external endpoints, ensuring that the most sensitive operations occur on Actions runners (GitHub-hosted or self-hosted) rather than from the attacker’s own IP addresses.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Actions runtime on GitHub-hosted or self-hosted runners",
              "Secrets management UI for Actions"
            ],
            "related_data": [
              "Workflow logs and artifacts containing execution traces",
              "Secrets and tokens available to workflows",
              "Actions Artifacts & Logs Storage records"
            ],
            "notes": "This shifts activity into an environment whose low-level OS/network logs are outside GitHub’s SaaS audit surface."
          },
          {
            "step_id": 4,
            "description": "Minimize explicit logging of sensitive operations inside the workflow (e.g., redirect command output to temporary files, avoid echoing secrets, keep logs terse) so that **Actions logs contain only high-level success messages**.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Actions Artifacts & Logs Storage"
            ],
            "related_interfaces": [
              "Step scripts within workflow jobs",
              "Actions logs viewer"
            ],
            "related_data": [
              "Step-level logs and artifacts",
              "Any temporary files created during jobs"
            ],
            "notes": "Defenders may see that a job ran, but not detailed evidence of what it accessed or transmitted."
          },
          {
            "step_id": 5,
            "description": "Optionally run workflows on **self-hosted runners** controlled by the attacker or a compromised on-prem system so that host-level logs and network telemetry are outside GitHub’s visibility and may not be centrally monitored.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Organizations & Enterprise Admin Service (runner policies)"
            ],
            "related_interfaces": [
              "Runner registration and management UI/APIs",
              "Self-hosted runner configuration on attacker-controlled machines"
            ],
            "related_data": [
              "Runner registration tokens and labels",
              "Local system/network logs on self-hosted runners (outside GitHub)",
              "Limited runner metadata recorded in GitHub"
            ],
            "notes": "This pattern mirrors resource abuse in cloud CI platforms where the provider logs job metadata but not deep host telemetry accessible to customers."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Actions & Workflow Service",
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "Workflow YAML files in .github/workflows",
          "Actions run history and logs UI",
          "REST API – Actions workflows and workflow-runs",
          "Runner management UIs/APIs for self-hosted runners",
          "Secrets management UI for Actions"
        ],
        "data_accessed": [
          "Workflow definitions, secrets, and environment variables",
          "Actions job logs and artifacts stored in Actions Artifacts & Logs Storage",
          "Runner registration tokens and configuration metadata",
          "Org and repo audit logs referencing workflow and runner configuration changes"
        ],
        "preconditions_required": [
          "Attacker has write/admin access to a repository that permits Actions workflows and, if needed, to configure self-hosted runners.",
          "Actions are enabled for the organization/repository under enterprise/org policies.",
          "Attacker can authenticate through SSO/MFA and operate from within IP allowlists."
        ],
        "constraints_encountered": [
          "Billing & Usage Management (noted indirectly): Excessive Actions usage may trigger budget alerts; attacker must stay within expected usage patterns.",
          "Rate Limiting: REST APIs used to manage workflows or retrieve outputs are rate-limited.",
          "MFA Required / SSO-Only Authentication: Initial configuration of workflows and runners requires authenticated access but workflow runs themselves do not.",
          "IP Allowlisting: Management actions (not job execution on GitHub-hosted runners) must originate from allowed IP ranges."
        ],
        "evasion_considerations": [
          "Name workflows and jobs to match existing CI/CD patterns (e.g., “integration-tests”) and avoid unusual schedules or runner labels.",
          "Blend malicious steps with legitimate ones and keep job durations within normal ranges for the project.",
          "Use self-hosted runners located where defenders have limited or no telemetry, ensuring that only high-level job status is visible in GitHub.",
          "Use minimal logging inside jobs and rely on external destinations for any detailed telemetry the attacker needs."
        ],
        "comments": "This vector does not remove logs but makes investigative traces shallow and pushes sensitive operations into runner environments and external systems where central defenders may lack visibility.",
        "evasion_achieved": "Suspicious or sensitive operations run inside apparently normal Actions workflows and on runners (potentially self-hosted) where only coarse-grained job metadata is visible to GitHub and central defenders, making it harder to reconstruct exactly what was executed."
      },
      {
        "can_achieve": true,
        "technique_name": "Masquerade Account Name",
        "technique_stix_id": "attack-pattern--d349c66e-18e1-4d43-abc7-318e81a73d65",
        "method_steps": [
          {
            "step_id": 1,
            "description": "When registering a **GitHub App** or OAuth app for malicious use, choose a name, logo, and description that closely resemble existing trusted tooling (e.g., “GitHub Actions Helper”, “CI Sync Prod”) used by the organization.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "GitHub Apps registration UI"
            ],
            "related_data": [
              "App registration metadata (name, icon, description)"
            ],
            "notes": "Real adversaries (e.g., Storm-1811 spoofing IT helpdesk) use similarly named accounts to appear legitimate."
          },
          {
            "step_id": 2,
            "description": "Install the masquerading app on target repositories or the organization, ensuring that installation prompts and subsequent audit entries refer to the benign-looking name.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Org/Repo app installation UIs"
            ],
            "related_data": [
              "App installation records",
              "Org audit logs referencing the app name"
            ],
            "notes": null
          },
          {
            "step_id": 3,
            "description": "Use the app’s tokens to perform configuration and content changes (e.g., adjusting workflows, security settings) so that audit logs and commit attributions record the **masquerading app name** as the actor.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "REST APIs called with app tokens",
              "Commit and configuration UIs showing app-based changes"
            ],
            "related_data": [
              "REST/audit records listing the app as the actor",
              "Repository commit metadata attributed to the app"
            ],
            "notes": "Defenders scanning logs by actor name may mistake it for a known integration."
          },
          {
            "step_id": 4,
            "description": "Optionally create or rename **teams, projects, or repositories** with generic support or tooling names (e.g., “build-tools”, “infra-support”), then use those as staging areas for further misconfiguration while keeping nomenclature consistent with existing patterns.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Project Planning & Reporting with GitHub Projects",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Organization settings – teams and repositories UI",
              "Projects configuration UI"
            ],
            "related_data": [
              "Team and repository names and metadata",
              "Org audit logs for team/repo creation/rename"
            ],
            "notes": null
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Project Planning & Reporting with GitHub Projects",
          "GitHub REST API",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "GitHub Apps registration and configuration UI",
          "Org/Repo app installation UIs",
          "Organization settings for teams and repositories",
          "Projects configuration UI",
          "REST API – GitHub Apps and org/repo management"
        ],
        "data_accessed": [
          "App registration records (names, icons, descriptions)",
          "App installation scopes and permissions",
          "Team, project, and repository metadata (names, visibility, membership)",
          "Audit logs listing actions under app/team/repo names"
        ],
        "preconditions_required": [
          "Attacker can create and install GitHub Apps/OAuth apps or create/rename teams/repos within the target organization.",
          "Defenders rely heavily on actor names and surface appearances rather than strict permission reviews.",
          "Attacker can authenticate through SSO/MFA and operate within IP allowlists."
        ],
        "constraints_encountered": [
          "Admin Approval Required (for apps/integrations): New apps may need explicit admin approval; disguising names helps but does not remove this gate.",
          "MFA Required / SSO-Only Authentication: Creation/installation actions are tied to a compromised high-privilege account.",
          "Rate Limiting: Minimal impact because configuration actions are low-volume."
        ],
        "evasion_considerations": [
          "Clone naming conventions, icons, and descriptions from existing legitimate integrations to minimize perceived differences.",
          "Avoid using obviously generic or suspicious names like “admin” or “root”; instead, stay consistent with internal tooling brands.",
          "Make incremental changes over time under the masquerading identity to avoid single large, suspicious bursts of activity.",
          "Ensure permissions requested by the app align with its purported function (e.g., CI helper should primarily need repo/workflow scopes)."
        ],
        "comments": "This vector primarily targets human detection and triage by making malicious identities look indistinguishable from legitimate service and support accounts.",
        "evasion_achieved": "Malicious actions and configuration changes are attributed in logs and UI to accounts and apps that visually and linguistically resemble legitimate tooling or support identities, reducing the chance that defenders question their presence or activity."
      },
      {
        "can_achieve": true,
        "technique_name": "Web Session Cookie",
        "technique_stix_id": "attack-pattern--c3c8c916-2f3c-4e71-94b2-240bdfc996f0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain a victim’s valid **GitHub.com session cookie** for the target enterprise/org account (for example, via phishing proxy, malware on the victim workstation, or browser theft in another layer of the attack).",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Identity & Authentication Service"
            ],
            "related_interfaces": [
              "User web session management (implicit in Authentication docs)"
            ],
            "related_data": [
              "Active web session cookies/tokens linked to the user account"
            ],
            "notes": "This step occurs outside GitHub’s documented features but leverages the fact that authenticated sessions exist and are long-lived."
          },
          {
            "step_id": 2,
            "description": "Replay/import the stolen cookie into a browser on infrastructure that either matches the victim’s **allowlisted IP environment** (e.g., through a compromised VPN/VDI) or remotely accesses the victim’s machine, so that IP allowlisting and device checks are satisfied.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Browser session handling; GitHub web UI"
            ],
            "related_data": [
              "Session metadata (IP, user agent, device fingerprints) recorded in security logs"
            ],
            "notes": "Mirrors attacks where APT29/Star Blizzard reused cookies to bypass MFA and conditional access."
          },
          {
            "step_id": 3,
            "description": "Operate within the web UI as the victim account to perform administrative tasks (e.g., installing apps, creating tokens, changing security configurations) **without triggering fresh MFA or SSO challenges**, as long as the session remains valid.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Org/Enterprise settings UIs",
              "GitHub Apps and Security configuration UIs"
            ],
            "related_data": [
              "Org and enterprise audit logs reflecting actions under the victim user identity",
              "Security logs showing session reuse but not new logins"
            ],
            "notes": null
          },
          {
            "step_id": 4,
            "description": "Use the web session to **bootstrap more durable access**, such as creating GitHub Apps, PATs, or deploying Actions workflows, then pivot to those alternate credentials for ongoing activity.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "App registration UI",
              "Token management UI",
              "Repo workflow editor"
            ],
            "related_data": [
              "New tokens and app registrations tied to the victim account",
              "Audit entries for these creations"
            ],
            "notes": "This is consistent with real-world campaigns that use stolen cookies to register new MFA methods or service principals."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "GitHub Apps & OAuth Apps Platform",
          "Security & Audit Logs"
        ],
        "interfaces_used": [
          "Web UI session authenticated via existing session cookie",
          "Org and Enterprise settings UIs",
          "Token and app management UIs",
          "Security configuration UIs"
        ],
        "data_accessed": [
          "Existing authenticated session tokens/cookies",
          "Organization and enterprise configuration data",
          "Token and app registration metadata",
          "Account security logs indicating session reuse and any device/IP anomalies",
          "Organization and enterprise audit logs of admin actions"
        ],
        "preconditions_required": [
          "Attacker can steal a valid GitHub web session cookie for a user with sufficient rights (e.g., org owner or security manager).",
          "The cookie remains valid and is not invalidated by logout, device loss, or security operations.",
          "Attacker can present network and device characteristics consistent with IP allowlisting and session-verification policies (e.g., through remote access to victim host or VPN)."
        ],
        "constraints_encountered": [
          "MFA Required / SSO-Only Authentication: MFA and SSO are enforced at session creation; stolen cookies bypass repeated prompts but do not prevent eventual expiration or revocation.",
          "IP Allowlisting: Session replay from unknown IP ranges may be blocked or trigger re-auth; attacker must route traffic through approved networks.",
          "Rate Limiting: UI-driven/admin actions are low volume and unlikely to hit rate limits.",
          "Session/device verification: Security logs may record unusual device/IP changes; sustained misuse may still trigger investigation."
        ],
        "evasion_considerations": [
          "Use the hijacked session sparingly and at times consistent with the victim’s normal working hours to avoid behavioral anomalies.",
          "Keep actions small and incremental (e.g., creating a single new app or token) and pivot quickly to alternate credentials for noisy operations.",
          "Where possible, operate from the victim’s own workstation or VDI to perfectly match device/IP fingerprints.",
          "Avoid changing the victim’s personal profile settings or obvious UI preferences that might alert them."
        ],
        "comments": "This vector is primarily about reducing new authentication traces and MFA challenges by piggybacking on existing authenticated sessions.",
        "evasion_achieved": "Attacker performs high-impact administrative actions under an already-authenticated session, avoiding new login and MFA events that might otherwise flag anomalous access while retaining legitimate-looking attribution to the victim account."
      },
      {
        "can_achieve": false,
        "technique_name": "Multi-Factor Authentication",
        "technique_stix_id": "attack-pattern--b4409cd8-0da9-46e1-a401-a241afd4d1cc",
        "method_steps": [],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "User security settings – MFA configuration UI",
          "Org/Enterprise security settings – 2FA enforcement UI"
        ],
        "data_accessed": [
          "User MFA configuration (registered devices, recovery codes)",
          "Org/enterprise 2FA enforcement policies"
        ],
        "preconditions_required": [
          "Attacker would need control over both GitHub Enterprise IAM settings and the external IdP enforcing SSO/MFA.",
          "Environment explicitly mandates MFA for all accounts and SSO-only authentication, leaving no documented path in GitHub to globally disable MFA without violating external policy."
        ],
        "constraints_encountered": [
          "MFA Required: Environment states MFA is mandatory for all user accounts; GitHub’s documented controls only allow enabling or enforcing MFA, not silently disabling it in an SSO-only setup.",
          "SSO-Only Authentication: Authentication flows are controlled by the external IdP; GitHub does not expose tooling to patch or bypass the IdP’s MFA enforcement from within GitHub.",
          "Admin Approval / Governance: Any attempt to relax MFA enforcement at the org/enterprise layer would likely conflict with corporate policy and be highly scrutinized."
        ],
        "evasion_considerations": [
          "Instead of trying to disable MFA, realistic attackers will rely on alternate authentication material (session cookies, PATs, app tokens) and valid accounts to bypass repeated MFA prompts, as covered in other vectors.",
          "Modifying MFA behavior at the IdP layer (e.g., via tools like AADInternals) is out of scope for GitHub-specific capabilities and would require separate compromise of identity infrastructure."
        ],
        "comments": "Given the stated environment constraints (MFA Required and SSO-Only Authentication) and GitHub’s documented capabilities, there is no realistic way for an attacker to silently disable or weaken MFA **from within GitHub itself**. MFA bypass would need to occur via external IdP compromise or stealing alternate authentication material, which are covered by other techniques.",
        "evasion_achieved": "Not achievable with GitHub’s documented admin and security features in an environment where MFA and SSO are strictly enforced externally."
      }
    ],
    "summary": "Within GitHub’s documented capabilities, an attacker with compromised high-privilege identities can realistically evade or impair defenses mainly by (1) downgrading or misconfiguring security tooling (code scanning, secret scanning, Dependabot, branch/merge protections), (2) blinding or misdirecting external monitoring via webhook and global webhook changes, and (3) operating under alternate identities and credentials (GitHub Apps, OAuth apps, PATs, and stolen web session cookies) to reduce suspicious login events and blend activity into routine automation. GitHub Actions and self-hosted runners further allow attackers to shift sensitive operations into environments with limited central telemetry. Direct disabling of MFA within GitHub is not feasible under the stated SSO/MFA constraints; instead, realistic evasion relies on session and token abuse plus configuration and logging impairments aligned with MITRE’s Disable or Modify Cloud Logs and Application Access Token techniques."
  },
  "credential_access": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Unsecured Credentials",
        "technique_stix_id": "attack-pattern--435dfb86-2697-4867-85b5-2fef496c0517",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain or use an identity (user account, PAT, or GitHub App token) that has at least read access to the target organization’s repositories, or rely on unauthenticated access for public repositories.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "User account security settings UI – https://docs.github.com/en/authentication",
              "Organization settings and member management UI – https://docs.github.com/en/organizations",
              "General REST API authentication model – https://docs.github.com/en/rest/authentication"
            ],
            "related_data": [
              "User identities and account metadata",
              "Personal access tokens and GitHub App tokens",
              "Organization membership and repository access policies"
            ],
            "notes": "For private enterprise repos, this identity must satisfy MFA and SSO requirements and originate from allowlisted IP ranges, per environment constraints."
          },
          {
            "step_id": 2,
            "description": "Enumerate all repositories accessible to the compromised identity and prioritize high-value or likely mismanaged projects (e.g., internal tools, infrastructure, legacy or archived repos).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository list and settings UI – https://docs.github.com/en/repositories",
              "REST API for listing repositories – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Repositories and repository metadata",
              "Repository visibility and collaborator permissions"
            ],
            "notes": "Public repositories can be enumerated anonymously; private repositories require the previously obtained identity."
          },
          {
            "step_id": 3,
            "description": "For each target repository, retrieve full contents and history (via git clone/fetch or the REST API) to access all files, configuration, and historical commits where secrets may have been committed and later removed.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Git operations via HTTPS/SSH remotes and Git CLI – https://docs.github.com/en/get-started/git-basics/set-up-git",
              "Repository content and archive download via REST – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Files, blobs, and trees in Git repositories",
              "Commits, branches, and tags",
              "Git Repository Storage"
            ],
            "notes": "Full-history access allows recovery of secrets that have been removed from HEAD but still exist in history."
          },
          {
            "step_id": 4,
            "description": "Scan repository contents and history for credential patterns (API keys, access tokens, passwords, private keys, cloud credentials) using offline tooling or custom scripts.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Secret Scanning & Push Protection",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Local cloned repositories accessed via Git CLI",
              "(Optional) Secret-scanning-like pattern sets inferred from – https://docs.github.com/en/code-security/secret-scanning"
            ],
            "related_data": [
              "Source code and configuration files",
              "Environment files, YAML/JSON configs, and CI/CD configuration committed to the repo",
              "Detected secret tokens and metadata (conceptually similar to what GitHub secret scanning finds)"
            ],
            "notes": "This mirrors how secret-scanning tools operate (as in MITRE examples of searching templates and configuration for secrets) but is performed by the attacker against the cloned data."
          },
          {
            "step_id": 5,
            "description": "Optionally pull and inspect build artifacts such as container images or packages hosted in GitHub Packages that are linked to the repositories, scanning them for embedded credentials (e.g., registry passwords, service account keys).",
            "related_capabilities": [
              "Package Management with GitHub Packages",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub Packages UI – https://docs.github.com/en/packages",
              "REST API for packages – https://docs.github.com/en/rest/packages/packages"
            ],
            "related_data": [
              "Packages and versions across supported ecosystems",
              "Container images and package contents retrieved by ecosystem-native tooling"
            ],
            "notes": "Attackers use ecosystem-native tooling (npm, Docker, etc.) to download artifacts and then scan them locally for credentials."
          },
          {
            "step_id": 6,
            "description": "Aggregate discovered credentials (including file path, commit hash, and repository) to stage for follow-on use or further validation.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Local tooling or scripts using data retrieved from Git and the REST API"
            ],
            "related_data": [
              "Extracted API keys and tokens",
              "Associated repository and commit metadata"
            ],
            "notes": "As with real-world campaigns cited in MITRE, the attacker focuses on harvesting and organizing discovered hard-coded credentials for later operations."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "Package Management with GitHub Packages",
          "Secret Scanning & Push Protection"
        ],
        "interfaces_used": [
          "Repository web UI (Code tab, history, file views) – https://docs.github.com/en/repositories",
          "Git operations via HTTPS/SSH remotes and Git CLI – https://docs.github.com/en/get-started/git-basics/set-up-git",
          "REST API for repositories (/repos) – https://docs.github.com/en/rest/repos/repos",
          "GitHub Packages registry interfaces – https://docs.github.com/en/packages"
        ],
        "data_accessed": [
          "Files, blobs, and trees in Git repositories",
          "Commits, branches, and tags",
          "Repository visibility and collaborator permissions",
          "Package contents and metadata in GitHub Packages"
        ],
        "preconditions_required": [
          "For private repositories, attacker must control a GitHub user, personal access token, or GitHub App installation with at least read access to the target repositories.",
          "That identity must already satisfy MFA Required and SSO-Only Authentication constraints and originate from an IP range allowed by IP Allowlisting.",
          "For public repositories, no authentication is required; environment constraints on MFA, SSO, and IP allowlisting generally do not apply.",
          "To scan package contents, attacker needs permission to pull packages from the relevant registries."
        ],
        "constraints_encountered": [
          "MFA Required – increases difficulty of initially compromising an account with access to private repositories but does not restrict repository reads once the account is compromised.",
          "SSO-Only Authentication – GitHub logins are federated through an IdP; credential theft must occur elsewhere, but once a valid session or token exists, repository access functions normally.",
          "IP Allowlisting – limits where authenticated access to private repositories can originate; attacker may need to operate from a compromised host inside the allowlisted network.",
          "Domain-Based Registration, Email Verification Required, Admin Approval Required – hinder registering new accounts, pushing attackers toward compromising existing users.",
          "Rate Limiting – constrains high-volume REST API enumeration; large-scale scanning must be throttled or distributed.",
          "CAPTCHA Protection – affects automated login attempts but not ordinary API use with an already-issued token."
        ],
        "evasion_considerations": [
          "Clone repositories and perform scanning offline rather than using repetitive search API calls, reducing suspicious API patterns.",
          "Throttle repository enumeration and cloning to stay well within REST API rate limits and avoid lockouts or anomaly detection.",
          "Limit the volume of data exfiltrated at once (e.g., compress and stage only repositories likely to contain credentials) to blend with normal developer workflows."
        ],
        "comments": "Directly maps to MITRE T1552 Unsecured Credentials. GitHub’s role as a code and configuration host makes repository contents and history a primary location for hard-coded secrets, similar to attackers harvesting credentials from configuration templates or scripts in other environments.",
        "credentials_obtained": "Static credentials and API tokens embedded in repository code, configuration files, commit history, or package artifacts (for example, cloud provider keys, database passwords, SaaS API tokens, and occasionally GitHub personal access tokens)."
      },
      {
        "can_achieve": true,
        "technique_name": "Chat Messages",
        "technique_stix_id": "attack-pattern--9664ad0e-789e-40ac-82e2-d7b17fbe8fb3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use an account or token with read access to the target repositories and organization to view issues, pull requests, and project items, which are often used as discussion channels for troubleshooting and support.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "Project Planning & Reporting with GitHub Projects",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Issues UI – https://docs.github.com/en/issues",
              "Pull requests UI – https://docs.github.com/en/pull-requests",
              "Projects UI – https://docs.github.com/en/issues/planning-and-tracking-with-projects",
              "Issues REST API – https://docs.github.com/en/rest/issues/issues",
              "Pull requests REST API – https://docs.github.com/en/rest/pulls/pulls"
            ],
            "related_data": [
              "Issues and their titles, bodies, and states",
              "Issue comments and reactions",
              "Pull request descriptions and review comments",
              "Project items and custom text fields"
            ],
            "notes": "GitHub Issues and PRs act as collaboration/chat channels where users may paste logs, configuration, and sometimes credentials, similar to chat tools in MITRE’s examples."
          },
          {
            "step_id": 2,
            "description": "Programmatically enumerate issues and pull requests across accessible repositories via the REST API, collecting text content from bodies and comments for automated analysis.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Issues REST API – https://docs.github.com/en/rest/issues/issues",
              "Pull requests REST API – https://docs.github.com/en/rest/pulls/pulls"
            ],
            "related_data": [
              "Issue bodies and comments",
              "Pull request descriptions, review threads, and commit messages"
            ],
            "notes": "An attacker can mirror LAPSUS$-style behavior by systematically harvesting collaboration content for leaked credentials."
          },
          {
            "step_id": 3,
            "description": "Search issue and PR content for likely credentials, focusing on pasted logs, configuration snippets, and troubleshooting discussions that reference tokens, passwords, or connection strings.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow"
            ],
            "related_interfaces": [
              "Issues UI search and filtering – https://docs.github.com/en/issues",
              "Pull requests UI and diff views – https://docs.github.com/en/pull-requests"
            ],
            "related_data": [
              "Issue and PR text content",
              "Inline code blocks and log snippets attached to issues and PRs"
            ],
            "notes": "Developers often share full logs or configs when debugging, which may unintentionally contain live credentials."
          },
          {
            "step_id": 4,
            "description": "Include project items and any custom text fields in the search, as they can mirror or summarize sensitive content originally posted in issues or pull requests.",
            "related_capabilities": [
              "Project Planning & Reporting with GitHub Projects"
            ],
            "related_interfaces": [
              "Projects UI (tables, boards) – https://docs.github.com/en/issues/planning-and-tracking-with-projects"
            ],
            "related_data": [
              "Project items referencing issues and pull requests",
              "Custom text fields on project items"
            ],
            "notes": "Projects sometimes replicate titles/descriptions from issues/PRs verbatim, propagating any embedded secrets."
          },
          {
            "step_id": 5,
            "description": "Extract any discovered credentials from these collaboration surfaces and associate them to the underlying repository or system (for example, credentials in a deployment-troubleshooting issue likely relate to a specific environment).",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Issues and PR detail views and APIs"
            ],
            "related_data": [
              "Extracted API keys, passwords, and tokens from issue and PR text",
              "Linked repository and environment metadata from issue/PR context"
            ],
            "notes": "As in real-world campaigns targeting Slack/Teams, the adversary’s goal is to mine collaboration content for credentials that users have casually shared."
          }
        ],
        "capabilities_used": [
          "Issue Tracking & Work Management with GitHub Issues",
          "Pull Requests & Code Review Workflow",
          "Project Planning & Reporting with GitHub Projects",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Issues UI – https://docs.github.com/en/issues",
          "Pull requests UI – https://docs.github.com/en/pull-requests",
          "Projects UI – https://docs.github.com/en/issues/planning-and-tracking-with-projects",
          "Issues REST API – https://docs.github.com/en/rest/issues/issues",
          "Pull requests REST API – https://docs.github.com/en/rest/pulls/pulls"
        ],
        "data_accessed": [
          "Issues and their titles, bodies, and comments",
          "Pull request descriptions, review comments, and inline discussions",
          "Project items and custom text fields referencing work items"
        ],
        "preconditions_required": [
          "Read access to the repositories in question (public or private) to view issues and pull requests.",
          "For private or internal repositories, the attacker’s account or token must satisfy MFA Required, SSO-Only Authentication, and IP Allowlisting constraints.",
          "To use the REST API at scale, the attacker needs a PAT or GitHub App token with appropriate scopes (e.g., repo read)."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication – restrict who can access private collaboration content but do not constrain a compromised account’s ability to read issues/PRs.",
          "IP Allowlisting – requires access from approved IP ranges when viewing private repos’ issues and PRs.",
          "Rate Limiting – constrains large-scale API scraping of issues and PRs; the attacker must spread or throttle collection.",
          "Domain-Based Registration and Admin Approval – limit creation of new accounts that can view internal collaboration spaces, pushing attackers to compromise existing ones."
        ],
        "evasion_considerations": [
          "Prefer API queries that resemble typical reporting or search tools (e.g., paginated access) rather than highly repetitive keyword searches.",
          "Blend manual web UI browsing with automated collection to avoid a single token exhibiting all suspicious activity.",
          "Restrict searches to likely high-signal repositories and time windows (for example, recent incidents) to reduce the volume of accesses."
        ],
        "comments": "This directly aligns with MITRE’s Chat Messages credential-access technique, where adversaries mine collaboration platforms for exposed credentials. GitHub Issues and PR discussions function as long-lived, searchable collaboration channels, making them attractive targets.",
        "credentials_obtained": "Credentials and API tokens pasted into issue and pull request bodies or comments, including passwords, bearer tokens, SSH private keys, cloud access keys, or configuration snippets containing them."
      },
      {
        "can_achieve": true,
        "technique_name": "Unsecured Credentials",
        "technique_stix_id": "attack-pattern--435dfb86-2697-4867-85b5-2fef496c0517",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify repositories where GitHub Actions is enabled and actively used, focusing on workflows that reference secrets or deploy to sensitive environments.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions tab and workflow list UI – https://docs.github.com/en/actions",
              "Workflow definitions in .github/workflows – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
              "REST API for workflows – https://docs.github.com/en/rest/actions/workflows"
            ],
            "related_data": [
              "Workflow definitions (YAML) under .github/workflows",
              "Repository metadata indicating Actions usage"
            ],
            "notes": "Workflows that use secrets (e.g., deployments, registry logins) are more likely to have accidentally logged credentials."
          },
          {
            "step_id": 2,
            "description": "Enumerate past workflow runs and associated jobs for those repositories using the Actions UI or REST API to build a list of runs whose logs and artifacts can be inspected.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions run history and logs UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "REST API for workflow runs – https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "Job execution metadata and logs",
              "Artifacts and caches generated by workflows"
            ],
            "notes": "Background jobs are explicitly documented as potentially storing sensitive data in logs and artifacts if misconfigured."
          },
          {
            "step_id": 3,
            "description": "Download and inspect job logs for evidence of secrets that were echoed or included in diagnostic output (for example, full Authorization headers, environment dumps, or printed configuration values).",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Actions logs UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "REST APIs for job logs under workflow runs – https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "Actions job logs",
              "Secrets and environment variables that may have been printed into logs"
            ],
            "notes": "GitHub documentation notes that logs can inadvertently store sensitive data, making this a primary unsecured-credentials surface."
          },
          {
            "step_id": 4,
            "description": "Download build artifacts and caches produced by workflows and scan them for embedded credentials (for example, .env-like files, compiled configs, or test output artifacts).",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)",
              "Actions Artifacts & Logs Storage"
            ],
            "related_interfaces": [
              "Artifacts download links from Actions UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "REST API for artifacts – https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "Artifacts and caches generated by workflows",
              "Build outputs and logs stored in Actions Artifacts & Logs Storage"
            ],
            "notes": "Artifacts may contain configuration snapshots or deployment manifests that include credentials."
          },
          {
            "step_id": 5,
            "description": "Correlate any discovered secrets with their use in workflows (for example, determining whether a token is a GitHub PAT, GITHUB_TOKEN, cloud API key, or registry credential) based on context in the logs and workflow YAML.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Workflow YAML views in the repository UI – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
              "REST API for workflows – https://docs.github.com/en/rest/actions/workflows"
            ],
            "related_data": [
              "Secrets and environment variables referenced in workflows",
              "Extracted secrets from logs and artifacts"
            ],
            "notes": "As in MITRE’s examples of attackers using third-party tools to pull credentials from system artifacts, the attacker here leverages existing logs and build outputs without needing to change workflows."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "GitHub REST API",
          "Actions Artifacts & Logs Storage"
        ],
        "interfaces_used": [
          "Actions tab and workflow list UI – https://docs.github.com/en/actions",
          "Actions run history and logs UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
          "Workflow YAML definitions under .github/workflows – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
          "REST API for workflows – https://docs.github.com/en/rest/actions/workflows",
          "REST API for workflow runs, jobs, and artifacts – https://docs.github.com/en/rest/actions/workflow-runs"
        ],
        "data_accessed": [
          "Workflow definitions (YAML)",
          "Job execution metadata and logs",
          "Artifacts and caches generated by workflows",
          "Secrets and environment variables that may have been written into these logs or artifacts"
        ],
        "preconditions_required": [
          "Read access to the repository and permission to view its Actions workflow runs and artifacts (typically any collaborator with repo read access, depending on organization policy).",
          "For private repositories and enterprise orgs, the attacker’s account or token must meet MFA Required, SSO-Only Authentication, and IP Allowlisting constraints.",
          "Actions must be enabled for the repository, with historical workflow runs and logs still retained."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication – constrain initial account compromise but do not limit a compromised user’s ability to view Actions logs.",
          "IP Allowlisting – requires the attacker to access Actions data from within permitted IP ranges.",
          "Rate Limiting – restricts high-volume API-based retrieval of logs and artifacts; large campaigns must pace requests.",
          "Retention policies for Actions logs and artifacts – older runs may have been pruned, limiting how far back credentials can be recovered."
        ],
        "evasion_considerations": [
          "Retrieve logs and artifacts slowly and in limited batches to avoid triggering rate-limit thresholds or anomalous download patterns.",
          "Focus on workflows and time windows where secrets are most likely (deployment jobs, recent incidents) to minimize the volume of accesses.",
          "Use tokens with permissions that appear consistent with the user’s normal role (for example, a CI-bot PAT) to blend into expected traffic."
        ],
        "comments": "This is another instance of T1552 Unsecured Credentials, specifically targeting CI/CD logs and artifacts. GitHub explicitly warns that Actions logs and artifacts may inadvertently store secrets, mirroring real-world misuse of build logs and system artifacts to harvest credentials.",
        "credentials_obtained": "Secrets and tokens that have been written into existing GitHub Actions logs, job output, or build artifacts, such as cloud API keys, deployment tokens, package registry credentials, or accidentally printed GITHUB_TOKEN values."
      },
      {
        "can_achieve": true,
        "technique_name": "Steal Application Access Token",
        "technique_stix_id": "attack-pattern--890c9858-598c-401d-a4d5-c67ebcdd703a",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Gain the ability to influence or control GitHub Actions workflow definitions or the code they execute, either by compromising a maintainer account, abusing write access to the repository, or exploiting a misconfigured trigger (for example, a workflow that runs untrusted fork code with access to secrets).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository code and workflow editing via the web UI – https://docs.github.com/en/actions",
              "Editing workflow YAML in .github/workflows – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax"
            ],
            "related_data": [
              "Workflow definitions",
              "Repository source code controlling step logic"
            ],
            "notes": "MITRE examples show attackers stealing tokens from CI/CD environments once they can run code; here the attacker achieves that via Actions workflows."
          },
          {
            "step_id": 2,
            "description": "Identify which secrets and tokens are available to workflows (for example, repository, environment, or organization secrets; GITHUB_TOKEN; registry or cloud credentials) by inspecting workflow YAML and repository/environment configuration.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Organization & Team Administration",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Secrets configuration in the repository/organization UI (as referenced from Actions docs) – https://docs.github.com/en/actions",
              "Workflow YAML referencing secrets.* – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax"
            ],
            "related_data": [
              "Secrets and environment variables configured for Actions",
              "Implicit GITHUB_TOKEN created for each workflow run"
            ],
            "notes": "Understanding which secrets are injected into the job environment dictates which tokens are worth stealing."
          },
          {
            "step_id": 3,
            "description": "Modify or add a workflow step that reads these secrets and application access tokens from the job environment and makes them observable to the attacker (for example, by writing them into logs or a new artifact that only the attacker’s account is expected to inspect).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Workflow YAML editing – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
              "Actions run history and logs UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs"
            ],
            "related_data": [
              "Secrets and environment variables available to workflows",
              "GITHUB_TOKEN and other application access tokens provided to the job"
            ],
            "notes": "As in the MITRE OAuth and CI/CD token theft examples, the attacker leverages the execution environment to extract short-lived or long-lived access tokens."
          },
          {
            "step_id": 4,
            "description": "Trigger the modified workflow by pushing code, manually dispatching a workflow, or opening a pull request that causes the workflow to run in a context where secrets are available.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Triggering workflows via pushes, pull requests, or workflow_dispatch – https://docs.github.com/en/actions/concepts/workflows-and-actions",
              "Pull requests UI – https://docs.github.com/en/pull-requests"
            ],
            "related_data": [
              "Events (push, pull_request, schedule, etc.) associated with workflow runs",
              "Job execution metadata"
            ],
            "notes": "Misconfigured triggers (e.g., pull_request_target) can cause secrets to be exposed when processing untrusted contributions."
          },
          {
            "step_id": 5,
            "description": "Once the workflow run completes, retrieve the logs or artifacts that contain the extracted secrets and tokens using the Actions UI or REST API.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions run and logs UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "REST API for workflow runs, logs, and artifacts – https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "Actions job logs and artifacts containing printed or stored secrets",
              "Extracted application access tokens"
            ],
            "notes": "At this point the attacker has harvested live application access tokens from the CI environment."
          },
          {
            "step_id": 6,
            "description": "Use the stolen tokens (for example, PATs, cloud provider access keys, registry tokens, or GITHUB_TOKEN if still valid) from outside of GitHub Actions for further authenticated access to GitHub or external services, as permitted by their scopes.",
            "related_capabilities": [
              "GitHub REST API",
              "Package Management with GitHub Packages",
              "External services integrated via Actions (conceptually)"
            ],
            "related_interfaces": [
              "General REST API – https://docs.github.com/en/rest",
              "Ecosystem-native tools (e.g., Docker, npm) that accept the stolen tokens"
            ],
            "related_data": [
              "Stolen application access tokens and secrets",
              "Resources reachable using these tokens"
            ],
            "notes": "Consistent with MITRE’s Steal Application Access Token examples, the attacker is now able to act with the permissions assigned to these tokens."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Workflow definitions in .github/workflows – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
          "Actions UI for runs and logs – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
          "Repository code and pull request UI – https://docs.github.com/en/pull-requests",
          "REST API for workflow runs and artifacts – https://docs.github.com/en/rest/actions/workflow-runs"
        ],
        "data_accessed": [
          "Secrets and environment variables configured for Actions",
          "GITHUB_TOKEN and other access tokens in the job environment",
          "Actions logs and artifacts containing exfiltrated secrets"
        ],
        "preconditions_required": [
          "Ability to modify or influence workflow definitions or job steps (for example, collaborator/maintainer access, or a misconfigured workflow that runs untrusted code with access to secrets).",
          "Actions enabled for the repository, with workflows that have access to secrets and tokens.",
          "For private repositories, the attacker’s identity must pass MFA Required and SSO-Only Authentication and connect from an IP allowed by IP Allowlisting."
        ],
        "constraints_encountered": [
          "Organization and enterprise policies on Actions may restrict which actions and runners are allowed, potentially limiting arbitrary code execution or preventing certain triggers from accessing secrets.",
          "MFA Required, SSO-Only Authentication, and IP Allowlisting make obtaining the necessary write access to workflows more difficult but do not constrain workflow behavior after compromise.",
          "Secret Scanning & Push Protection may detect or block certain obvious exfiltration patterns (for example, committing tokens into the repository) but generally does not inspect ephemeral workflow logs prior to access."
        ],
        "evasion_considerations": [
          "Make subtle changes to existing workflows rather than adding obviously malicious steps, so that diffs appear as routine maintenance.",
          "Expose secrets through artifacts or logs that only a small set of users typically access, reducing chances of accidental discovery.",
          "Trigger exfiltrating workflows sparingly to avoid unusual spikes in run volume or artifact creation."
        ],
        "comments": "Closely matches MITRE T1528 Steal Application Access Token, applied to GitHub’s CI/CD environment. The attacker abuses their ability to run code in Actions to harvest short-lived and long-lived tokens from the job environment.",
        "credentials_obtained": "Secrets and application access tokens injected into Actions workflows and exfiltrated via logs or artifacts, including GITHUB_TOKEN, repository/organization/environment secrets (cloud provider keys, registry credentials, PATs), and other API tokens used in CI."
      },
      {
        "can_achieve": true,
        "technique_name": "Steal Application Access Token",
        "technique_stix_id": "attack-pattern--890c9858-598c-401d-a4d5-c67ebcdd703a",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Compromise or control a developer account that is allowed to create and use GitHub Codespaces for one or more target repositories within the organization.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Authentication & Account Security Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Codespaces UI entry points in repositories – https://docs.github.com/en/codespaces",
              "Codespaces with GitHub CLI – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli"
            ],
            "related_data": [
              "User identities and permissions for Codespaces usage",
              "Repository access permissions"
            ],
            "notes": "The attacker effectively uses the compromised developer’s ability to start privileged development environments."
          },
          {
            "step_id": 2,
            "description": "Create or open a Codespace for the target repository, ensuring that repository access and any configured Codespaces secrets are available to the environment.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Projects & Codespaces Automation and Prebuilds"
            ],
            "related_interfaces": [
              "Codespaces creation and management UI – https://docs.github.com/en/codespaces",
              "Codespaces prebuilds configuration – https://docs.github.com/en/codespaces/prebuilding-your-codespaces"
            ],
            "related_data": [
              "Codespace instances, including filesystem and environment",
              "Dev container configuration and prebuild images"
            ],
            "notes": "Codespaces documentation notes that environments can have access to private repositories and registries, implying access to associated secrets."
          },
          {
            "step_id": 3,
            "description": "Within the running Codespace, inspect environment variables, configuration files, and dev container setup for embedded tokens or credentials (for example, Codespaces secrets, PATs stored in config files, or registry credentials).",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "Codespaces terminal and IDE integrations – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code"
            ],
            "related_data": [
              "Secrets and environment variables scoped to codespaces",
              "Filesystem state containing configuration and credentials files"
            ],
            "notes": "As in MITRE examples of harvesting tokens from cloud workloads, the attacker treats the Codespace as a cloud-hosted environment whose metadata and configs may contain usable tokens."
          },
          {
            "step_id": 4,
            "description": "If prebuild images or dev container definitions include cached credentials (for example, in baked-in configuration, environment defaults, or scripts), inspect these artifacts via the devcontainer configuration and any associated scripts.",
            "related_capabilities": [
              "Projects & Codespaces Automation and Prebuilds",
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "Prebuild configuration UI – https://docs.github.com/en/codespaces/prebuilding-your-codespaces"
            ],
            "related_data": [
              "Codespaces prebuild configurations and VM images",
              "Dev container configuration files"
            ],
            "notes": "Misconfigured prebuilds may include static credentials that are then replicated to many Codespaces instances."
          },
          {
            "step_id": 5,
            "description": "Extract discovered tokens from the Codespace (for example, copying them out via the IDE terminal or CLI) and store them for subsequent use against GitHub or external services, subject to their scopes.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Codespaces terminal and local environment access – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli"
            ],
            "related_data": [
              "Stolen application access tokens present in the Codespace environment",
              "Associated metadata (which repository or service each token relates to)"
            ],
            "notes": "The attacker now has access tokens analogous to those stolen from containers or virtual machines in other cloud environments (T1528)."
          }
        ],
        "capabilities_used": [
          "Cloud Development Environments with GitHub Codespaces",
          "Projects & Codespaces Automation and Prebuilds",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Codespaces UI in repository and user menus – https://docs.github.com/en/codespaces",
          "Codespaces with GitHub CLI – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli",
          "Codespaces in Visual Studio Code – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code",
          "Prebuilds configuration – https://docs.github.com/en/codespaces/prebuilding-your-codespaces"
        ],
        "data_accessed": [
          "Codespace instances (filesystem and running environment)",
          "Secrets and environment variables scoped to Codespaces",
          "Dev container and prebuild configuration files"
        ],
        "preconditions_required": [
          "Compromised or malicious user account with permission to create/open Codespaces for the target repositories.",
          "Codespaces feature enabled for the organization and the specific repositories.",
          "The attacker’s account must pass MFA Required and SSO-Only Authentication and originate traffic from an IP allowed by IP Allowlisting for enterprise environments."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication – hinder initial compromise of developer accounts but do not restrict a compromised account’s ability to open Codespaces.",
          "IP Allowlisting – may restrict where Codespaces can be accessed from, forcing the attacker to operate from allowed IP ranges.",
          "Organization and enterprise policies on machine types, regions, networking, and retention may limit persistence of tokens in snapshots but do not prevent in-session inspection of secrets once a Codespace is running."
        ],
        "evasion_considerations": [
          "Open and use Codespaces in patterns similar to legitimate developers (for example, during working hours, tied to real repositories) to avoid anomalous usage.",
          "Avoid making overtly suspicious changes inside the Codespace that would leave evidence in the repository (for example, don’t commit exfil scripts).",
          "Prefer reading tokens from environment and config in memory or ephemeral files rather than writing additional files that might be noticed."
        ],
        "comments": "Applies T1528 Steal Application Access Token to GitHub’s managed development environments. Codespaces act like cloud VMs where access tokens and other secrets are present for convenience and can be harvested if an attacker controls the developer account.",
        "credentials_obtained": "Application access tokens and secrets present in GitHub Codespaces environments, such as Codespaces secrets, cached personal access tokens or registry credentials in configuration files, and other API tokens embedded in devcontainer or prebuild configurations."
      },
      {
        "can_achieve": true,
        "technique_name": "Unsecured Credentials",
        "technique_stix_id": "attack-pattern--435dfb86-2697-4867-85b5-2fef496c0517",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using an account with appropriate repository or organization access, navigate to the Security views that surface secret scanning alerts for repositories under the target organization.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Secret scanning UI – https://docs.github.com/en/code-security/secret-scanning",
              "Org-level security center – https://docs.github.com/en/code-security/securing-your-organization"
            ],
            "related_data": [
              "Secret scanning alerts and states",
              "Secret risk assessment data and reports"
            ],
            "notes": "Secret scanning aggregates detected secret tokens and their locations, effectively giving the attacker a precomputed index of credential exposures."
          },
          {
            "step_id": 2,
            "description": "Enumerate all secret scanning alerts across accessible repositories via the UI or the secret scanning REST API, filtering for still-open or recently detected secrets that are likelier to remain valid.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Secret scanning REST API – https://docs.github.com/en/rest/secret-scanning/secret-scanning",
              "Org-level security configuration and risk views – https://docs.github.com/en/code-security/securing-your-organization"
            ],
            "related_data": [
              "Detected secret tokens and metadata",
              "Alert status (open, resolved, dismissed)",
              "Repository and file/line location for each detection"
            ],
            "notes": "Org-scale security capabilities highlight where secrets have leaked, much like the risk summaries described in the documentation."
          },
          {
            "step_id": 3,
            "description": "Drill into individual secret scanning alerts to view the detected secret value or sufficient contextual information (for example, in-code value snippets) to reconstruct the credential.",
            "related_capabilities": [
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Secret scanning alert detail pages – https://docs.github.com/en/code-security/secret-scanning"
            ],
            "related_data": [
              "Detected secret token strings or excerpts",
              "Associated code context (file, commit, surrounding lines)"
            ],
            "notes": "The key advantage for the attacker is that GitHub has already localized the exact locations of tokens that look like credentials."
          },
          {
            "step_id": 4,
            "description": "Leverage org-level secret risk assessment reports to prioritize repositories and secrets with the greatest potential impact (for example, secrets in production repositories or with many detections).",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Secret risk assessment dashboards – https://docs.github.com/en/code-security/securing-your-organization"
            ],
            "related_data": [
              "Secret risk assessment data and exposure metrics",
              "Lists of repositories categorized by secret exposure level"
            ],
            "notes": "This mirrors attackers using security tooling outputs (as in MITRE examples) to prioritize which credentials to target."
          },
          {
            "step_id": 5,
            "description": "Extract the exposed secrets from alerts and correlated source files, storing them along with metadata (repository, path, detection time) for later exploitation or validation.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Secret scanning alert UI and APIs – https://docs.github.com/en/rest/secret-scanning/secret-scanning",
              "Repository content access to confirm the secret value – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Extracted secret tokens from alert content",
              "Repository and commit metadata for each secret"
            ],
            "notes": "In effect, the attacker is turning a defensive detection feature into a curated feed of credentials."
          }
        ],
        "capabilities_used": [
          "Secret Scanning & Push Protection",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "GitHub REST API",
          "Organization & Team Administration"
        ],
        "interfaces_used": [
          "Secret scanning UI – https://docs.github.com/en/code-security/secret-scanning",
          "Secret scanning REST API – https://docs.github.com/en/rest/secret-scanning/secret-scanning",
          "Org-level security center and risk assessments – https://docs.github.com/en/code-security/securing-your-organization"
        ],
        "data_accessed": [
          "Detected secret tokens and metadata",
          "Secret scanning alerts and their states",
          "Secret risk assessment data and exposure metrics"
        ],
        "preconditions_required": [
          "Attacker must control an account (or app token) with permission to view secret scanning alerts for the relevant repositories or organization (for example, security manager, repository admin, or GitHub App with security events access).",
          "For enterprise organizations, the account must satisfy MFA Required and SSO-Only Authentication and originate from an IP allowed by IP Allowlisting.",
          "Secret scanning must be enabled on the target repositories; otherwise, no alerts are present to exploit."
        ],
        "constraints_encountered": [
          "Access to secret scanning data is limited to users and apps with specific roles or scopes; general repo readers may not see all alerts.",
          "MFA Required, SSO-Only Authentication, and IP Allowlisting raise the bar to compromise an account with security-center access.",
          "Rate Limiting constrains bulk API retrieval of secret scanning alerts but can be worked around with throttled collection.",
          "Secret rotation and alert remediation may mean that some detected secrets are no longer valid by the time they are viewed."
        ],
        "evasion_considerations": [
          "Access alerts via the UI or through low-rate API calls that resemble legitimate security monitoring activity.",
          "Favor querying subsets of repositories or time windows rather than exporting the entire alert corpus at once.",
          "Avoid changing alert states (for example, not dismissing or re-opening alerts) to minimize audit-log evidence of tampering."
        ],
        "comments": "Another form of T1552 Unsecured Credentials, where the attacker leverages GitHub’s own secret-scanning and risk-assessment capabilities to quickly locate and harvest leaked credentials, similar to attackers using security tools against the defender.",
        "credentials_obtained": "Detected secret tokens and associated metadata as surfaced in secret scanning alerts and org-level risk reports, including cloud keys, OAuth tokens, and generic API keys that were previously committed to repositories."
      },
      {
        "can_achieve": true,
        "technique_name": "Steal Application Access Token",
        "technique_stix_id": "attack-pattern--890c9858-598c-401d-a4d5-c67ebcdd703a",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Register a malicious OAuth App or GitHub App in the attacker’s own GitHub account, giving it a plausible name and description and requesting scopes that provide useful access (such as reading organization repositories, Actions data, or issues).",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "GitHub Apps and OAuth app registration UI – https://docs.github.com/en/apps",
              "About creating GitHub Apps – https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps"
            ],
            "related_data": [
              "App registrations and metadata (name, permissions, callback URL)",
              "Client IDs/secrets or app private keys"
            ],
            "notes": "Matches MITRE examples where adversaries register malicious cloud/OAuth apps to capture tokens when victims authorize them."
          },
          {
            "step_id": 2,
            "description": "Configure the app’s callback URL or webhook endpoint to point to attacker-controlled infrastructure that can receive authorization codes or webhook events and exchange them for access tokens.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "App callback and webhook configuration – https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events"
            ],
            "related_data": [
              "App tokens and user access tokens issued to the app",
              "Webhook event payloads containing installation or authorization details"
            ],
            "notes": "As in APT28’s OAuth token-harvesting campaigns, the attacker prepares infrastructure to receive tokens upon user consent."
          },
          {
            "step_id": 3,
            "description": "Lure target users (for example, organization owners or developers) into authorizing or installing the app by sending them links to the app’s authorization page or installation flow, often framed as a productivity, code-quality, or integration tool.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "App installation and authorization screens – https://docs.github.com/en/apps/using-github-apps/about-using-github-apps"
            ],
            "related_data": [
              "User consents granting scopes to the app",
              "Installation records linking the app to organizations or repositories"
            ],
            "notes": "Victims authenticate via SSO/MFA to GitHub, but the attacker receives tokens as a byproduct of the consent workflow, not by stealing passwords."
          },
          {
            "step_id": 4,
            "description": "Upon successful authorization or installation, receive OAuth access tokens or GitHub App installation tokens on the attacker-controlled endpoint, storing them securely for later API use.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub Apps REST API for installation tokens – https://docs.github.com/en/rest/apps/apps",
              "OAuth access token exchange as described under REST authentication – https://docs.github.com/en/rest/authentication"
            ],
            "related_data": [
              "OAuth access tokens bound to victim accounts",
              "GitHub App installation access tokens scoped to victim organizations/repositories"
            ],
            "notes": "This is the core T1528 behavior: harvesting application access tokens rather than passwords."
          },
          {
            "step_id": 5,
            "description": "Use the stolen tokens to call the GitHub REST API and access victim resources (for example, reading private repositories, workflow logs, or security alerts) according to the scopes and permissions granted.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "REST API index – https://docs.github.com/en/rest",
              "REST categories for repos, issues, pulls, and actions – https://docs.github.com/en/rest/repos/repos, https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "Repositories, issues, pull requests, and Actions data accessible via the app’s scopes",
              "Any secrets or credentials discoverable through those data surfaces"
            ],
            "notes": "The attacker can now use the app tokens like any other integration, but for malicious purposes."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Webhook Event Delivery",
          "Organization & Team Administration",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "GitHub Apps and OAuth apps registration and configuration UI – https://docs.github.com/en/apps",
          "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps",
          "OAuth and REST authentication documentation – https://docs.github.com/en/rest/authentication",
          "App webhook configuration – https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events"
        ],
        "data_accessed": [
          "App registrations and their permissions",
          "OAuth access tokens and GitHub App installation tokens",
          "Victim repositories and other resources accessible through these tokens"
        ],
        "preconditions_required": [
          "Ability to register GitHub Apps or OAuth apps (any GitHub user can typically do this in their own account).",
          "Ability to reach target users who can authorize or install the app (for example, via phishing or internal messaging).",
          "For access to enterprise organizations, the victim approver must have rights to install the app on relevant orgs/repositories and will authenticate via SSO and MFA as usual."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication protect user logins but do not prevent users from granting app access once authenticated; this technique sidesteps password theft.",
          "Organization and enterprise policies may control which third-party apps can be installed; the attacker may be limited to personal accounts or less-restricted orgs.",
          "IP Allowlisting may limit where victims can complete the authorization flow, but does not affect token use once obtained (if used via allowed infrastructure or proxies).",
          "Rate Limiting constrains how aggressively the attacker can use stolen tokens via the REST API."
        ],
        "evasion_considerations": [
          "Use an app name, logo, and description that mimic legitimate tools to reduce suspicion and bypass informal security review.",
          "Request the minimal set of scopes that still provide high-value access (for example, read-only repo and Actions data) to appear less risky.",
          "Distribute API calls made with stolen tokens over time and across IPs to avoid abnormal spikes associated with a single app installation."
        ],
        "comments": "This is a direct application of MITRE T1528 Steal Application Access Token, mirroring real-world OAuth and cloud-app consent phishing campaigns (for example, APT28’s malicious OAuth apps) but targeting GitHub Apps/OAuth Apps.",
        "credentials_obtained": "OAuth access tokens and GitHub App installation/user tokens that grant API access on behalf of victim users or organizations, scoped according to the permissions granted during authorization/installation."
      },
      {
        "can_achieve": false,
        "technique_name": "Brute Force",
        "technique_stix_id": "attack-pattern--a93494bb-4b80-4ea1-8695-3236a49916fd",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Attempt to perform large numbers of password-based login attempts against GitHub’s authentication endpoints to guess or spray passwords for user accounts.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Identity & Authentication Service"
            ],
            "related_interfaces": [
              "Authentication flows described in the Authentication docs – https://docs.github.com/en/authentication",
              "Enterprise SSO/IAM configuration – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
            ],
            "related_data": [
              "User identities and credential verification responses",
              "Security logs of sign-in attempts"
            ],
            "notes": "In theory, this would align with MITRE’s password guessing, spraying, credential stuffing, and brute-force techniques."
          },
          {
            "step_id": 2,
            "description": "Observe whether login attempts can be made directly against GitHub or are redirected to an external IdP due to SSO-only enforcement, and whether repeated failures result in account lockout or IP blocking.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Enterprise IAM / SSO management – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
            ],
            "related_data": [
              "SSO configuration and enforcement policies",
              "Security logs capturing failed authentications"
            ],
            "notes": "In this environment, SSO-only and MFA enforcement mean that password checks happen primarily at the IdP, outside GitHub’s control."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Identity & Authentication Service",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "User login and authentication flows as documented under Authentication – https://docs.github.com/en/authentication",
          "Enterprise IAM/SSO configuration – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
        ],
        "data_accessed": [
          "User identities and account metadata",
          "Security logs of failed and successful sign-in attempts"
        ],
        "preconditions_required": [
          "Network connectivity to GitHub’s authentication endpoints or to the configured SSO identity provider."
        ],
        "constraints_encountered": [
          "SSO-Only Authentication – users authenticate via an external IdP; GitHub does not directly process passwords for these users, so brute forcing must target the IdP rather than GitHub.",
          "MFA Required – even if a password were guessed, access would still require a valid second factor, significantly limiting the effectiveness of brute-force techniques.",
          "Rate Limiting – strict rate limiting on authentication endpoints and IP bans for excessive failures make high-volume guessing impractical.",
          "CAPTCHA Protection – automated password attacks would have to solve CAPTCHAs at scale.",
          "IP Allowlisting – only requests from pre-approved IP ranges are accepted, reducing the attacker’s ability to mount distributed password attacks.",
          "Domain-Based Registration, Email Verification Required, Admin Approval Required – prevent trivial registration of large numbers of new accounts to test password patterns."
        ],
        "evasion_considerations": [
          "Not applicable in this environment; realistic brute-force or spraying attempts would have to target the external IdP and its controls rather than GitHub itself."
        ],
        "comments": "While MITRE techniques such as Password Guessing, Password Spraying, Credential Stuffing, and Brute Force apply generically to SaaS authentication, the documented environment constraints (SSO-only, MFA-required, strong rate limiting, CAPTCHA, and IP allowlisting) effectively force all credential attacks to occur against the external identity provider, not via GitHub’s own capabilities. Therefore, GitHub does not provide a realistic brute-force credential access path in this configuration.",
        "credentials_obtained": "Not obtainable via GitHub in this environment due to SSO-only and MFA-enforced authentication; any viable brute-force-style credential access would need to target the external identity provider instead of GitHub."
      }
    ],
    "summary": "GitHub exposes several realistic credential access paths aligned with MITRE Credential Access techniques, primarily centered on T1552 Unsecured Credentials and T1528 Steal Application Access Token, plus T9664 Chat Messages. Attackers who control or compromise accounts with repository, CI/CD, Codespaces, or security-center access can:\n\n- Mine repositories, history, packages, and collaboration content (issues, PRs, projects) for embedded secrets.\n- Harvest credentials already leaked into GitHub Actions logs, artifacts, and caches.\n- Actively exfiltrate GITHUB_TOKEN and other secrets from Actions by modifying workflows to print or store them.\n- Steal tokens resident in GitHub Codespaces environments (Codespaces secrets, cached PATs, registry credentials).\n- Exploit secret scanning alerts and org-level risk assessments as a curated index of leaked credentials.\n- Conduct consent-phishing via malicious GitHub Apps/OAuth Apps to obtain OAuth and installation tokens with victim-scoped access.\n\nEnvironment constraints (SSO-only, MFA-required, IP allowlisting, rate limiting, CAPTCHA, and controlled registration) largely eliminate direct brute-force/password-based credential acquisition through GitHub itself; such attacks must instead target the external identity provider. The dominant risk, therefore, is not stealing GitHub account passwords via login endpoints but abusing internal GitHub features and security tooling to locate, exfiltrate, or mint powerful tokens and third-party credentials already present in code, automation, and collaboration artifacts."
  },
  "lateral_movement": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Application Access Token",
        "technique_stix_id": "attack-pattern--f005e783-57d4-4837-88ad-dbe7faee1c51",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use the compromised personal access token (PAT), fine‑grained PAT, or GitHub App installation token to call the GitHub REST API and confirm the associated identity and that the token is valid (for example, GET /user and /user/orgs).",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "User account security settings for passwords, two-factor authentication, passkeys, SSH keys, and tokens. (https://docs.github.com/en/authentication)",
              "Versioned REST API endpoints under api.github.com organized by resource categories. (https://docs.github.com/en/rest)"
            ],
            "related_data": [
              "User identities and account metadata",
              "Authentication credentials (personal access tokens, fine-grained tokens, GitHub App tokens)"
            ],
            "notes": "This mirrors real-world use of stolen OAuth and cloud access tokens to query profile and tenant membership before expanding access."
          },
          {
            "step_id": 2,
            "description": "Enumerate all organizations and repositories the token can see by calling REST API endpoints such as /user/orgs, /user/repos, and /orgs/{org}/repos, including private and internal repositories.",
            "related_capabilities": [
              "GitHub REST API",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "REST API endpoints for organizations under /orgs. (https://docs.github.com/en/rest/orgs/orgs)",
              "REST API endpoints under /repos for programmatic repository lifecycle and configuration. (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Organization accounts and profiles",
              "Members, roles, and repository access policies",
              "Repositories and repository metadata (including visibility and owner)"
            ],
            "notes": "API enumeration allows systematic discovery of all code and projects reachable by the token, not just the initial foothold."
          },
          {
            "step_id": 3,
            "description": "For each discovered repository, query its metadata (for example, GET /repos/{owner}/{repo}) to determine the token’s permission level (read, triage, write, maintain, admin) and prioritize those where the token has write or admin access.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "REST API – /repos/{owner}/{repo} to retrieve repository details and permissions. (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Repository metadata, including permissions for the authenticated user or installation",
              "Repository visibility and collaborator permissions"
            ],
            "notes": "Focusing on repositories with write/admin rights maximizes the ability to plant workflows, taint content, or adjust settings in later tactics."
          },
          {
            "step_id": 4,
            "description": "Use the token to clone or fetch additional private repositories via Git over HTTPS, or to download their contents via the REST API, gaining source code and configuration beyond the initially compromised project.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Git over HTTPS using the same user credentials or tokens across many repositories. (https://docs.github.com/en/get-started/git-basics/set-up-git)",
              "REST API – /repos/{owner}/{repo}/contents for repository file access. (https://docs.github.com/en/rest/repos/contents)"
            ],
            "related_data": [
              "Commits, branches, and tags",
              "Files, blobs, and trees",
              "Workflow definitions and configuration files"
            ],
            "notes": "This is lateral movement to new codebases under the same account; any secrets or infrastructure links in these repos can support further compromise in other tactics."
          },
          {
            "step_id": 5,
            "description": "Where the token has write or admin access, use REST or Git to introduce or modify configuration in additional repositories (for example, adding or changing Actions workflows, Codespaces configs, or webhooks) so those repos can later be abused for further pivots.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)",
              "Cloud Development Environments with GitHub Codespaces",
              "Webhook Event Delivery",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Web UI for creating repositories, managing settings, enabling features, and browsing code and history. (https://docs.github.com/en/repositories)",
              "Workflow YAML files under .github/workflows in repositories. (https://docs.github.com/en/actions/reference/workflows-and-actions)",
              "Codespaces entry points in repository and user menus for creating and managing codespaces. (https://docs.github.com/en/codespaces)",
              "Repository-level webhooks configuration UI. (https://docs.github.com/en/webhooks)",
              "REST API – /repos for updating repository configuration. (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Codespaces configuration (devcontainer.json, Dockerfiles)",
              "Webhook configurations (endpoint URLs and secrets)",
              "Repository settings (branch protections, features enabled)"
            ],
            "notes": "Changes here set up additional mechanisms for later movement or persistence while staying within the privileges of the stolen token."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "User account security settings for passwords, two-factor authentication, passkeys, SSH keys, and tokens. (https://docs.github.com/en/authentication)",
          "Versioned REST API endpoints under api.github.com organized by resource categories. (https://docs.github.com/en/rest)",
          "REST API endpoints under /repos for programmatic repository lifecycle and configuration. (https://docs.github.com/en/rest/repos/repos)",
          "REST API endpoints for organizations under /orgs. (https://docs.github.com/en/rest/orgs/orgs)",
          "Git over HTTPS using personal access tokens. (https://docs.github.com/en/get-started/git-basics/set-up-git)"
        ],
        "data_accessed": [
          "User identities and account metadata",
          "Organization accounts and membership lists",
          "Repositories and repository metadata, including visibility and permissions",
          "Commits, branches, tags, and repository files",
          "Workflow definitions and other configuration stored in repositories"
        ],
        "preconditions_required": [
          "Attacker possesses a valid personal access token, fine-grained PAT, or GitHub App installation token associated with a user or app that already has access to multiple repositories and/or organizations.",
          "The token has not been revoked and, where SSO-only authentication is in use, the token has been SSO-authorized for the relevant organizations.",
          "Attacker can reach api.github.com and Git HTTPS endpoints from an IP address allowed by any IP allowlisting or network controls in front of GitHub."
        ],
        "constraints_encountered": [
          "MFA Required – increases difficulty of obtaining new tokens but does not protect use of an already-compromised application access token.",
          "SSO-Only Authentication – requires that PATs or app tokens be explicitly authorized for each SSO-enforced organization; tokens lacking authorization will not provide cross-org access.",
          "IP Allowlisting – if the enterprise restricts access to specific IP ranges, the attacker must operate from a compromised system or proxy within the allowlist or this vector is blocked.",
          "Rate Limiting – aggressive REST API enumeration (for example, listing thousands of repos rapidly) may hit GitHub rate limits and produce noticeable telemetry."
        ],
        "evasion_considerations": [
          "Throttle API calls and distribute enumeration over time to avoid exceeding rate limits or triggering anomaly detection.",
          "Mimic common developer tools (such as official SDKs or the GitHub CLI) in user agents and interaction patterns.",
          "Prefer targeted access to high-value repositories over bulk cloning to reduce audit noise and bandwidth anomalies.",
          "Avoid overt administrative changes (for example, changing org-wide settings) during lateral enumeration to stay below review and audit thresholds."
        ],
        "comments": "This vector is a direct analogue of real-world abuses of OAuth and cloud application tokens, applied to GitHub PATs and GitHub App installation tokens to expand from one compromised identity to all GitHub resources it can reach.",
        "movement_achieved": "Expansion from a single compromised application access token to read and potentially modify every repository and organization the associated identity can access, enabling cross-repository and cross-organization lateral movement entirely via GitHub’s REST and Git interfaces."
      },
      {
        "can_achieve": true,
        "technique_name": "Use Alternate Authentication Material",
        "technique_stix_id": "attack-pattern--51a14c76-dd3b-440b-9c20-2bf91d25a814",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Catalog all alternate authentication materials already obtained in earlier phases, such as other users’ PATs, GitHub App tokens, SSH private keys or deploy keys, and any OAuth tokens associated with GitHub Apps.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "User account security settings for managing SSH keys and personal access tokens. (https://docs.github.com/en/authentication)",
              "App registration and installation configuration pages for GitHub Apps and OAuth apps. (https://docs.github.com/en/apps)"
            ],
            "related_data": [
              "Personal access tokens and fine-grained personal access tokens",
              "SSH keys and deploy keys used for repository access",
              "GitHub App tokens and user access tokens"
            ],
            "notes": "These materials have been captured via other tactics (for example, secret leakage or off-platform compromise); this vector focuses on using them to move laterally."
          },
          {
            "step_id": 2,
            "description": "For each stolen PAT or GitHub App token, perform a low-noise validation by calling a simple REST API endpoint like GET /user or /app to learn which identity or app it belongs to and confirm the token is still valid.",
            "related_capabilities": [
              "GitHub REST API",
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Versioned REST API endpoints under api.github.com (https://docs.github.com/en/rest)",
              "REST API for GitHub Apps, installations, and tokens. (https://docs.github.com/en/rest/apps/apps)"
            ],
            "related_data": [
              "User identities and account metadata",
              "App registrations and metadata",
              "Token scopes and permissions"
            ],
            "notes": "As in documented campaigns abusing SAML and OAuth tokens, this step establishes which accounts and roles each piece of alternate material represents."
          },
          {
            "step_id": 3,
            "description": "For each stolen SSH or deploy key, attempt a minimal Git SSH operation (such as git ls-remote) against likely repositories to determine which repositories the key grants access to without cloning large histories.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Git over SSH using configured SSH keys and deploy keys. (https://docs.github.com/en/get-started/git-basics/set-up-git)"
            ],
            "related_data": [
              "SSH keys and deploy keys",
              "Git repository refs on accessible repositories"
            ],
            "notes": "Deploy keys may grant direct access to specific repositories even if the attacker does not initially know which ones; probing reveals new footholds."
          },
          {
            "step_id": 4,
            "description": "Using each distinct validated identity (user or app), enumerate its organizations and repositories via the REST API and Git, similar to Vector 1, thereby uncovering code and configuration belonging to multiple separate accounts.",
            "related_capabilities": [
              "GitHub REST API",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "REST API endpoints for organizations (/orgs, /user/orgs). (https://docs.github.com/en/rest/orgs/orgs)",
              "REST API endpoints for repositories (/user/repos, /orgs/{org}/repos). (https://docs.github.com/en/rest/repos/repos)",
              "Git over HTTPS/SSH for cloning repositories. (https://docs.github.com/en/get-started/git-basics/set-up-git)"
            ],
            "related_data": [
              "Organization accounts and membership lists",
              "Repositories and repository metadata across multiple identities",
              "Source code and configuration files in newly discovered repositories"
            ],
            "notes": "This constitutes true lateral movement across accounts: the attacker is no longer confined to a single user but is impersonating multiple principals."
          },
          {
            "step_id": 5,
            "description": "Where any of the newly impersonated identities has elevated permissions (for example, organization owner or enterprise admin), use their tokens to access higher-scope administrative APIs and additional organizations governed by those roles.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Enterprise account settings for managing orgs, policies, IAM, and audit logs. (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "REST API endpoints covering enterprise teams and enterprise-level administration. (https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)",
              "REST API endpoints for organizations and their members. (https://docs.github.com/en/rest/orgs/orgs)"
            ],
            "related_data": [
              "Enterprise account metadata and list of organizations",
              "Org-level settings and repository access policies",
              "Enterprise roles and delegations"
            ],
            "notes": "This step resembles the abuse of forged SAML tokens to impersonate highly privileged cloud accounts in past incidents, but here applied to GitHub’s enterprise and org admin surfaces."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "User account security settings for managing SSH keys and personal access tokens. (https://docs.github.com/en/authentication)",
          "App registration and installation configuration pages for GitHub Apps and OAuth apps. (https://docs.github.com/en/apps)",
          "Versioned REST API endpoints under api.github.com. (https://docs.github.com/en/rest)",
          "REST API for GitHub Apps, installations, and tokens. (https://docs.github.com/en/rest/apps/apps)",
          "Git over SSH using SSH keys and deploy keys. (https://docs.github.com/en/get-started/git-basics/set-up-git)",
          "Enterprise IAM administration for SAML/OIDC and SCIM. (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)"
        ],
        "data_accessed": [
          "Personal access tokens, fine-grained tokens, and associated scopes",
          "SSH keys and deploy keys mapped to specific repositories",
          "GitHub App tokens and installation records",
          "User and app identity metadata",
          "Organization and enterprise membership and roles",
          "Repositories and their contents reachable via each alternate identity"
        ],
        "preconditions_required": [
          "Attacker has already obtained one or more pieces of alternate authentication material (for example, other users’ PATs, GitHub App tokens, SSH private keys, or deploy keys) through prior credential access or off-platform compromise.",
          "These credentials belong to identities or keys that have access to repositories or organizations beyond the attacker’s original foothold.",
          "The alternate materials are still valid (not revoked or rotated) and, for SSO-enforced organizations, have appropriate SSO authorization."
        ],
        "constraints_encountered": [
          "MFA Required – protects interactive logins but does not prevent use of stolen tokens, SSH keys, or cookies as alternate authentication material.",
          "SSO-Only Authentication – may constrain which PATs or app tokens function unless they have been explicitly authorized for SSO-protected orgs.",
          "IP Allowlisting – may prevent use of some tokens or SSH keys from unapproved networks; attacker must route traffic via an allowlisted host.",
          "Secret Scanning & Push Protection – may have detected and triggered rotation of some leaked credentials stored in repositories, reducing but not eliminating available alternate materials."
        ],
        "evasion_considerations": [
          "Use each stolen identity sparingly and avoid concurrent usage patterns that would look unusual for that user or app.",
          "Favor read operations and minimal Git interactions (such as ls-remote and shallow clones) to keep activity light and less noticeable.",
          "Avoid modifying security or authentication settings with impersonated admin accounts unless absolutely necessary, to stay under audit review thresholds.",
          "When using SSH keys, match typical client fingerprints (such as common SSH client versions) to blend with legitimate developer activity."
        ],
        "comments": "This vector extends the token-based approach by explicitly impersonating multiple distinct principals via SSH keys, deploy keys, and other tokens, analogous to adversaries pivoting between cloud service accounts using stolen service account tokens.",
        "movement_achieved": "Lateral movement across multiple GitHub identities—users, apps, and deploy keys—expanding access from an initial account to additional accounts’ organizations and repositories using their alternate authentication material."
      },
      {
        "can_achieve": true,
        "technique_name": "Web Session Cookie",
        "technique_stix_id": "attack-pattern--c3c8c916-2f3c-4e71-94b2-240bdfc996f0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Import the stolen, valid GitHub.com session cookie for the target user into an attacker-controlled browser session, then navigate to GitHub to confirm the user is treated as authenticated without re-entering credentials or MFA.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "User account security and session management via the GitHub web UI. (https://docs.github.com/en/authentication)"
            ],
            "related_data": [
              "Web session identifiers and device verification state",
              "User account metadata associated with the session"
            ],
            "notes": "Real-world campaigns have used stolen cookies to bypass MFA and access cloud email; the same pattern applies to GitHub’s authenticated web sessions."
          },
          {
            "step_id": 2,
            "description": "Using the authenticated web session, browse to the user’s organizations and repositories through the web UI, gaining read or write access to all resources that the victim account can normally reach.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Organization settings and membership views in the web UI. (https://docs.github.com/en/organizations)",
              "Repository browsing and settings in the web UI. (https://docs.github.com/en/repositories)"
            ],
            "related_data": [
              "Organization accounts and membership lists",
              "Repositories, branches, and files"
            ],
            "notes": "Because the cookie authenticates as the user, this instantly extends the attacker’s reach to all of that user’s orgs and private repositories."
          },
          {
            "step_id": 3,
            "description": "From the authenticated browser, access security- and automation-related surfaces associated with the victim’s permissions, such as Actions runs, Codespaces, or app installations, to understand where additional execution and integration footholds exist.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Cloud Development Environments with GitHub Codespaces",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Actions tab in repositories and organizations for viewing workflows and runs. (https://docs.github.com/en/actions)",
              "Codespaces entry points and management UI. (https://docs.github.com/en/codespaces)",
              "GitHub Apps and OAuth app management pages. (https://docs.github.com/en/apps)"
            ],
            "related_data": [
              "Workflow definitions and run history",
              "Codespaces instances and configurations",
              "Installed GitHub Apps and their scopes"
            ],
            "notes": "This step identifies where the victim can already execute code or where apps & secrets may be present for use in later movement."
          },
          {
            "step_id": 4,
            "description": "Optionally, use the authenticated session to create new fine-grained PATs or to authorize existing apps, where allowed, to establish longer-lived application access tokens that persist beyond the lifetime of the web session cookie.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Token creation and management in the account security settings UI. (https://docs.github.com/en/authentication)",
              "App authorization and installation dialogues in the web UI. (https://docs.github.com/en/apps/using-github-apps/about-using-github-apps)"
            ],
            "related_data": [
              "Newly created personal access tokens and scopes",
              "App installation records and user access tokens"
            ],
            "notes": "Where sudo-mode or additional prompts are not required, this converts a transient cookie-based foothold into reusable application tokens for further lateral movement."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Automation with GitHub Actions (User Perspective)",
          "Cloud Development Environments with GitHub Codespaces",
          "GitHub Apps & OAuth Apps Platform"
        ],
        "interfaces_used": [
          "User account security settings and sessions in the web UI. (https://docs.github.com/en/authentication)",
          "Organization settings UI for members, teams, and repositories. (https://docs.github.com/en/organizations)",
          "Repository browsing and settings UI. (https://docs.github.com/en/repositories)",
          "Actions tab in repositories and organizations. (https://docs.github.com/en/actions)",
          "Codespaces management UI. (https://docs.github.com/en/codespaces)",
          "GitHub Apps and OAuth apps configuration UI. (https://docs.github.com/en/apps)"
        ],
        "data_accessed": [
          "Authenticated web session state for the victim account",
          "Organization membership and repository access derived from the victim’s roles",
          "Repositories, issues, pull requests, and workflows visible to the victim",
          "Information about installed apps, Actions workflows, and Codespaces tied to the victim’s access"
        ],
        "preconditions_required": [
          "Attacker has obtained a valid, unexpired GitHub web session cookie for a target account via prior techniques (for example, \"Steal Web Session Cookie\").",
          "The cookie is not bound to a device or IP in a way that completely prevents reuse, or the attacker can operate from a host whose properties match the original device closely enough.",
          "The victim account has membership in one or more organizations or private repositories; otherwise, lateral expansion yields limited gain."
        ],
        "constraints_encountered": [
          "MFA Required – typically enforced at authentication time; a stolen cookie can bypass MFA if the session is already fully authenticated.",
          "SSO-Only Authentication – a valid SSO-authenticated session cookie will bypass repeated SSO prompts until it expires; however, re-auth challenges for high-risk actions may still occur.",
          "IP Allowlisting – if access is restricted to certain IP ranges, the session cookie may not be accepted from outside those ranges; the attacker may need a compromised host inside the allowlist.",
          "Session and device verification flows (such as sudo mode or new-device prompts) may occasionally require re-entry of credentials or a second factor, which the attacker may not possess."
        ],
        "evasion_considerations": [
          "Use browser and network characteristics (IP range, user agent) similar to the victim’s typical environment to avoid triggering device or location alerts.",
          "Avoid high-risk actions (such as password or 2FA changes) that are more likely to require re-authentication and draw scrutiny.",
          "Limit concurrent usage: do not perform actions while the real user is very active to reduce the chances of session conflict or detection.",
          "Operate primarily through standard web UI navigation patterns rather than mass scripted actions to blend with normal user behavior."
        ],
        "comments": "This vector uses a stolen authenticated session to inherit all of a user’s GitHub access, bypassing MFA and SSO controls, analogous to documented \"pass-the-cookie\" attacks against other SaaS platforms.",
        "movement_achieved": "Immediate lateral expansion from no GitHub access to full web-based access to all organizations, repositories, Actions, Codespaces, and app integrations that the victim account can reach, without needing the user’s password or MFA device."
      },
      {
        "can_achieve": true,
        "technique_name": "Software Deployment Tools",
        "technique_stix_id": "attack-pattern--92a78814-b191-47ca-909c-1ccfe3777414",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify a compromised repository that has GitHub Actions workflows enabled and that uses secrets or self-hosted runners linked to external infrastructure (such as customer CI/CD systems, on-prem servers, or cloud accounts).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Actions tab in the repository UI for configuring workflows and viewing runs. (https://docs.github.com/en/actions)",
              "Workflow YAML files under .github/workflows that define jobs and steps. (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
              "Repository settings UI where secrets and Actions configuration are managed. (https://docs.github.com/en/repositories)"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Actions secrets and environment variables",
              "Runner configuration and labels",
              "Repository metadata about enabled features"
            ],
            "notes": "GitHub docs explicitly note that Actions can deploy to production systems or integrate with external CI/CD, making them ideal pivot points."
          },
          {
            "step_id": 2,
            "description": "Modify an existing workflow or add a new one in the repository (for example, by committing a new YAML file under .github/workflows) so that it runs attacker-controlled steps on a runner that has network reach to the target external environment.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Git CLI interacting with GitHub remotes for pushing commits that change workflow files. (https://docs.github.com/en/get-started/git-basics/set-up-git)",
              "Workflow syntax and configuration reference. (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)"
            ],
            "related_data": [
              "Workflow YAML content describing jobs, steps, and runner selection",
              "Repository commit history reflecting the workflow change"
            ],
            "notes": "As in prior abuses of enterprise deployment systems, the adversary repurposes legitimate automation to run their own commands at scale."
          },
          {
            "step_id": 3,
            "description": "Configure the workflow steps to use existing repository, environment, or organization secrets that contain credentials (API keys, SSH keys, cloud tokens) for the external systems, so the job can authenticate outward without introducing obviously new secrets.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Actions secrets configuration in repository/organization settings. (https://docs.github.com/en/actions)",
              "Workflow environment variable and secret usage syntax. (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)"
            ],
            "related_data": [
              "Secrets and environment variables configured for Actions",
              "Authentication tokens for external services (for example, cloud providers, registries)"
            ],
            "notes": "The attacker relies on already-present credentials to minimize configuration changes that might be reviewed or audited."
          },
          {
            "step_id": 4,
            "description": "Trigger the malicious workflow using a permitted mechanism (for example, pushing a commit, using a scheduled run, or invoking a manual workflow_dispatch) so that it executes on the appropriate runner.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Actions run management UI for manually dispatching workflows or monitoring triggered runs. (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)",
              "REST API endpoints for triggering or re-running workflows. (https://docs.github.com/en/rest/actions/workflows)"
            ],
            "related_data": [
              "Job execution metadata and logs",
              "Runner selection and job status information"
            ],
            "notes": "This uses GitHub’s normal event-driven model; no special privileges are needed beyond the ability to introduce the workflow change."
          },
          {
            "step_id": 5,
            "description": "Within the running job, execute commands or scripts that connect to the external environment (for example, calling deployment APIs, SSH endpoints, or management services) using the configured secrets, thereby gaining code execution or control within that external system.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Actions runner execution environment, which runs arbitrary user-defined commands. (https://docs.github.com/en/actions/concepts/workflows-and-actions)",
              "Network connectivity from the runner to external systems configured by the customer (Customer CI/CD and Deployment Systems)."
            ],
            "related_data": [
              "External system credentials stored as workflow secrets",
              "Any outputs or responses captured in Actions logs or artifacts"
            ],
            "notes": "This is the lateral movement step: automation originally meant for deployment is co-opted to give the attacker a foothold in external infrastructure."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "Authentication & Account Security Management",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Actions tab in repositories and organizations for configuring workflows and viewing runs. (https://docs.github.com/en/actions)",
          "Workflow YAML files under .github/workflows. (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
          "Git CLI for pushing workflow changes. (https://docs.github.com/en/get-started/git-basics/set-up-git)",
          "REST API endpoints for workflows and workflow runs. (https://docs.github.com/en/rest/actions/workflows)",
          "Repository settings UI for secrets and Actions configuration. (https://docs.github.com/en/repositories)"
        ],
        "data_accessed": [
          "Workflow definitions, including triggers and runner selection",
          "Actions secrets and environment variables containing external credentials",
          "Runner configuration and job execution metadata",
          "Logs and artifacts produced by the malicious workflow"
        ],
        "preconditions_required": [
          "Attacker can modify or add workflow YAML files in at least one repository that has Actions enabled.",
          "Branch protection and required reviews either do not block workflow changes, are misconfigured, or the attacker can satisfy them using compromised reviewer/maintainer accounts.",
          "The repository or organization has configured Actions secrets or self-hosted runners with network connectivity and credentials to the targeted external systems.",
          "Organization or enterprise policies allow running the types of workflows the attacker needs (for example, third-party actions are not completely blocked if they are required)."
        ],
        "constraints_encountered": [
          "Enterprise and organization Actions policies may restrict which runners can be used, whether workflows from forks can run, and which actions are allowed; these may limit but not fully prevent abuse.",
          "MFA and SSO-Only Authentication affect who can modify workflows but not the execution of already configured workflows once merged.",
          "IP Allowlisting on the GitHub side does not constrain outbound connections from runners to external systems, but allowlists on the external systems themselves may restrict what endpoints the workflow can reach.",
          "Billing and usage limits for Actions (minutes, concurrency) may cap how aggressively workflows can be used without triggering cost or abuse alerts."
        ],
        "evasion_considerations": [
          "Embed malicious steps within existing workflows that already deploy or test code, so new behavior is harder to distinguish from normal deployment automation.",
          "Use environment variables and secrets that already exist rather than adding new ones, to avoid configuration changes visible in audits.",
          "Limit the amount of data written to logs or artifacts about external interactions, to avoid leaving clear traces of the lateral pivot.",
          "Schedule runs at times that match existing CI/CD patterns (for example, during work hours or regular release windows) to blend into expected pipeline activity."
        ],
        "comments": "This vector aligns with documented adversary use of enterprise software deployment tools for lateral movement, with GitHub Actions serving as the SaaS-based orchestration layer that reaches into customer infrastructure via runners and secrets.",
        "movement_achieved": "Movement from a compromised GitHub repository into external infrastructure (such as CI/CD systems, on-prem servers, or cloud services) by abusing GitHub Actions workflows and runners as a software deployment and remote execution tool."
      },
      {
        "can_achieve": true,
        "technique_name": "Cloud Services",
        "technique_stix_id": "attack-pattern--8861073d-d1b8-4941-82ce-dce621d398f0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Leverage a compromised identity in the organization’s external Identity Provider (IdP) that is federated with GitHub Enterprise Cloud via SAML or OIDC, such that this identity is entitled to GitHub organizations through Enterprise Managed Users or SSO.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Enterprise IAM configuration for SAML/OIDC and Enterprise Managed Users. (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)",
              "User SSO login flow for GitHub.com (SSO-only authentication behaviour)."
            ],
            "related_data": [
              "SSO and SAML/OIDC assertion metadata",
              "Enterprise-managed user mappings to organizations"
            ],
            "notes": "This mirrors campaigns where adversaries used compromised high-privilege on-prem or cloud identities to access federated SaaS services."
          },
          {
            "step_id": 2,
            "description": "Use the compromised IdP account to initiate an SSO login to GitHub Enterprise Cloud, obtaining a valid GitHub session and, where applicable, an enterprise-managed user account bound to multiple GitHub organizations.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "User account security with SSO-based authentication. (https://docs.github.com/en/authentication)",
              "Enterprise admin SSO configuration and documentation. (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)"
            ],
            "related_data": [
              "GitHub web session state for the federated account",
              "Enterprise account metadata and linked organizations"
            ],
            "notes": "MFA and conditional access policies are enforced at the IdP; once bypassed, GitHub trusts the resulting assertions as valid logins."
          },
          {
            "step_id": 3,
            "description": "Enumerate all organizations, teams, and repositories that the federated GitHub identity can access using the web UI or REST API (for example, /user/orgs and /orgs/{org}/repos).",
            "related_capabilities": [
              "GitHub REST API",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Versioned REST API endpoints under api.github.com. (https://docs.github.com/en/rest)",
              "REST API for organizations and their members. (https://docs.github.com/en/rest/orgs/orgs)",
              "REST API for repositories. (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "List of organizations and their settings",
              "Team hierarchies and memberships",
              "Repositories and visibility/permission data"
            ],
            "notes": "A single compromised enterprise identity may automatically grant access to many organizations defined in the enterprise account."
          },
          {
            "step_id": 4,
            "description": "Where the federated identity has elevated roles (such as organization owner or enterprise administrator), use those privileges to reach administrative interfaces for multiple organizations, effectively moving from the IdP’s cloud environment into broad GitHub administrative control.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Enterprise account settings UI for managing orgs, policies, and monitoring. (https://docs.github.com/en/enterprise-cloud@latest/admin)",
              "Organization settings UI for membership and repository access. (https://docs.github.com/en/organizations)",
              "Enterprise and organization administration REST APIs. (https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)"
            ],
            "related_data": [
              "Enterprise roles and delegations",
              "Org-level security and access configurations",
              "Audit logs reflecting administrative operations"
            ],
            "notes": "This creates a new high-privilege foothold inside GitHub’s control plane reachable solely through cloud SSO, without separate GitHub-local credentials."
          }
        ],
        "capabilities_used": [
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Enterprise IAM and SSO configuration for SAML/OIDC and EMU. (https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam)",
          "Enterprise admin portal for managing organizations and policies. (https://docs.github.com/en/enterprise-cloud@latest/admin)",
          "User SSO login flow using the configured IdP.",
          "REST API endpoints for organizations and enterprise teams. (https://docs.github.com/en/rest/orgs/orgs, https://docs.github.com/en/rest/enterprise-teams/enterprise-teams)"
        ],
        "data_accessed": [
          "SAML/OIDC assertions and identity mappings between IdP accounts and GitHub users",
          "Enterprise account metadata including the list of managed organizations",
          "Organization membership and team structures derived from SSO provisioning",
          "Repositories and other resources visible to the federated identity"
        ],
        "preconditions_required": [
          "The target enterprise uses SAML/OIDC-based SSO or Enterprise Managed Users for GitHub, and GitHub logins are tied to external IdP identities.",
          "Attacker has already compromised credentials or token material for at least one IdP account that is mapped to a GitHub user with meaningful access.",
          "SSO configuration between the IdP and GitHub Enterprise Cloud is functioning and not locked down to specific device characteristics that would prevent the attacker’s use."
        ],
        "constraints_encountered": [
          "SSO-Only Authentication – ensures all access to GitHub goes through the IdP, but this vector assumes the IdP itself has been compromised or its tokens forged.",
          "MFA Required – often enforced at the IdP; the attacker must defeat these controls upstream before GitHub will accept SSO assertions.",
          "IP Allowlisting – may exist on either the IdP or GitHub; attacker must originate SSO sessions from an allowed IP range.",
          "Admin Approval Required – some environments may require admin approval for new SSO-linked accounts or group assignments, potentially limiting which identities can be leveraged."
        ],
        "evasion_considerations": [
          "Re-use typical IdP access patterns (locations, devices) for the compromised identity when initiating GitHub SSO to avoid unusual sign-in alerts.",
          "Limit administrative changes inside GitHub initially, focusing on reconnaissance and read access to avoid obvious audit log spikes.",
          "Prefer using the REST API with standard tooling or SDKs to blend with legitimate automation that also uses SSO-backed accounts.",
          "Avoid creating obviously new GitHub organizations or massive permission changes early, which could trigger security reviews."
        ],
        "comments": "This vector follows the pattern of adversaries using compromised cloud identities to access other federated SaaS control planes, here using SSO integrations to move from an external IdP into GitHub Enterprise Cloud and its managed organizations.",
        "movement_achieved": "Lateral movement from a compromised cloud or IdP environment into GitHub Enterprise Cloud, gaining access to all organizations and repositories tied to the federated identity via SSO and enterprise account administration."
      },
      {
        "can_achieve": true,
        "technique_name": "Taint Shared Content",
        "technique_stix_id": "attack-pattern--246fd3c7-f5e3-466d-8787-4c13d9e3b61c",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify repositories or packages that are treated as shared components across many projects, such as internal libraries, shared GitHub Actions, or container images published via GitHub Packages and used by multiple repositories.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Package Management with GitHub Packages",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Web UI for browsing repositories and their dependents or references. (https://docs.github.com/en/repositories)",
              "Package views on organization and repository pages. (https://docs.github.com/en/packages)",
              "Actions marketplace and workflow references for shared actions. (https://docs.github.com/en/actions)"
            ],
            "related_data": [
              "Repositories and their metadata, including usage patterns",
              "Packages and versions across supported ecosystems",
              "Workflow definitions that reference shared actions or packages"
            ],
            "notes": "Shared libraries, actions, and images play the same role as shared network directories or binaries in traditional Taint Shared Content scenarios."
          },
          {
            "step_id": 2,
            "description": "Using existing write or maintainer access, modify code or configuration in the shared repository or package source to introduce logic that will execute in consumer contexts (for example, additional build steps, scripts, or workflow steps that run during CI/CD or runtime).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Web UI or Git CLI for editing code and configuration files. (https://docs.github.com/en/repositories)",
              "Workflow YAML files under .github/workflows, if the shared repo is an action or template. (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)"
            ],
            "related_data": [
              "Source code and configuration files in the shared repository",
              "Actions or scripts defined for reuse by other repositories"
            ],
            "notes": "The modification must preserve expected behavior to avoid immediate detection while still introducing attacker-controlled behavior."
          },
          {
            "step_id": 3,
            "description": "Publish a new version or release of the shared component (for example, tag a new release, push a new package version to GitHub Packages, or update the version referenced by reusable workflows or actions).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Package Management with GitHub Packages"
            ],
            "related_interfaces": [
              "Releases and release assets management in the repository UI. (https://docs.github.com/en/repositories)",
              "Package publishing workflows and registry interactions documented for GitHub Packages. (https://docs.github.com/en/packages/working-with-a-github-packages-registry)"
            ],
            "related_data": [
              "Releases and release assets",
              "Published package versions and metadata"
            ],
            "notes": "By publishing a new legitimate-looking version, downstream projects are encouraged (or automatically configured) to adopt the tainted content."
          },
          {
            "step_id": 4,
            "description": "As downstream repositories update to the new shared version (manually or via Dependabot or other automation), their CI/CD workflows or runtime environments execute the tainted content, giving the attacker code execution in those additional repositories’ pipelines or environments.",
            "related_capabilities": [
              "Dependency & Supply Chain Management with Dependabot",
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Dependabot configuration and update PRs for dependency versions. (https://docs.github.com/en/code-security/dependabot)",
              "Actions run history and logs in consuming repositories. (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)"
            ],
            "related_data": [
              "Automated pull requests updating dependency versions",
              "Workflow run logs and artifacts in downstream repositories"
            ],
            "notes": "This is the lateral execution step: compromised shared content is now running in many additional repositories’ contexts, including on self-hosted runners or production-like environments."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Package Management with GitHub Packages",
          "Automation with GitHub Actions (User Perspective)",
          "Dependency & Supply Chain Management with Dependabot",
          "Event-Driven Workflows with GitHub Actions Runners"
        ],
        "interfaces_used": [
          "Repository code and configuration management UI. (https://docs.github.com/en/repositories)",
          "Git CLI for pushing code and tags. (https://docs.github.com/en/get-started/git-basics/set-up-git)",
          "Package views and registry configuration for GitHub Packages. (https://docs.github.com/en/packages)",
          "Actions workflow definitions and run history. (https://docs.github.com/en/actions)",
          "Dependabot alerts and update PRs. (https://docs.github.com/en/code-security/dependabot)"
        ],
        "data_accessed": [
          "Source code and build configuration in shared repositories",
          "Package metadata and version history in GitHub Packages",
          "Releases and release assets used by downstream projects",
          "Dependency manifests and lockfiles in consumer repositories",
          "CI/CD workflow logs and artifacts in downstream repositories"
        ],
        "preconditions_required": [
          "Attacker controls or can commit to at least one shared repository or package that multiple other repositories consume (for example, a common internal library, shared action, or base container image).",
          "Downstream projects regularly consume new versions of the shared component (manually or via tools like Dependabot).",
          "Branch protection and review requirements on the shared repo either allow the attacker’s changes or can be bypassed using previously compromised reviewers or maintainers."
        ],
        "constraints_encountered": [
          "Branch protection, required reviews, and rulesets may require multiple approvals for changes to critical shared components, making unauthorized tainting more difficult.",
          "Code scanning, secret scanning, and other security pipelines may flag obviously malicious modifications or unusual behavior in new versions.",
          "Rate of dependency updates in downstream repos may be slow, delaying or limiting the spread of tainted versions.",
          "MFA and SSO controls apply to the account that modifies the shared repo, but once changes are merged the shared content is trusted by default in consuming contexts."
        ],
        "evasion_considerations": [
          "Introduce subtle, staged functionality in the shared content rather than overt malicious behavior to avoid immediate code review rejection.",
          "Maintain compatibility and expected functionality so that dependency updates do not cause functional regressions that would trigger rollbacks.",
          "Align versioning and changelogs with normal project practice to avoid raising suspicion when new versions are published.",
          "Use small, targeted changes in build scripts or actions rather than large code rewrites that attract reviewer attention."
        ],
        "comments": "This vector mirrors traditional Taint Shared Content on network drives or shared binaries, adapted to GitHub’s shared libraries, actions, and packages that are pulled into many repositories and executed in CI/CD or runtime contexts.",
        "movement_achieved": "Propagation of attacker-controlled logic from a single compromised shared repository or package into many consuming repositories and their execution environments, enabling code execution and further pivots wherever the tainted content is used."
      },
      {
        "can_achieve": true,
        "technique_name": "Internal Spearphishing",
        "technique_stix_id": "attack-pattern--9e7452df-5144-4b6e-b04a-b66dd4016747",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Enumerate high-value users inside the GitHub organizations (such as organization owners, security managers, or repository admins) using member lists, teams, and commit/review activity to identify attractive targets for further compromise.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Organization members and teams views in the web UI. (https://docs.github.com/en/organizations)",
              "REST API endpoints for organization members and teams. (https://docs.github.com/en/rest/orgs/orgs, https://docs.github.com/en/rest/teams/teams)",
              "Repository contributors and activity views. (https://docs.github.com/en/repositories)"
            ],
            "related_data": [
              "Organization membership lists and roles",
              "Team hierarchies and maintainers",
              "Repository collaborator and contributor information"
            ],
            "notes": "Past campaigns show adversaries preferentially targeting internal administrators and technical staff for spearphishing to gain broader access."
          },
          {
            "step_id": 2,
            "description": "From the compromised account, craft plausible issues, pull requests, or review comments that mention or assign these high-value users, embedding links to attacker-controlled resources or instructions that encourage victims to perform risky actions (such as running unvetted scripts).",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Issues tab and issue creation UI in repositories. (https://docs.github.com/en/issues)",
              "Pull request creation and review UIs. (https://docs.github.com/en/pull-requests)",
              "REST API endpoints for issues and pull requests. (https://docs.github.com/en/rest/issues/issues, https://docs.github.com/en/rest/pulls/pulls)"
            ],
            "related_data": [
              "Issues, PRs, and their bodies and comments",
              "Mentions and assignments that generate notifications",
              "Links embedded in issue and PR content"
            ],
            "notes": "Because these communications originate from a legitimate internal GitHub account, they are more likely to be trusted by recipients."
          },
          {
            "step_id": 3,
            "description": "Rely on GitHub’s notification mechanisms (email, in-app notifications, and any configured webhooks) to deliver these messages to the targeted users, who will see them as normal repository activity.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "GitHub notifications generated by issues, PRs, and mentions (email and in-app).",
              "Webhook configuration that forwards events like issues and PRs to chat or ticketing systems. (https://docs.github.com/en/webhooks)"
            ],
            "related_data": [
              "Notification payloads containing the crafted messages",
              "Webhook event payloads containing issue/PR content and links"
            ],
            "notes": "This step leverages the trusted internal communication channels of GitHub as the spearphishing delivery vector."
          },
          {
            "step_id": 4,
            "description": "If targeted users follow malicious links or instructions outside GitHub (for example, to a phishing site that mimics GitHub’s login), their credentials or tokens may be captured, enabling compromise of additional accounts and thus further lateral movement within GitHub.",
            "related_capabilities": [
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "User authentication endpoints for GitHub (as mimicked off-platform).",
              "Email-based notifications that direct users to the crafted content."
            ],
            "related_data": [
              "Usernames, passwords, and potential second-factor data entered into phishing pages (captured off GitHub)",
              "Newly compromised credentials used later as Valid Accounts or application access tokens"
            ],
            "notes": "The credential capture itself occurs off the GitHub platform, but GitHub’s issues and PRs act as the trusted internal spearphishing medium."
          }
        ],
        "capabilities_used": [
          "Issue Tracking & Work Management with GitHub Issues",
          "Pull Requests & Code Review Workflow",
          "Organization & Team Administration",
          "Webhook Event Delivery",
          "Authentication & Account Security Management",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Issues UI and related REST APIs. (https://docs.github.com/en/issues, https://docs.github.com/en/rest/issues/issues)",
          "Pull request creation and review UI and APIs. (https://docs.github.com/en/pull-requests, https://docs.github.com/en/rest/pulls/pulls)",
          "Organization members and teams management UI. (https://docs.github.com/en/organizations)",
          "Webhook configuration UI and API for forwarding events to external systems. (https://docs.github.com/en/webhooks, https://docs.github.com/en/rest/orgs/webhooks)",
          "User authentication and account security management UI. (https://docs.github.com/en/authentication)"
        ],
        "data_accessed": [
          "Identifiers and roles of high-value organization members and maintainers",
          "Issues, pull requests, and comments used as message carriers",
          "Notification payloads and webhook events that disseminate messages",
          "Credentials and tokens of newly phished users (captured off-platform but used to access GitHub)"
        ],
        "preconditions_required": [
          "Attacker already controls at least one valid GitHub account within the target organization (via prior compromise or malicious onboarding).",
          "Target organization members routinely rely on GitHub notifications and issue/PR workflows for collaboration.",
          "Links to external resources in issues and PRs are not strictly blocked or heavily filtered by policy or tooling."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication increase difficulty of successfully reusing phished passwords alone; attackers may need to capture tokens or session cookies as well.",
          "Rate Limiting and CAPTCHA Protection on authentication endpoints may limit large-scale credential stuffing, but targeted spearphishing with manual follow-up is typically unaffected.",
          "Security awareness and training may make some users suspicious of unexpected links or scripts in issues and PRs.",
          "Email filtering or link rewriting by corporate email gateways may partially mitigate some phishing links delivered via GitHub notifications."
        ],
        "evasion_considerations": [
          "Align spearphishing content with ongoing projects and use realistic technical language so issues and PRs appear credible.",
          "Target a small number of high-value users rather than broad spam to reduce suspicion and logging anomalies.",
          "Embed links or instructions in the context of normal collaboration (for example, \"Please test this patch by cloning from this private mirror\"), leveraging existing trust relationships.",
          "Avoid obviously malicious filenames or URLs; use infrastructure that mimics legitimate GitHub or internal tooling domains."
        ],
        "comments": "This vector repurposes GitHub’s own collaboration workflows (issues, PRs, comments, notifications) as an internal spearphishing channel to compromise additional developer or admin accounts, similar to adversary use of internal email or chat in other environments.",
        "movement_achieved": "Potential compromise of additional developer, maintainer, and administrator accounts inside the same GitHub organization or enterprise, using GitHub’s trusted internal communication channels to deliver targeted spearphishing content."
      }
    ],
    "summary": "Within GitHub, lateral movement is realistically achievable through several distinct but complementary methods. Compromised application access tokens (PATs, GitHub App tokens) allow attackers to enumerate and act across all organizations and repositories the token’s identity can access, while stolen alternate authentication material (other users’ tokens, SSH keys, deploy keys) enables pivots across multiple identities and their respective repos. Stolen web session cookies can bypass MFA and SSO to immediately inherit a user’s full GitHub access via the web UI. GitHub Actions workflows and their runners function as powerful software deployment tools that can be repurposed to execute code in external infrastructure reachable from the runners. SSO integrations let attackers move from compromised IdP identities into GitHub Enterprise Cloud organizations via cloud-services-style lateral movement. Shared repositories, packages, and actions can be tainted so that downstream projects execute attacker-controlled content, spreading compromise through the software supply chain. Finally, GitHub’s collaboration surfaces—issues, pull requests, and notifications—can be abused for internal spearphishing to compromise additional high-value GitHub accounts. Environment constraints like MFA, SSO-only authentication, IP allowlisting, rate limiting, and security scanning primarily hinder the acquisition of credentials and large-scale abuse, but they do not fundamentally prevent these lateral movement vectors once valid tokens, sessions, or privileged accounts have been obtained."
  },
  "collection": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Code Repositories",
        "technique_stix_id": "attack-pattern--cff94884-3b1c-4987-a70b-6d5643c621c3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Authenticate to GitHub using a compromised user account, personal access token (PAT), fine-grained token, or SSH key that has at least read access to the target organizations and repositories, satisfying any SSO and MFA requirements.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Organization & Team Administration",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "User account security settings UI (authentication docs)",
              "Git over HTTPS/SSH remote authentication",
              "REST API authentication mechanisms (REST auth docs)"
            ],
            "related_data": [
              "User identities and account metadata",
              "Authentication credentials (PATs, SSH keys, fine-grained tokens)",
              "Repository visibility and collaborator permissions"
            ],
            "notes": "Environmental constraints such as MFA, SSO-only authentication, domain-based registration, email verification, and admin approval must already be satisfied by the compromised identity."
          },
          {
            "step_id": 2,
            "description": "Enumerate all repositories the identity can access, using the organization and repository list views in the web UI or REST API endpoints such as /user/repos and /orgs/{org}/repos.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization repositories list in the web UI (Repositories docs)",
              "REST API: /user/repos, /orgs/{org}/repos (REST API index)"
            ],
            "related_data": [
              "Repositories and repository metadata",
              "Repository visibility and collaborator permissions",
              "Organization accounts and profiles"
            ],
            "notes": "This mirrors real-world adversary behavior where groups like LAPSUS$ and APT29 have first enumerated accessible GitHub/GitLab repositories before downloading code."
          },
          {
            "step_id": 3,
            "description": "For each target repository, use Git over HTTPS/SSH (or the web UI \"Download ZIP\" feature) to clone or download the full repository, including all branches and tags.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Git remote access over HTTPS/SSH (Git basics docs)",
              "Repository web UI clone/download controls (Repositories docs)"
            ],
            "related_data": [
              "Files, blobs, and trees (source code and other content)",
              "Commits, branches, and tags",
              "Repository rulesets and branch protection configuration"
            ],
            "notes": "Cloning provides a complete local copy of all history that the identity can read, similar to how APT41 and APT29 have cloned victim Git repositories."
          },
          {
            "step_id": 4,
            "description": "Retrieve additional metadata and packaged artifacts by querying repository REST endpoints for branches, tags, and releases, and downloading any release assets (binaries, archives).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "REST API: /repos/{owner}/{repo}/branches, /tags, /releases, /releases/assets",
              "Repository Releases tab in the web UI"
            ],
            "related_data": [
              "Commits, branches, and tags",
              "Releases and release assets",
              "Repository metadata (descriptions, topics, default branches)"
            ],
            "notes": "Release assets often contain production-ready binaries or deployment artifacts which may be more sensitive than raw source."
          },
          {
            "step_id": 5,
            "description": "Iterate this process across all organizations and repositories the identity can access, prioritizing private and internal repositories or those matching high-value naming patterns (e.g., \"prod\", \"infra\", \"secrets\").",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization and repository listing UIs",
              "REST API: /user/orgs, /orgs, /orgs/{org}/repos"
            ],
            "related_data": [
              "Repositories and repository metadata",
              "Files, blobs, and trees",
              "Commits, branches, and tags"
            ],
            "notes": "Organization- and team-level permissions determine the ultimate breadth of code that can be collected with this method."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "Authentication & Account Security Management",
          "Organization & Team Administration"
        ],
        "interfaces_used": [
          "Repository web UI for browsing and downloading code (Repositories docs)",
          "Git over HTTPS/SSH remotes for cloning and fetching (Git basics docs)",
          "REST API /repos family of endpoints for repository metadata, branches, tags, and releases (REST API docs)"
        ],
        "data_accessed": [
          "Repositories and repository metadata",
          "Files, blobs, and trees (full repository content)",
          "Commits, branches, and tags",
          "Releases and release assets",
          "Repository visibility and collaborator permissions"
        ],
        "preconditions_required": [
          "Compromised GitHub user account or token with at least read access to target repositories.",
          "If SSO-only authentication is enforced, the compromised identity must already be provisioned in the IdP and able to obtain valid GitHub sessions/tokens.",
          "If MFA is required, the attacker must have satisfied MFA for the sessions/tokens they are using.",
          "If domain-based registration or admin approval is enforced, the compromised account must have already completed those processes.",
          "If IP allowlisting is in place, the attacker must operate from an allowed IP range (for example, via corporate VPN or a compromised host inside the allowlist)."
        ],
        "constraints_encountered": [
          "MFA Required – inhibits direct password-only access; attacker must rely on already-enrolled accounts/tokens and may face re-authentication prompts during sensitive UI operations.",
          "SSO-Only Authentication – prevents creation of arbitrary standalone accounts; attacker is limited to identities in the organization’s IdP.",
          "IP Allowlisting – Git, UI, and REST access may only work from approved IP ranges, forcing the attacker to pivot through allowed infrastructure.",
          "Rate Limiting – high-volume REST enumeration of repositories, branches, tags, and releases is constrained by per-token and per-IP limits."
        ],
        "evasion_considerations": [
          "Favor Git cloning/fetching (a common developer activity) over heavy REST content downloads to blend into normal traffic.",
          "Throttle API calls and cloning operations to remain within rate limits and avoid conspicuous bursts of activity.",
          "Stage repository downloads over time and across multiple identities/tokens rather than mirroring everything at once.",
          "Name any additional access tokens in a way that appears consistent with normal developer tooling (e.g., \"CI backup\"), reducing suspicion during credential reviews."
        ],
        "comments": "This is the most direct and common collection path for GitHub: adversaries such as APT29, APT41, and LAPSUS$ have all targeted and downloaded code repositories after gaining valid access.",
        "data_collected": "Complete working copies and histories of all accessible repositories, including source code, configuration files, documentation, commit history, branches, tags, and any associated release binaries or archives."
      },
      {
        "can_achieve": true,
        "technique_name": "Automated Collection",
        "technique_stix_id": "attack-pattern--30208d3e-0d6b-43c8-883e-44462a514619",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain or create an API credential suitable for broad read access, such as a fine-grained personal access token scoped to repositories and security data, or a GitHub App installation token with read permissions across many repositories and organizations.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API",
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "User security settings UI for PAT/fine-grained token creation",
              "GitHub Apps registration and installation management UIs",
              "REST API authentication flows (REST auth docs)"
            ],
            "related_data": [
              "Authentication credentials (PATs, fine-grained tokens, GitHub App tokens)",
              "App registrations and metadata",
              "Installation records across users and organizations"
            ],
            "notes": "This mirrors how real intrusions abuse powerful automation credentials to systematically collect data from cloud/SaaS APIs."
          },
          {
            "step_id": 2,
            "description": "Use the REST API to enumerate the scope of accessible organizations and repositories, for example with /user/orgs to list organizations and /orgs/{org}/repos to list all repos in each organization.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "API Gateway & REST Layer"
            ],
            "related_interfaces": [
              "REST API: /user/orgs, /orgs, /orgs/{org}/repos",
              "REST API overview and pagination mechanisms"
            ],
            "related_data": [
              "List of organizations and their settings",
              "Repositories and repository metadata",
              "Organization members and roles"
            ],
            "notes": null
          },
          {
            "step_id": 3,
            "description": "Programmatically iterate over each repository and call REST endpoints for key resource types—such as issues (/issues), pull requests (/pulls), contents or trees (/contents, /git/trees?recursive=1), Actions workflows and runs (/actions/workflows, /actions/runs), and security alerts (/code-scanning/alerts, /dependabot/alerts, /secret-scanning/alerts)—storing the responses in an attacker-controlled data store.",
            "related_capabilities": [
              "GitHub REST API",
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "REST API: /repos/{owner}/{repo}/issues, /pulls, /contents, /git/trees",
              "REST API: /repos/{owner}/{repo}/actions/workflows, /actions/runs",
              "REST API: /repos/{owner}/{repo}/code-scanning/alerts, /dependabot/alerts, /secret-scanning/alerts"
            ],
            "related_data": [
              "Issues, pull requests, and associated comments",
              "Repository source trees and file metadata",
              "Actions workflows, run metadata, logs indices, and artifacts indices",
              "Code scanning, Dependabot, and secret scanning alerts"
            ],
            "notes": "This step turns the REST API into a generalized data-harvesting pipeline across all reachable repositories."
          },
          {
            "step_id": 4,
            "description": "Automate periodic collection by scheduling the enumeration script externally (for example via cron) or by defining a GitHub Actions workflow in a dedicated repository that runs on a schedule (on: schedule) and uses a stored PAT or GITHUB_TOKEN to call the REST API and write aggregated snapshots into workflow artifacts or a separate archival repository.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Workflow YAML under .github/workflows configured with schedule triggers",
              "Actions UI and REST API for workflow runs and artifacts"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Job execution logs and artifacts containing collected JSON/CSV data",
              "Aggregated exports of repositories, issues, PRs, and security alerts"
            ],
            "notes": "This pattern is analogous to malware like Rover or Micropsia periodically scanning for and archiving matching files, but realized via cloud APIs and CI workflows rather than local filesystem scans."
          },
          {
            "step_id": 5,
            "description": "Optionally use a GitHub App webhook to receive event-driven updates (push, issues, pull_request, workflow_run) and have the collection logic only request detailed data for resources referenced in those events, reducing API volume while maintaining near real-time coverage.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub App webhook configuration and event handling (Apps docs)",
              "Webhook events and payloads reference",
              "REST API: follow-up calls to repos, issues, pulls, actions, and security endpoints based on event payloads"
            ],
            "related_data": [
              "Webhook event payloads referencing repositories, issues, pull requests, and workflow runs",
              "Incremental updates to already-collected datasets"
            ],
            "notes": null
          }
        ],
        "capabilities_used": [
          "GitHub REST API",
          "GitHub Apps & OAuth Apps Platform",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management",
          "API Gateway & REST Layer",
          "Webhook Event Delivery"
        ],
        "interfaces_used": [
          "REST API: /user/orgs, /orgs, /orgs/{org}/repos and other resource categories (REST API docs)",
          "GitHub Apps registration, permissions, and installation interfaces (Apps platform docs)",
          "Actions workflows and scheduled runs (Actions concepts and workflow syntax docs)",
          "Webhook and GitHub App webhook delivery to external endpoints (Webhooks and Apps docs)"
        ],
        "data_accessed": [
          "Repositories and repository metadata",
          "Issues, pull requests, comments, and project items",
          "Actions workflows, runs, logs indexes, and artifacts indexes",
          "Code scanning, Dependabot, and secret scanning alerts",
          "Organization and team structures",
          "Billing and usage metrics where token scopes allow access"
        ],
        "preconditions_required": [
          "At least one compromised identity (user or GitHub App) with token scopes that permit reading targeted resources (repositories, issues, PRs, security alerts, etc.).",
          "If SSO-only authentication and MFA are enforced, the attacker must already possess a valid SSO-backed account and usable tokens.",
          "If IP allowlisting is applied to the tenant or API, the automated collection must run from an allowed IP range or from GitHub-hosted infrastructure (for example, Actions runners) that is implicitly trusted.",
          "Organization or enterprise policies must allow the creation or use of GitHub Apps and/or Actions workflows in at least one repository controlled by the attacker."
        ],
        "constraints_encountered": [
          "Rate Limiting – high-volume, cross-org enumeration via REST API must respect per-token and per-IP rate limits; bursty collection risks throttling.",
          "IP Allowlisting – API calls originating from unapproved networks will be rejected, forcing the actor to run collectors from allowed networks or from within GitHub Actions.",
          "MFA Required and SSO-Only Authentication – restrict creation and use of new high-privilege user accounts; attackers generally must re-use existing privileged identities.",
          "CAPTCHA Protection – may make fully automated login flows harder if the actor tries to acquire new tokens via UI rather than using already-issued tokens."
        ],
        "evasion_considerations": [
          "Implement back-off and jitter in the automation to stay below API rate-limit thresholds and mimic typical integration behavior.",
          "Scope GitHub App permissions narrowly and use benign naming to resemble legitimate tooling, reducing the chance of administrative revocation.",
          "Distribute collection work across multiple tokens or app installations associated with different teams or service accounts to avoid concentration of activity in one credential.",
          "Leverage event-driven collection (via webhooks) to limit full scans and make activity patterns look like normal integration behavior instead of broad scraping."
        ],
        "comments": "This vector translates classic automated file collection (as in T9000/Micropsia) into the GitHub SaaS context by using REST APIs, GitHub Apps, and Actions workflows to continuously and systematically harvest data.",
        "data_collected": "Large-scale, regularly refreshed datasets of all GitHub resources visible to the compromised identity—including repositories, issues, pull requests, workflows, and security alerts—aggregated via scripted API access and optionally stored in workflow artifacts or attacker-controlled archives."
      },
      {
        "can_achieve": true,
        "technique_name": "Data from Information Repositories",
        "technique_stix_id": "attack-pattern--d28ef391-8ed4-45dc-bc4a-2f43abf54416",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify the repositories and organizations whose work management data (issues, pull requests, projects) is of interest, using the web UI or REST APIs to list repositories and visible projects.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Project Planning & Reporting with GitHub Projects",
              "Pull Requests & Code Review Workflow",
              "GitHub REST API",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository Issues and Pull requests tabs in the web UI",
              "Projects views in the web UI (table/board/roadmap)",
              "REST API: /repos/{owner}/{repo}/issues, /pulls, /projects"
            ],
            "related_data": [
              "Issues and their titles, bodies, states, and comments",
              "Pull requests and review metadata",
              "Project items and custom fields",
              "Organization accounts and repository metadata"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Enumerate and export issues by calling /repos/{owner}/{repo}/issues with state=all (and appropriate filters) or by using the Issues UI/CLI to list all issues, then serializing the results (titles, bodies, labels, assignees, milestones, comments) into files or a database.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "REST API: /repos/{owner}/{repo}/issues",
              "GitHub CLI issue listing commands (GitHub CLI docs)",
              "Issues tab in the web UI"
            ],
            "related_data": [
              "Issue records (titles, bodies, labels, milestones, assignees)",
              "Comments and reactions",
              "Linked pull requests and metadata"
            ],
            "notes": "Issues often contain operational details, incident timelines, and sometimes sensitive design or security information."
          },
          {
            "step_id": 3,
            "description": "Enumerate and export pull requests by calling /repos/{owner}/{repo}/pulls with state=all, capturing PR descriptions, associated branches and commits, review comments, and review states.",
            "related_capabilities": [
              "Pull Requests & Code Review Workflow",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "REST API: /repos/{owner}/{repo}/pulls",
              "Pull requests tab in the web UI"
            ],
            "related_data": [
              "Pull request metadata (titles, descriptions, branches)",
              "Review comments and review states",
              "Merged/closed/open state and timestamps"
            ],
            "notes": "PR descriptions and review discussions can reveal design decisions, known weaknesses, and links to external systems."
          },
          {
            "step_id": 4,
            "description": "List and export Projects data using the Projects REST APIs and/or the Projects web UI export feature, retrieving project items (issues, PRs, draft items), custom fields, and views to build a consolidated picture of work planning across repositories.",
            "related_capabilities": [
              "Project Planning & Reporting with GitHub Projects",
              "Projects & Codespaces Automation and Prebuilds (Projects automation)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Projects UI views and export functionality",
              "REST API: /projects endpoints and related project item APIs"
            ],
            "related_data": [
              "Project items and custom fields",
              "Project views and filters",
              "Charts and insights derived from project data"
            ],
            "notes": "Project exports naturally aggregate issue/PR metadata and are an efficient way to collect planning and roadmap information."
          },
          {
            "step_id": 5,
            "description": "Optionally configure repository or organization webhooks (or a GitHub App) subscribed to issues, pull_request, and project events so that incremental changes are continuously delivered to an attacker-controlled endpoint for near real-time updates.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub Apps & OAuth Apps Platform",
              "Issue Tracking & Work Management with GitHub Issues",
              "Project Planning & Reporting with GitHub Projects",
              "Pull Requests & Code Review Workflow"
            ],
            "related_interfaces": [
              "Webhook configuration UIs at repo/org scope",
              "REST API: /orgs/{org}/webhooks and related endpoints",
              "GitHub App webhooks and event handling (Apps docs)"
            ],
            "related_data": [
              "Webhook event payloads for issues, pull requests, and project changes",
              "Incremental deltas to issues/PRs/projects collected in earlier steps"
            ],
            "notes": "This turns static exports into a continuously updated dataset of collaboration activity."
          }
        ],
        "capabilities_used": [
          "Issue Tracking & Work Management with GitHub Issues",
          "Project Planning & Reporting with GitHub Projects",
          "Pull Requests & Code Review Workflow",
          "GitHub REST API",
          "Webhook Event Delivery",
          "GitHub Apps & OAuth Apps Platform",
          "Projects & Codespaces Automation and Prebuilds",
          "Organization & Team Administration",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Issues, Pull requests, and Projects tabs in the web UI (Issues and Projects docs)",
          "REST API: /repos/{owner}/{repo}/issues, /pulls, and /projects (REST API docs)",
          "GitHub CLI commands for listing issues and pull requests (GitHub CLI docs)",
          "Repository/organization webhooks and GitHub App webhooks for issues/pull_request/project events (Webhooks and Apps docs)"
        ],
        "data_accessed": [
          "Issues (titles, bodies, states, labels, milestones, assignees, comments, linked PRs)",
          "Pull requests (metadata, diffs, review comments, approvals, merge states)",
          "Project items, custom fields, and views",
          "Webhook payloads capturing ongoing collaboration changes"
        ],
        "preconditions_required": [
          "A compromised account or token with read access to the target repositories and projects (via collaborator status, team membership, or organization base permissions).",
          "If organization/project visibility is restricted, the account must be a member of the organization or teams that can view those projects.",
          "Permissions to configure webhooks or install GitHub Apps if continuous, event-based collection is desired.",
          "Compliance with any existing SSO, MFA, and IP allowlisting controls for the compromised identity."
        ],
        "constraints_encountered": [
          "Rate Limiting – bulk listing of issues, pull requests, and project items across many repositories must be paginated and paced.",
          "IP Allowlisting – REST and webhook configuration may only be possible from approved IP ranges; webhook destinations may also be scrutinized.",
          "MFA Required and SSO-Only Authentication – constrain who can log into organization/project UIs to perform exports or configure automation.",
          "Admin Approval Required – can limit the creation of new user accounts that might otherwise be used to stage large-scale collection."
        ],
        "evasion_considerations": [
          "Use standard REST API patterns and official SDKs (for example, Octokit) so traffic resembles normal reporting or analytics tooling.",
          "Throttle exports and respect pagination to avoid noticeable spikes in API usage or webhook creation.",
          "Name webhooks, apps, and tokens to look like legitimate integrations (for example, \"Reporting dashboard\") aligned with typical org practices.",
          "Leverage Projects export and filtered views to collect high-value planning data in a few large exports, rather than many fine-grained calls."
        ],
        "comments": "GitHub Issues, PRs, and Projects act as rich information repositories; adversaries have similarly targeted enterprise databases and documentation systems in other campaigns to mine operational and security-relevant data.",
        "data_collected": "Comprehensive records of issues, pull requests, and project planning data—including discussion history, work status, and cross-references—sufficient to reconstruct development workflows, incident timelines, and roadmaps."
      },
      {
        "can_achieve": true,
        "technique_name": "Data from Information Repositories",
        "technique_stix_id": "attack-pattern--d28ef391-8ed4-45dc-bc4a-2f43abf54416",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Gain access—via a compromised security engineer, organization owner, or similarly privileged identity—to repositories and organization security centers where code scanning, Dependabot, and secret scanning alerts are visible.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection",
              "Organization & Team Administration",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Repository and organization Security tabs in the web UI",
              "Org-level security center and risk assessment views (Securing your organization docs)"
            ],
            "related_data": [
              "Code scanning alerts and SARIF-derived metadata",
              "Dependabot security alerts and advisory data",
              "Secret scanning alerts and detected secret metadata",
              "Security configurations and risk assessments"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Enumerate code scanning alerts for each target repository via the Security tab and via REST API endpoints such as /repos/{owner}/{repo}/code-scanning/alerts, capturing vulnerability types, severities, locations, and triage states.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Security tab: Code scanning alerts view",
              "REST API: /repos/{owner}/{repo}/code-scanning/alerts"
            ],
            "related_data": [
              "Code scanning alerts and SARIF references",
              "Repository and branch metadata linked to each alert"
            ],
            "notes": "These alerts highlight precisely where known vulnerabilities exist in code, aiding follow-on exploitation or extortion."
          },
          {
            "step_id": 3,
            "description": "List Dependabot security alerts for dependencies across repositories using the Dependabot security UI and REST API endpoints under /repos/{owner}/{repo}/dependabot/alerts, retaining details on affected packages, versions, severities, and any associated remediation PRs.",
            "related_capabilities": [
              "Dependency & Supply Chain Management with Dependabot",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Security alerts views for Dependabot (web UI)",
              "REST API: Dependabot alerts endpoints"
            ],
            "related_data": [
              "Dependabot alerts and vulnerability advisories",
              "Automated remediation pull requests and their status"
            ],
            "notes": null
          },
          {
            "step_id": 4,
            "description": "Enumerate secret scanning alerts and push protection events using the repository/org Security tab and REST API endpoints like /repos/{owner}/{repo}/secret-scanning/alerts, capturing secret types, locations in history, and alert/bypass states.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Secret scanning alert views in the Security tab",
              "REST API: /repos/{owner}/{repo}/secret-scanning/alerts"
            ],
            "related_data": [
              "Detected secret tokens and metadata",
              "Push protection configuration and bypass decision data"
            ],
            "notes": "This produces a concentrated index of credentials and secrets that have been exposed in code, even if later remediated."
          },
          {
            "step_id": 5,
            "description": "Query organization-scale security configuration and risk data using the org security center UI and REST API endpoints for code security configurations to collect which repositories have code scanning, Dependabot, and secret scanning enabled or disabled, and to export secret risk assessments and vulnerability exposure metrics.",
            "related_capabilities": [
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Org security center and configuration pages (Securing your organization docs)",
              "REST API: /orgs/{org}/code-security/configurations"
            ],
            "related_data": [
              "Security configurations per repository",
              "Secret risk assessment reports",
              "Vulnerability exposure metrics and campaign progress"
            ],
            "notes": "This yields a high-level map of where defenses are weak or disabled, similar to how attackers harvest database schemas and user accounts in other environments."
          },
          {
            "step_id": 6,
            "description": "Optionally register security-related webhooks (or a GitHub App) to receive events tied to security alerts and configuration changes, enabling continuous updates to the collected dataset.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub Apps & OAuth Apps Platform",
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "Webhook configuration UI at repo/org/enterprise scope",
              "Webhook events and payloads for security-related events",
              "GitHub App webhook handling"
            ],
            "related_data": [
              "Security-related webhook event payloads",
              "Incremental updates to alerts and configurations"
            ],
            "notes": null
          }
        ],
        "capabilities_used": [
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection",
          "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines",
          "Automated Dependency & Security Remediation Jobs",
          "GitHub REST API",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Authentication & Account Security Management",
          "Webhook Event Delivery",
          "GitHub Apps & OAuth Apps Platform"
        ],
        "interfaces_used": [
          "Repository and organization Security tabs (Code scanning, Dependabot, Secret scanning UIs)",
          "Org-level security center and risk assessment pages (Securing your organization docs)",
          "REST API: /code-scanning/code-scanning, /dependabot/alerts, /secret-scanning/secret-scanning, /code-security/configurations",
          "Security-related webhooks and GitHub App webhooks"
        ],
        "data_accessed": [
          "Code scanning alerts and SARIF-derived analysis results",
          "Dependabot security alerts and linked vulnerability advisories",
          "Secret scanning alerts, detected secret types, locations, and bypass records",
          "Security configurations, secret risk assessments, vulnerability exposure metrics, and campaign status"
        ],
        "preconditions_required": [
          "A compromised account or token with rights to view repository/org security alerts (often maintainer, admin, or security manager roles).",
          "Org- or enterprise-level security center access if organization-scale configuration and risk data is to be collected.",
          "Valid authentication under any enforced SSO/MFA controls, and operation from an allowed IP range if IP allowlisting is active.",
          "Optionally, permissions to configure security-related webhooks or install GitHub Apps for continuous updates."
        ],
        "constraints_encountered": [
          "Access Control – security alerts and org-level security data are restricted to higher-privilege roles; ordinary read-only collaborators may not see all information.",
          "Rate Limiting – bulk API retrieval of alerts across many repositories must handle pagination and throttling.",
          "MFA Required and SSO-Only Authentication – raise the bar for compromising accounts with security-center visibility.",
          "IP Allowlisting – may restrict where security APIs can be invoked from, especially for org- and enterprise-scoped endpoints."
        ],
        "evasion_considerations": [
          "Blend security API usage into normal patterns, for example querying alerts in sizes and intervals similar to common SIEM or risk-reporting integrations.",
          "Focus initial collection on a subset of high-value repositories to avoid sudden, organization-wide spikes in security API calls.",
          "Use GitHub Apps with appropriate, limited-looking permissions rather than PATs for broad security data access, as apps are common in security tooling.",
          "If using webhooks, re-use existing logging or SIEM endpoints where possible instead of creating obviously new destinations."
        ],
        "comments": "This vector leverages GitHub’s own security and risk dashboards as high-value information repositories, turning defensive telemetry into an offensive map of vulnerabilities, secrets, and misconfigurations.",
        "data_collected": "Detailed datasets of all code scanning, dependency, and secret-related security alerts plus organization-scale security configuration and risk reports, enabling a consolidated view of where code and secrets are most exposed."
      },
      {
        "can_achieve": true,
        "technique_name": "Data from Information Repositories",
        "technique_stix_id": "attack-pattern--d28ef391-8ed4-45dc-bc4a-2f43abf54416",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify repositories where GitHub Actions is enabled and that are likely to handle sensitive workloads (for example, CI/CD for production, deployment pipelines, or security scans) by reviewing repository settings and the Actions tab.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Actions tab in repository UI",
              "Repository settings related to Actions enablement"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Job execution metadata and logs"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Use the REST API or Actions UI to enumerate workflows in each target repository (for example, /repos/{owner}/{repo}/actions/workflows) and then list their runs via /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs.",
            "related_capabilities": [
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "REST API: /actions/workflows and /actions/workflows/{workflow_id}/runs",
              "Actions run history UI"
            ],
            "related_data": [
              "Workflow metadata",
              "Lists of workflow runs with status, start/end times, and triggering events"
            ],
            "notes": null
          },
          {
            "step_id": 3,
            "description": "For each workflow run, download the run logs via /repos/{owner}/{repo}/actions/runs/{run_id}/logs and inspect them for environment details, command outputs, configuration values, and any secrets that may have been inadvertently written to logs.",
            "related_capabilities": [
              "GitHub REST API",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Actions Artifacts & Logs Storage"
            ],
            "related_interfaces": [
              "REST API: /actions/runs/{run_id}/logs",
              "Actions run logs download in the UI"
            ],
            "related_data": [
              "Job execution logs",
              "Environment and runner metadata",
              "Command outputs and error messages"
            ],
            "notes": "Build/test scripts and deployment steps often echo configuration values and, in misconfigured workflows, secrets such as tokens or passwords."
          },
          {
            "step_id": 4,
            "description": "Enumerate and download workflow artifacts for each run using /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts and subsequent artifact download endpoints, collecting build outputs, test reports, and any archives of source or configuration that workflows have produced.",
            "related_capabilities": [
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)",
              "Actions Artifacts & Logs Storage"
            ],
            "related_interfaces": [
              "REST API: /actions/runs/{run_id}/artifacts and artifact download URLs",
              "Artifacts panel in the Actions run UI"
            ],
            "related_data": [
              "Build artifacts (binaries, archives, configuration bundles)",
              "Test and coverage reports",
              "Log bundles and diagnostic dumps"
            ],
            "notes": "Artifacts may contain compiled production binaries, deployment manifests, and sometimes snapshots of repository content."
          },
          {
            "step_id": 5,
            "description": "Optionally add or modify a workflow (if the attacker has write/maintainer access) that reads data from Actions caches or other on-runner storage and writes it into artifacts or logs, effectively turning caches into another information repository accessible via the same interfaces.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Workflow YAML under .github/workflows",
              "Actions run logs and artifacts UI/APIs"
            ],
            "related_data": [
              "Actions caches and intermediate build artifacts",
              "Additional filesystem data exposed by the new workflow"
            ],
            "notes": "This step overlaps with automated collection; it converts transient runner data into persistent, centrally accessible artifacts."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "GitHub REST API",
          "Actions Artifacts & Logs Storage",
          "Organization & Team Administration",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Actions tab for workflow and run history (Actions docs)",
          "REST API: /actions/workflows and /actions/workflow-runs (REST Actions docs)",
          "REST API: /actions/runs/{run_id}/logs and /actions/runs/{run_id}/artifacts",
          "Workflow YAML under .github/workflows"
        ],
        "data_accessed": [
          "Workflow definitions (YAML) describing build/test/deploy pipelines",
          "Workflow run metadata (status, initiator, environment details)",
          "Workflow logs containing command outputs and environment information",
          "Artifacts and, indirectly, caches generated by workflows"
        ],
        "preconditions_required": [
          "A compromised identity with at least read access to Actions runs in the target repositories (usually anyone with repo read access if Actions is enabled).",
          "If the attacker intends to modify or add workflows to expose caches, they need write or maintainer-level access to the repository.",
          "Valid authentication under any SSO/MFA requirements and operation from an allowed IP range if IP allowlisting applies.",
          "Actions must be enabled for the target repositories by organization/enterprise policy."
        ],
        "constraints_encountered": [
          "Organization or enterprise policies may restrict Actions usage or limit which repositories can run workflows, reducing available data.",
          "Rate Limiting – large-scale retrieval of logs and artifacts via REST must adhere to API quotas.",
          "IP Allowlisting – may prevent direct download of logs/artifacts from non-approved networks.",
          "MFA and SSO enforcement can make it harder to compromise the higher-privilege accounts needed to edit workflows."
        ],
        "evasion_considerations": [
          "Focus on repositories where Actions is already heavily used so additional log and artifact access looks routine.",
          "Use API pagination and moderate download rates to avoid triggering abnormal bandwidth or API-usage alarms.",
          "If modifying workflows, embed data-collection steps into existing pipelines with innocuous names (for example, additional test or diagnostics steps).",
          "Rely primarily on reading existing logs/artifacts instead of creating conspicuously new workflows whenever possible."
        ],
        "comments": "Actions logs and artifacts function as a secondary information repository capturing build outputs, configuration, and sometimes secrets; adversaries can mine them much like they mine enterprise databases or logging systems.",
        "data_collected": "Historical and current workflow logs and artifacts, including build outputs, deployment manifests, reports, and any sensitive configuration or secrets that have been written into logs or artifacts."
      },
      {
        "can_achieve": true,
        "technique_name": "Data from Cloud Storage",
        "technique_stix_id": "attack-pattern--3298ce88-1628-43b1-87d9-0b5336b193d7",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Use the Packages UI and/or REST API to enumerate all packages and container images associated with organizations and repositories the compromised identity can access.",
            "related_capabilities": [
              "Package Management with GitHub Packages",
              "Packages & Container Registry Service",
              "GitHub REST API",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Packages views on user/org/repository pages",
              "REST API: /orgs/{org}/packages and related endpoints"
            ],
            "related_data": [
              "Packages and versions across supported ecosystems",
              "Package metadata (names, descriptions, licenses)",
              "Package visibility and access configuration"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "For each discovered package, call the appropriate REST API endpoints (for example, /orgs/{org}/packages/{package_type}/{package_name}/versions) to list available versions and capture associated metadata.",
            "related_capabilities": [
              "Package Management with GitHub Packages",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "REST API: /packages endpoints (Packages REST docs)"
            ],
            "related_data": [
              "Package versions and their metadata",
              "Links between packages and source repositories"
            ],
            "notes": null
          },
          {
            "step_id": 3,
            "description": "Authenticate to the relevant registries (for example, GitHub Container Registry or language-specific registries) using a PAT or token with read:packages scope, and systematically pull package binaries or container images (for example, docker pull ghcr.io/org/image:tag or npm/pip/maven clients for library packages).",
            "related_capabilities": [
              "Package Management with GitHub Packages",
              "Authentication & Account Security Management",
              "Packages & Container Registry Service"
            ],
            "related_interfaces": [
              "Container registry endpoints (ghcr.io) as documented in Packages docs",
              "Ecosystem-native package clients configured for GitHub Packages (npm, Maven, NuGet, etc.)"
            ],
            "related_data": [
              "Container images and manifests",
              "Library/package binaries and archives",
              "Authentication tokens used for registry access"
            ],
            "notes": "This parallels adversary use of cloud object storage (for example, S3 buckets) where they dump or sync all accessible objects."
          },
          {
            "step_id": 4,
            "description": "Optionally orchestrate package and image collection via GitHub Actions workflows that run with a token permitted to read private packages, looping through the enumerated package list and downloading or copying artifacts into workflow artifacts or other internal storage for further analysis.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Package Management with GitHub Packages"
            ],
            "related_interfaces": [
              "Workflow YAML definitions calling registry clients",
              "Actions logs and artifacts for storing pulled packages"
            ],
            "related_data": [
              "Workflow artifacts containing copied package contents",
              "Logs recording which packages and versions were collected"
            ],
            "notes": "Using GitHub-hosted runners can help operate from IP ranges that are already trusted by the environment."
          }
        ],
        "capabilities_used": [
          "Package Management with GitHub Packages",
          "Packages & Container Registry Service",
          "GitHub REST API",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Organization & Team Administration",
          "Authentication & Account Security Management",
          "Automated Dependency & Security Remediation Jobs"
        ],
        "interfaces_used": [
          "GitHub Packages UI at user, organization, and repository scope",
          "REST API: /packages endpoints (Packages REST docs)",
          "Container registry endpoints and ecosystem-native clients (Docker, npm, Maven, etc.)",
          "Actions workflows that authenticate to registries using tokens or secrets"
        ],
        "data_accessed": [
          "Packages and versions across all supported ecosystems",
          "Container images and associated manifests",
          "Package metadata (names, descriptions, licenses, visibility settings)",
          "Registry authentication tokens or credentials used by jobs and tools"
        ],
        "preconditions_required": [
          "Compromised identity or token with permissions to read the relevant private packages and container images (often tied to repository or organization membership).",
          "If registries are configured as private, the token must include read:packages or equivalent scopes.",
          "If IP allowlisting is enforced for registry access, the collection must run from allowed IPs or from GitHub-hosted runners accepted by policy.",
          "Compliance with any SSO/MFA controls for managing tokens and repository/package access."
        ],
        "constraints_encountered": [
          "Access Control – package visibility and access control restrict who can download private packages and images.",
          "Rate Limiting and Quotas – registries and APIs may impose bandwidth or request limits that constrain bulk download speed.",
          "IP Allowlisting – container and package registry endpoints may only be reachable from pre-approved networks.",
          "MFA and SSO enforcement complicate acquisition of new high-privilege tokens for registry access."
        ],
        "evasion_considerations": [
          "Pull packages and images in patterns similar to normal CI/CD usage (for example, by reusing existing build workflows rather than creating obviously new jobs).",
          "Throttle registry pulls and avoid sudden, full-registry mirroring that might trigger anomaly detection or budget alarms.",
          "Prefer using existing credentials and workflows that already access private packages instead of introducing new ones.",
          "Stage collection to prioritize sensitive or production-linked packages first (for example, container images used in deployments)."
        ],
        "comments": "This vector aligns with MITRE’s Data from Cloud Storage technique by treating GitHub Packages and container registries as cloud object stores whose contents can be bulk enumerated and downloaded.",
        "data_collected": "Complete sets of package binaries and container images, plus associated metadata, for all registries and packages the compromised identity can access, including private artifacts used in production."
      },
      {
        "can_achieve": true,
        "technique_name": "Data from Information Repositories",
        "technique_stix_id": "attack-pattern--d28ef391-8ed4-45dc-bc4a-2f43abf54416",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Compromise an organization owner, enterprise owner, billing manager, or similarly privileged account that can view organization/enterprise audit activity, account security logs, and billing/usage dashboards.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Billing & Usage Management",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Organization settings UI (Organizations docs)",
              "Enterprise admin UI (Enterprise Cloud admin docs)",
              "Billing dashboards and settings (Billing docs)",
              "Account security settings UI (Authentication docs)"
            ],
            "related_data": [
              "Organization and enterprise audit logs",
              "Billing accounts and product usage metrics",
              "Account-level security logs and token activity"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Access organization and enterprise audit/activity logs via the admin interfaces, filtering by time and event type, and export or systematically capture records of configuration changes, repository lifecycle events, membership changes, and security-related actions.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Security & Audit Logs (technical storage component)"
            ],
            "related_interfaces": [
              "Organization and enterprise audit log UIs",
              "Any documented export or download features in those views"
            ],
            "related_data": [
              "Organization audit log entries",
              "Enterprise audit log entries",
              "Repository and membership change history"
            ],
            "notes": "These logs reveal who changed what and when, enabling reconstruction of sensitive administrative actions."
          },
          {
            "step_id": 3,
            "description": "View and, where possible, export account-level security logs that record sign-ins, token creation/revocation, SSH key changes, and other credential events from the user’s security settings.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Security & Audit Logs (technical storage component"
            ],
            "related_interfaces": [
              "User account security logs and sessions page (Authentication docs)"
            ],
            "related_data": [
              "Sign-in events and locations",
              "Credential and token lifecycle events"
            ],
            "notes": "This helps the attacker understand which credentials exist, how often they are used, and from where."
          },
          {
            "step_id": 4,
            "description": "Use the Billing & Usage Management UI and the REST Billing Usage API to collect detailed usage data for Actions, Codespaces, Copilot, and other metered products, including historical trends, budgets, and invoices.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Billing & Metering Service",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Billing dashboards (Billing docs)",
              "REST API: /billing/usage endpoints"
            ],
            "related_data": [
              "Actions minutes, Codespaces hours, Copilot seat usage",
              "Invoices, budgets, and billing line items"
            ],
            "notes": "Usage data can highlight which repositories, runners, and features are most critical and active."
          },
          {
            "step_id": 5,
            "description": "Optionally configure enterprise global webhooks or organization webhooks that forward activity events to an attacker-controlled endpoint, effectively creating a continuous feed of operational telemetry to supplement the static logs and usage reports.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Enterprise global webhooks configuration UI",
              "Organization webhooks configuration and REST APIs"
            ],
            "related_data": [
              "Webhook payloads describing pushes, workflow runs, membership changes, and other activity"
            ],
            "notes": "Global webhooks can provide near-real-time mirroring of cross-org activity at enterprise scale."
          }
        ],
        "capabilities_used": [
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management",
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Webhook Event Delivery",
          "Security & Audit Logs (technical storage component)",
          "Billing & Metering Service (technical component)"
        ],
        "interfaces_used": [
          "Organization and enterprise admin settings UIs (Organizations and Enterprise admin docs)",
          "Billing and usage dashboards plus REST Billing Usage API",
          "Account security logs in user settings (Authentication docs)",
          "Enterprise global webhooks and organization webhooks configuration (Webhooks docs)"
        ],
        "data_accessed": [
          "Organization and enterprise audit logs for configuration and access changes",
          "Account-level security logs (sign-ins, token events, key changes)",
          "Actions, Codespaces, Copilot, and other product usage metrics",
          "Invoices, budgets, and billing configuration",
          "Webhook event streams with operational telemetry"
        ],
        "preconditions_required": [
          "A compromised account with organization-owner, enterprise-owner, billing-manager, or equivalent admin roles.",
          "Enterprise or organization must use GitHub Enterprise Cloud with audit logging and billing/usage reporting features enabled.",
          "If IP allowlisting, SSO-only authentication, MFA, domain-based registration, or admin approval are enforced, the compromised admin account must already satisfy these controls.",
          "Permissions to configure organization/enterprise webhooks if continuous event feeds are used."
        ],
        "constraints_encountered": [
          "Strict RBAC – access to audit logs and billing data is highly restricted to senior administrative roles.",
          "IP Allowlisting – administrative and billing APIs/UIs may only be reachable from specific networks.",
          "MFA Required and SSO-Only Authentication – materially raise the difficulty of compromising suitable admin accounts.",
          "Rate Limiting – may apply to REST billing usage APIs if queried very frequently."
        ],
        "evasion_considerations": [
          "Query logs and usage data at intervals and volumes consistent with typical compliance and finance reporting cycles.",
          "Avoid large, one-time exports of entire enterprise audit histories; instead, pull incremental ranges over time.",
          "If configuring global or organization webhooks, name them and target endpoints to resemble existing monitoring or SIEM integrations.",
          "Minimize direct manipulation of billing settings to avoid generating unusual admin events that could draw scrutiny."
        ],
        "comments": "Administrative, audit, and billing surfaces provide high-value telemetry about how GitHub is used within an enterprise, analogous to how attackers target centralized logging and metering systems in other environments.",
        "data_collected": "Cross-organizational audit and security logs, as well as detailed billing and product-usage reports, enabling reconstruction of administrative activity, developer behavior, and which repositories and features are most critical."
      },
      {
        "can_achieve": true,
        "technique_name": "Automated Collection",
        "technique_stix_id": "attack-pattern--30208d3e-0d6b-43c8-883e-44462a514619",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain write or maintainer-level access to a repository that has valuable secrets configured in Actions or that deploys to sensitive environments, ensuring ability to add or modify workflows in .github/workflows.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)",
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Repository collaborators/teams configuration UI",
              "Workflow files under .github/workflows"
            ],
            "related_data": [
              "Repository source code and configuration files",
              "Actions workflow definitions",
              "Repository and environment secrets metadata (names)"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Create or modify a workflow (for example, collect-secrets.yml) that is triggered on a schedule, workflow_dispatch, or common events (push, pull_request), and that uses actions/checkout to obtain the repository contents on the runner.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Workflow syntax for GitHub Actions (workflow YAML)",
              "Actions run configuration in the web UI"
            ],
            "related_data": [
              "Workflow definition including triggers and jobs",
              "Repository files checked out on the runner"
            ],
            "notes": "The workflow should be designed to appear similar to existing CI/CD or maintenance jobs to reduce suspicion."
          },
          {
            "step_id": 3,
            "description": "Within the workflow, run scripts that automatically enumerate and collect data of interest—such as environment variables, injected secrets, configuration files, dependency manifests, or specific file types—writing them into files in the workspace.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Runner shell or scripting steps in workflow jobs",
              "Secrets and environment variables injected into Actions jobs"
            ],
            "related_data": [
              "Secrets and environment variables available to workflows",
              "Configuration files and dependency manifests",
              "Any files matching chosen patterns within the repository"
            ],
            "notes": "This closely mirrors malware that scans for particular file extensions or credential stores, but executed inside GitHub’s CI environment."
          },
          {
            "step_id": 4,
            "description": "Use an artifact-upload step (for example, actions/upload-artifact) to package the collected files into one or more artifacts attached to the workflow run, ensuring the artifacts are retained long enough to be retrieved.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Actions Artifacts & Logs Storage"
            ],
            "related_interfaces": [
              "Artifact upload steps in workflow YAML",
              "Actions artifacts panel and /actions/runs/{run_id}/artifacts API"
            ],
            "related_data": [
              "Aggregated secrets and configuration data stored as artifact files",
              "Metadata about artifacts (names, sizes, retention)"
            ],
            "notes": "Artifacts become the internal staging repository for collected sensitive data."
          },
          {
            "step_id": 5,
            "description": "Trigger the workflow manually (via workflow_dispatch) or wait for scheduled/event-driven runs, then list and download the resulting artifacts via the Actions UI or REST API endpoints for workflow runs and artifacts.",
            "related_capabilities": [
              "GitHub REST API",
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "REST API: /repos/{owner}/{repo}/actions/workflows/{id}/dispatches",
              "REST API: /actions/runs/{run_id}/artifacts and artifact download URLs",
              "Actions run and artifacts UI"
            ],
            "related_data": [
              "Workflow artifacts containing aggregated sensitive data",
              "Run metadata (timestamps, triggering user/event)"
            ],
            "notes": null
          },
          {
            "step_id": 6,
            "description": "Optionally clean up or disguise the workflow (for example, by giving it a generic name and description or embedding it into an existing CI file) to reduce the chance that repository maintainers notice its data-collection purpose.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Repository commit history and pull requests modifying workflows",
              "Actions workflow list in the UI"
            ],
            "related_data": [
              "Updated workflow definitions",
              "Audit log entries describing workflow changes (if accessible)"
            ],
            "notes": null
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Actions Artifacts & Logs Storage",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Authentication & Account Security Management",
          "GitHub REST API",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines"
        ],
        "interfaces_used": [
          "Workflow YAML under .github/workflows (workflow syntax docs)",
          "Actions UI for workflow definitions, runs, and artifacts",
          "REST API: /actions/workflows, /actions/workflow-runs, /actions/runs/{run_id}/artifacts"
        ],
        "data_accessed": [
          "Repository content available to Actions runners",
          "Secrets and environment variables configured for Actions",
          "Files selected by automated search logic (for example, keys, configs, manifests)",
          "Aggregated artifacts storing collected data"
        ],
        "preconditions_required": [
          "A compromised identity with write/maintainer privileges on at least one repository where sensitive secrets or configurations are used in Actions workflows.",
          "Actions must be enabled for the repository, and the organization or enterprise must permit custom workflows.",
          "The compromised identity must be able to trigger workflows (via push, PR, scheduled events, or workflow_dispatch).",
          "Any SSO/MFA/IP restrictions must already be satisfied for the compromised identity."
        ],
        "constraints_encountered": [
          "Branch protection rules and required reviews may make it harder to introduce or alter workflows on protected branches without detection.",
          "Organization policies may restrict which actions can be used or may disable Actions entirely for some repositories.",
          "MFA and SSO enforcement make it more difficult to compromise high-privilege maintainers who can modify workflows.",
          "Rate limiting is less of a concern here but still applies to REST interactions used to trigger and download workflow artifacts."
        ],
        "evasion_considerations": [
          "Embed collection behavior into existing, legitimate-looking CI pipelines rather than creating obviously new workflows.",
          "Trigger workflows on normal events (for example, pushes to main) and avoid unusually frequent manual dispatches.",
          "Limit collection to specific file types or secrets to keep artifact sizes and activity levels within normal bounds.",
          "Name artifacts and jobs to resemble standard build/test artifacts to avoid attracting attention during routine checks."
        ],
        "comments": "This vector is a SaaS-native realization of automated data collection: instead of local malware scanning disks, the attacker’s logic runs inside GitHub Actions runners to automatically gather secrets and configuration into artifacts.",
        "data_collected": "Periodically refreshed artifacts containing curated sets of secrets, configuration files, and other sensitive repository data, produced automatically by GitHub Actions workflows and retrievable via standard Actions interfaces."
      },
      {
        "can_achieve": true,
        "technique_name": "Automated Collection",
        "technique_stix_id": "attack-pattern--30208d3e-0d6b-43c8-883e-44462a514619",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Obtain organization-owner, repository-admin, or enterprise-owner permissions—or compromise an existing GitHub App owner—so the attacker can configure repository/org/enterprise webhooks and install or manage GitHub Apps.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Organization settings UI for webhooks and app installations",
              "Enterprise global webhooks configuration UI",
              "GitHub Apps management UI"
            ],
            "related_data": [
              "Organization accounts and profiles",
              "App registrations and metadata",
              "Webhook configuration data"
            ],
            "notes": null
          },
          {
            "step_id": 2,
            "description": "Configure repository- or organization-level webhooks that send events such as push, pull_request, issues, workflow_run, and member changes to an attacker-controlled HTTPS endpoint, including a shared secret for authentication.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "Webhook configuration UI at repo/org scope",
              "REST API: /orgs/{org}/webhooks and related endpoints",
              "Webhook events and payloads documentation"
            ],
            "related_data": [
              "Webhook configuration (URLs, events, secrets)",
              "Event payloads containing repository, issue, PR, and workflow metadata"
            ],
            "notes": "Once configured, GitHub will automatically deliver structured JSON for every subscribed event."
          },
          {
            "step_id": 3,
            "description": "Optionally register a GitHub App with read permissions on repositories, issues, pull requests, and other targeted data, specifying the attacker-controlled webhook URL as the app’s webhook endpoint.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Apps & Integrations Platform (technical component)"
            ],
            "related_interfaces": [
              "GitHub App creation and permissions UI",
              "REST API: /apps endpoints"
            ],
            "related_data": [
              "GitHub App metadata and permissions",
              "Installation records for the app"
            ],
            "notes": "Apps offer fine-grained permissions and short-lived tokens, making them suitable for large-scale, ongoing collection."
          },
          {
            "step_id": 4,
            "description": "Install the GitHub App on targeted repositories and/or organizations. As events occur (pushes, PRs, issues, workflow runs, etc.), GitHub automatically sends app-specific webhook payloads to the attacker’s endpoint, which can log and index them for later analysis.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Repository Management & Source Code Hosting",
              "Issues, Projects & Collaboration Service",
              "Pull Request & Review Service"
            ],
            "related_interfaces": [
              "App installation workflows in the UI",
              "App webhook delivery mechanism"
            ],
            "related_data": [
              "App webhook event payloads including repository, issue, PR, and workflow-run data",
              "Installation scopes mapping the app to resources"
            ],
            "notes": "This creates a continuous, automated telemetry stream akin to a custom SIEM feed of GitHub activity."
          },
          {
            "step_id": 5,
            "description": "From the attacker-controlled endpoint, optionally use GitHub App installation tokens (obtained via the Apps REST API) to make follow-up REST API calls that enrich the event data—for example, fetching full issue or PR bodies, repository trees, or workflow artifacts referenced in events.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "API Gateway & REST Layer"
            ],
            "related_interfaces": [
              "REST API: /app/installations and /installations/{id}/access_tokens",
              "Resource-specific REST endpoints for repos, issues, PRs, and actions"
            ],
            "related_data": [
              "Full resource records (issues, PRs, repositories, workflow runs) linked from webhook events"
            ],
            "notes": "This combines event-driven triggers with pull-based enrichment to minimize API load while collecting complete records over time."
          },
          {
            "step_id": 6,
            "description": "For enterprises, configure global webhooks that cover all organizations in the enterprise account, ensuring that the attacker's endpoint receives activity events spanning every org under the enterprise.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Enterprise global webhooks configuration UI",
              "Associated monitoring and troubleshooting views for webhook deliveries"
            ],
            "related_data": [
              "Cross-organization activity events across the enterprise",
              "Webhook delivery logs and retry metadata"
            ],
            "notes": "This significantly broadens the scope of automated collection without needing per-org setup."
          }
        ],
        "capabilities_used": [
          "Webhook Event Delivery",
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Issue Tracking & Work Management with GitHub Issues",
          "Pull Requests & Code Review Workflow",
          "Automation with GitHub Actions (User Perspective)",
          "Apps & Integrations Platform",
          "API Gateway & REST Layer",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Repository, organization, and enterprise webhook configuration UIs (Webhooks docs)",
          "REST API: /orgs/{org}/webhooks and associated endpoints",
          "GitHub Apps registration and installation interfaces (Apps docs)",
          "REST API: /apps and /app/installations for app tokens and metadata"
        ],
        "data_accessed": [
          "Webhook event payloads containing repository, organization, user, and activity data",
          "GitHub App installation metadata and scopes",
          "Enriched resource data retrieved via REST for referenced issues, PRs, repositories, and workflow runs"
        ],
        "preconditions_required": [
          "Compromise of an identity with rights to configure webhooks and/or install GitHub Apps at the desired scope (repository, organization, or enterprise).",
          "Enterprise features must be enabled to leverage global webhooks across all organizations.",
          "Any SSO/MFA/IP allowlisting controls must already be satisfied by the compromised admin/app owner.",
          "Ability to host and maintain an HTTPS endpoint capable of receiving and processing webhook payloads."
        ],
        "constraints_encountered": [
          "Administrative Approval – new webhooks and GitHub Apps may be subject to administrative review or approval processes.",
          "IP Allowlisting – webhook delivery endpoints must be reachable from GitHub’s infrastructure and may be restricted by enterprise outbound network controls.",
          "Rate Limiting and Delivery Retries – extremely slow or failing webhook endpoints may trigger delivery problems or administrative investigation.",
          "MFA and SSO enforcement increase difficulty of compromising accounts that can set up high-scope webhooks or enterprise apps."
        ],
        "evasion_considerations": [
          "Name webhooks and GitHub Apps to resemble legitimate monitoring or CI integrations (for example, \"SIEM forwarder\" or \"Metrics collector\").",
          "Use endpoints and domains that look similar to existing enterprise logging or observability services.",
          "Limit subscribed events to those most useful and consistent with typical integrations (for example, push, pull_request) to avoid unusual event mixes.",
          "Ensure webhook endpoints respond quickly and with appropriate HTTP codes to avoid error spikes in delivery logs."
        ],
        "comments": "This vector uses GitHub’s own integration mechanisms (webhooks and Apps) to establish a long-lived, automated collection pipeline, continuously streaming structured activity data out of GitHub.",
        "data_collected": "Continuous, structured feeds of repository and organization activity—including pushes, issues, pull requests, workflow runs, and membership changes—aggregated across all repositories and organizations where webhooks or GitHub Apps are installed."
      }
    ],
    "summary": "Given GitHub’s documented capabilities, an attacker who has already overcome environmental controls such as SSO, MFA, and IP restrictions—and who controls at least one valid account or app installation—has multiple realistic collection paths. These include directly cloning and downloading repositories and releases; using the REST API and GitHub Apps to automate large-scale enumeration of code, collaboration artifacts, and security alerts; mining Actions logs and artifacts; bulk-retrieving packages and container images from GitHub Packages; harvesting administrative, audit, and billing telemetry; and configuring Actions workflows and webhooks/Apps to run continuous, automated collection inside GitHub’s own automation and integration framework. All identified vectors are feasible under the described capabilities, with effectiveness and scope governed primarily by account privileges, token scopes, organization/enterprise policies, and generic environmental constraints like MFA, SSO-only authentication, IP allowlisting, and rate limiting."
  },
  "command_and_control": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Application Layer Protocol: Web Protocols",
        "technique_stix_id": "T1071.001",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Authenticate to GitHub using a compromised user account or token that already satisfies MFA/SSO/IP-allowlisting constraints, and identify a target repository or organization where you can configure webhooks.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "User account security and authentication settings UI (https://docs.github.com/en/authentication)",
              "Repository settings UI (https://docs.github.com/en/repositories)",
              "Organization settings UI (https://docs.github.com/en/organizations)"
            ],
            "related_data": [
              "User identities and account metadata",
              "Repositories and repository metadata",
              "Organization accounts and profiles",
              "Members, roles, and repository access policies"
            ],
            "notes": "MFA, SSO-only auth, IP allowlisting, domain-based registration, and admin-approval constraints primarily affect how this compromised access was obtained, not the webhook channel itself."
          },
          {
            "step_id": 2,
            "description": "Create or modify a repository- or organization-level webhook to point to an attacker-controlled HTTPS endpoint, selecting events (for example, push, issues, pull_request, workflow_run) that will carry data or signals you want to receive.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository, organization, and enterprise webhook configuration UI (https://docs.github.com/en/webhooks)",
              "REST API for managing organization and repository webhooks (https://docs.github.com/en/rest/orgs/webhooks)"
            ],
            "related_data": [
              "Webhook endpoint URLs and shared secrets",
              "Webhook event payloads containing repository, organization, user, and activity data"
            ],
            "notes": "The webhook becomes a persistent outbound HTTP(S) channel from GitHub infrastructure to the attacker’s server whenever subscribed events fire."
          },
          {
            "step_id": 3,
            "description": "Configure a webhook secret and TLS on the attacker-controlled endpoint so that webhook deliveries appear legitimate and pass GitHub’s signature validation, reducing the chance that defenders treat failures as suspicious.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Webhook Delivery Service"
            ],
            "related_interfaces": [
              "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)"
            ],
            "related_data": [
              "Webhook shared secret (HMAC key)",
              "Webhook payload headers and signatures"
            ],
            "notes": "Using correct HMAC validation behavior makes the integration indistinguishable from a benign webhook from GitHub’s perspective."
          },
          {
            "step_id": 4,
            "description": "Implement a lightweight HTTP listener on the attacker infrastructure that accepts POST requests from GitHub, parses JSON payloads, and stores or forwards the event data as C2 telemetry.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Webhook Delivery Service"
            ],
            "related_interfaces": [
              "Webhook delivery over HTTPS from api.github.com/webhooks infrastructure"
            ],
            "related_data": [
              "Repository contents metadata (file paths, commit SHAs, branch names)",
              "Issue and pull request metadata and bodies",
              "Workflow run metadata and logs references",
              "Actor identities and timestamps"
            ],
            "notes": "This listener is the C2 server side; it receives a continuous stream of structured updates whenever relevant GitHub activity occurs."
          },
          {
            "step_id": 5,
            "description": "Optionally, encode explicit C2 messages into fields that trigger webhooks (for example, structured tokens in commit messages, issue titles, or PR descriptions) and have the listener interpret these fields as commands or signals.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Git over SSH/HTTPS for commits (https://docs.github.com/en/get-started/git-basics/set-up-git)",
              "Issues UI and REST API (https://docs.github.com/en/issues, https://docs.github.com/en/rest/issues/issues)",
              "Pull requests UI and REST API (https://docs.github.com/en/pull-requests, https://docs.github.com/en/rest/pulls/pulls)"
            ],
            "related_data": [
              "Commit messages and metadata",
              "Issue titles and bodies",
              "Pull request titles and descriptions",
              "Webhook payloads containing these fields"
            ],
            "notes": "This turns webhook payloads into a lightweight, push-based C2 channel where any collaborator action can deliver embedded commands to the attacker infrastructure."
          },
          {
            "step_id": 6,
            "description": "Throttle or filter events at the webhook configuration and on the attacker server (for example, only process events that contain a specific marker) to minimize noisy traffic and reduce the likelihood of detection in audit logs or billing anomalies.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Organization & Team Administration",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Webhook settings for event selection (https://docs.github.com/en/webhooks)",
              "Billing and usage dashboards (https://docs.github.com/en/billing)"
            ],
            "related_data": [
              "Webhook delivery logs and HTTP status codes",
              "Actions and other product usage metrics visible in billing"
            ],
            "notes": "Staying within normal traffic patterns and avoiding a large number of configured webhooks per repo/org reduces suspicion."
          }
        ],
        "capabilities_used": [
          "Webhook Event Delivery",
          "Webhook Delivery Service",
          "Repository Management & Source Code Hosting",
          "Issue Tracking & Work Management with GitHub Issues",
          "Pull Requests & Code Review Workflow",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management"
        ],
        "interfaces_used": [
          "Repository, organization, app, and enterprise webhook configuration UI (https://docs.github.com/en/webhooks)",
          "REST API for managing organization and repository webhooks (https://docs.github.com/en/rest/orgs/webhooks)",
          "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
          "Repository settings UI (https://docs.github.com/en/repositories)",
          "Organization settings UI (https://docs.github.com/en/organizations)",
          "User authentication and security settings (https://docs.github.com/en/authentication)"
        ],
        "data_accessed": [
          "Webhook event payloads (push, issues, pull requests, workflow runs, etc.)",
          "Repository metadata (names, visibility, default branches)",
          "Commit metadata and messages",
          "Issue and pull request content",
          "Webhook configuration (target URLs, secrets, event filters)",
          "Audit-relevant webhook delivery logs"
        ],
        "preconditions_required": [
          "Attacker controls a user account, PAT, or GitHub App with sufficient permissions to configure repository or organization webhooks.",
          "The account already satisfies MFA requirements, SSO-only authentication policies, and any email verification or admin approval requirements.",
          "If the environment enforces IP allowlisting for management/API access, the attacker must operate from an allowlisted IP (or via a compromised allowlisted host).",
          "Attacker can host an HTTPS endpoint reachable from GitHub’s webhook delivery service."
        ],
        "constraints_encountered": [
          "MFA Required – makes initial account compromise harder; once a token/session is stolen, configuring webhooks does not usually re-prompt for MFA.",
          "SSO-Only Authentication – attacker must compromise SSO or an existing SSO-backed account to gain access for webhook configuration.",
          "Domain-Based Registration and Admin Approval Required – limit the creation of new malicious accounts, increasing reliance on account takeover.",
          "IP Allowlisting – restricts from where the attacker can log in or use the REST API to configure webhooks; does not typically restrict GitHub’s outbound webhook deliveries.",
          "Rate Limiting – limits bulk API-based webhook creation or aggressive testing; attacker should use low-and-slow changes to remain under thresholds.",
          "CAPTCHA Protection and Email Verification – mainly impact automated registration rather than ongoing webhook use."
        ],
        "evasion_considerations": [
          "Name webhooks and descriptions to mimic legitimate tooling (for example, “CI mirror” or “analytics sink”) and use domains that resemble typical integrations.",
          "Subscribe only to a narrow set of events and further filter on the attacker server to keep delivery volumes low and patterns consistent with normal usage.",
          "Use HTTPS on standard ports and valid certificates to avoid standing out in network telemetry from the attacker side.",
          "Prefer reusing an existing webhook by subtly changing its URL rather than creating obvious new webhooks, if permissions allow.",
          "Rely on long-lived PATs or GitHub App tokens for configuration so that interactive MFA and CAPTCHA challenges are avoided during C2 maintenance."
        ],
        "comments": "This vector is straightforward and powerful: any admin-capable identity on a repo or org can turn GitHub’s webhook infrastructure into a push-based C2 channel streaming structured activity data to an attacker-controlled HTTP(S) server.",
        "communication_established": "Webhook endpoints on attacker-controlled infrastructure receive continuous HTTP POST callbacks from GitHub for selected repository or organization events."
      },
      {
        "can_achieve": true,
        "technique_name": "Web Service: Bidirectional Communication",
        "technique_stix_id": "T1102.002",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Register a GitHub App in an attacker-controlled user or organization account, specifying an attacker-controlled HTTPS webhook URL and requesting fine-grained permissions over repositories, issues, pull requests, or administration as needed.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Apps & Integrations Platform"
            ],
            "related_interfaces": [
              "GitHub Apps registration and configuration UI (https://docs.github.com/en/apps)",
              "About creating GitHub Apps (https://docs.github.com/en/apps/creating-github-apps/about-creating-github-apps/about-creating-github-apps)"
            ],
            "related_data": [
              "GitHub App registration metadata (name, description, permissions)",
              "Configured GitHub App webhook URL"
            ],
            "notes": "This defines a long-lived integration identity that GitHub will call via webhooks and that can obtain installation access tokens to act back on GitHub."
          },
          {
            "step_id": 2,
            "description": "Implement the app’s backend on attacker infrastructure to receive GitHub App webhooks, verify signatures, and exchange JSON messages over HTTPS with GitHub.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Webhook Delivery Service"
            ],
            "related_interfaces": [
              "Building a GitHub App that responds to webhook events (https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events)",
              "GitHub App webhook delivery channel (HTTPS callbacks)"
            ],
            "related_data": [
              "App-specific webhook payloads (installation events, issue/PR events, push events, etc.)",
              "Webhook shared secret and signatures"
            ],
            "notes": "This endpoint is effectively the C2 server for the app: it receives events from GitHub and can issue API calls back using app/installation tokens."
          },
          {
            "step_id": 3,
            "description": "Get the malicious GitHub App installed into the target organization or repositories (for example, via social engineering, by compromising an existing admin, or by creating the app under an already-trusted account).",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "GitHub Apps installation UI in organizations/repos (https://docs.github.com/en/apps/using-github-apps/about-using-github-apps)",
              "Enterprise and organization settings for managing app installations (https://docs.github.com/en/enterprise-cloud@latest/admin)"
            ],
            "related_data": [
              "App installation records linking the app to organizations and repositories",
              "Installation-scoped permission grants"
            ],
            "notes": "Once installed, the app has a durable, scoped presence within the victim’s GitHub environment."
          },
          {
            "step_id": 4,
            "description": "Upon relevant events (pushes, issue changes, PR updates, etc.), receive app webhooks on the attacker server and treat them as inbound C2 messages describing state changes inside the target GitHub environment.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "GitHub App webhooks delivery (HTTPS callbacks to the configured URL)",
              "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)"
            ],
            "related_data": [
              "Repository, issue, PR, and workflow event data",
              "Actor identities and timestamps",
              "References to commits, branches, and artifacts"
            ],
            "notes": "This creates a continuous, structured feed of victim-environment activity into the attacker’s C2 backend."
          },
          {
            "step_id": 5,
            "description": "Use the GitHub App’s private key to request short-lived JSON Web Tokens (JWTs), exchange them for installation access tokens, and call the GitHub REST API to read or modify resources in response to webhook-triggered logic.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Apps & Integrations Platform"
            ],
            "related_interfaces": [
              "REST API for GitHub Apps and installations (https://docs.github.com/en/rest/apps/apps)",
              "REST API index (https://docs.github.com/en/rest)",
              "About the REST API (https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
            ],
            "related_data": [
              "Installation access tokens with scoped permissions",
              "Repositories, issues, pull requests, and workflow data returned via the REST API"
            ],
            "notes": "These API calls represent the outbound leg of the C2 channel from the attacker back into GitHub, allowing automated control over the victim environment."
          },
          {
            "step_id": 6,
            "description": "Model GitHub objects (for example, issue bodies, comments, or specially named branches) as command or state channels, where the attacker updates them via the app’s API calls and the app’s backend synchronizes external C2 state accordingly.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Repository Management & Source Code Hosting",
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Issues REST API (https://docs.github.com/en/rest/issues/issues)",
              "Repositories REST API (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Issue bodies and comments encoding C2 commands or configuration",
              "Repository files or branches holding encoded state",
              "App installation-scoped activity logs"
            ],
            "notes": "This creates a bidirectional C2 loop: GitHub events -> attacker server via webhooks; attacker decisions -> GitHub via REST API mutations."
          },
          {
            "step_id": 7,
            "description": "Throttle API usage and scope permissions conservatively (for example, only to specific repos) to blend the malicious app’s pattern in with legitimate third-party integrations and reduce anomaly-based detection.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Billing & Usage Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "App permissions and installation scope configuration UI (https://docs.github.com/en/apps)",
              "Billing and usage dashboards (https://docs.github.com/en/billing)"
            ],
            "related_data": [
              "App permission sets and installation scopes",
              "API rate-limit headers and usage metrics"
            ],
            "notes": "Fine-grained permissions and low-volume activity make the app appear like a normal vendor integration."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "Webhook Event Delivery",
          "GitHub REST API",
          "Apps & Integrations Platform",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management"
        ],
        "interfaces_used": [
          "GitHub Apps registration and configuration UI (https://docs.github.com/en/apps)",
          "GitHub Apps & installations REST API (https://docs.github.com/en/rest/apps/apps)",
          "GitHub App webhook delivery channel (https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events)",
          "Generic webhook documentation (https://docs.github.com/en/webhooks)",
          "Webhook events and payloads reference (https://docs.github.com/en/webhooks/webhook-events-and-payloads)",
          "GitHub REST API (https://docs.github.com/en/rest)",
          "Organization and enterprise admin settings for apps (https://docs.github.com/en/enterprise-cloud@latest/admin)"
        ],
        "data_accessed": [
          "GitHub App registration and configuration data",
          "App installation records and scopes",
          "Webhook payloads for repository, issue, PR, and workflow events",
          "Installation access tokens and their scopes",
          "All GitHub resources granted to the app via REST API (repositories, issues, PRs, workflows, etc.)",
          "Audit and usage information related to app activity"
        ],
        "preconditions_required": [
          "Attacker can create or control a GitHub App (in any account) and host its backend on attacker infrastructure.",
          "Target organization or repositories accept app installations (no strict app-blocking policies), and an admin has installed the attacker-controlled app or the attacker is the admin.",
          "The app’s requested permissions are broad enough to expose useful data or control surfaces but narrow enough not to be automatically rejected as suspicious.",
          "Attacker’s account and app registrations already comply with MFA, SSO-only auth, email verification, domain restrictions, and any admin-approval workflows in the environment."
        ],
        "constraints_encountered": [
          "MFA Required and SSO-Only Authentication – make it harder to compromise the account that owns or installs the app, but do not affect the app’s backend once installed.",
          "Domain-Based Registration and Admin Approval Required – restrict who can create accounts and apps; attacker may need to compromise an existing trusted account instead of registering a new one.",
          "IP Allowlisting – may restrict from where administrators can install/manage the app; the app’s webhook deliveries to attacker infrastructure are not typically constrained by this.",
          "Rate Limiting – constrains high-volume REST API use from the app; C2 logic must stay within typical integration usage patterns.",
          "CAPTCHA and Email Verification – mostly impact account/app registration, not ongoing C2 via the app."
        ],
        "evasion_considerations": [
          "Choose benign-sounding app names, descriptions, and logos that mimic common tooling (for example, project analytics or CI assistance).",
          "Request the minimum set of permissions necessary and scope installations to specific repositories to avoid review friction and draw less attention.",
          "Keep webhook and API traffic volumes low and event types limited, aligning with plausible app behavior.",
          "Reuse existing hosting and domains that already serve legitimate integrations for the organization, if compromised, to blend outbound webhook traffic.",
          "Implement proper HMAC validation and error handling so webhook deliveries rarely fail (which would surface in admin troubleshooting views)."
        ],
        "comments": "GitHub Apps provide a first-class, formally supported way to maintain a persistent, bidirectional integration: GitHub sends webhooks in, the attacker-controlled backend sends API calls back. Once an app is installed into a target org or repo, it functions as a long-lived C2 agent embedded into the GitHub environment.",
        "communication_established": "A bidirectional HTTPS-based channel between the GitHub environment and attacker-controlled infrastructure via GitHub App webhooks (GitHub → attacker) and REST API calls using installation tokens (attacker → GitHub)."
      },
      {
        "can_achieve": true,
        "technique_name": "Application Layer Protocol: Web Protocols",
        "technique_stix_id": "T1071.001",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Identify a repository where GitHub Actions is enabled and where you have write or higher permissions, so you can create or modify workflow files under .github/workflows.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repository web UI and Actions tab (https://docs.github.com/en/actions)",
              "Repository file browser/edit UI (https://docs.github.com/en/repositories)",
              "Git over SSH/HTTPS for pushing workflow files (https://docs.github.com/en/get-started/git-basics/set-up-git)"
            ],
            "related_data": [
              "Repository contents including .github/workflows",
              "Repository permissions and branch protection policies"
            ],
            "notes": "Org or enterprise policies may constrain which actions and runners are available; the attacker prefers repos that can run on GitHub-hosted runners with internet egress."
          },
          {
            "step_id": 2,
            "description": "Create or modify a workflow YAML in .github/workflows that triggers on a schedule (cron) or on regular events (such as push) and runs a job on a GitHub-hosted runner.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Actions & Workflow Service"
            ],
            "related_interfaces": [
              "Workflow syntax for GitHub Actions (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
              "Actions concepts (https://docs.github.com/en/actions/concepts)"
            ],
            "related_data": [
              "Workflow definitions (YAML)",
              "Workflow triggers (schedule, push, pull_request, workflow_dispatch)"
            ],
            "notes": "Scheduled triggers are particularly effective for periodic C2 beacons that do not depend on visible user activity."
          },
          {
            "step_id": 3,
            "description": "Within the workflow steps, add logic (for example, using curl, PowerShell, Python, or Node.js) that issues HTTPS requests to an attacker-controlled endpoint, including environment information, selected repository data, or arbitrary payloads derived from secrets or files.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Workflow runner environment as described in Actions docs (https://docs.github.com/en/actions/concepts)",
              "External HTTPS endpoints operated by the attacker"
            ],
            "related_data": [
              "Repository files and configuration",
              "Workflow environment variables and secrets",
              "GITHUB_TOKEN and other credentials available to the job"
            ],
            "notes": "This establishes the outbound leg of the C2 channel from GitHub-hosted runners to attacker infrastructure using standard web protocols."
          },
          {
            "step_id": 4,
            "description": "Optionally implement polling in the workflow step: have the job request commands from the attacker server (for example, by fetching JSON from a C2 URL) and then interpret simple instructions to determine what to send back on subsequent HTTP requests or how to manipulate GitHub resources.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions workflow scripts running on runners",
              "GitHub REST API endpoints called from the workflow (https://docs.github.com/en/rest)"
            ],
            "related_data": [
              "Command payloads sent from attacker infrastructure",
              "API responses from GitHub when workflows act on repos, issues, or PRs"
            ],
            "notes": "Although workflows can execute arbitrary code, here they are used specifically to maintain an HTTP-based polling C2 loop from within GitHub infrastructure."
          },
          {
            "step_id": 5,
            "description": "Commit and push the workflow file, ensure it is enabled in the Actions UI, and, if using schedules, confirm that the cron expression causes regular execution without drawing attention (for example, align with existing CI schedules).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Actions UI for workflow runs (https://docs.github.com/en/actions/how-tos/manage-workflow-runs)",
              "Repository commits and history views (https://docs.github.com/en/repositories)"
            ],
            "related_data": [
              "Workflow run logs and metadata",
              "Commit history for .github/workflows"
            ],
            "notes": "Stealthy configuration avoids obviously malicious workflow names or unusual schedules."
          },
          {
            "step_id": 6,
            "description": "On attacker infrastructure, monitor incoming HTTPS connections from GitHub-hosted runners, log beacons, provide command responses, and adjust instructions over time while keeping traffic patterns within normal CI/CD behavior.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Attacker-controlled HTTPS endpoints",
              "Billing and usage dashboards that might reveal unusual Actions usage (https://docs.github.com/en/billing)"
            ],
            "related_data": [
              "Beacon payloads from workflows",
              "Usage metrics for Actions minutes and job counts"
            ],
            "notes": "Because traffic originates from GitHub’s runners to the attacker, defenders typically only see it indirectly via logs and billing unless they instrument external network telemetry."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "Billing & Usage Management",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "Actions tab and workflow run UI (https://docs.github.com/en/actions)",
          "Workflow syntax documentation (https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax)",
          "Actions concepts and runner behavior (https://docs.github.com/en/actions/concepts)",
          "REST API for workflows and workflow runs (https://docs.github.com/en/rest/actions/workflows, https://docs.github.com/en/rest/actions/workflow-runs)",
          "Repository UI and Git interfaces (https://docs.github.com/en/repositories, https://docs.github.com/en/get-started/git-basics/set-up-git)"
        ],
        "data_accessed": [
          "Workflow definitions, logs, and artifacts",
          "Repository source code and configuration files",
          "Environment variables and secrets injected into jobs",
          "GITHUB_TOKEN and other tokens used within workflows",
          "Usage and billing metrics for Actions"
        ],
        "preconditions_required": [
          "Attacker has write or admin-level permissions on a repository where Actions is enabled, or the ability to influence workflows via existing CI configuration.",
          "Organization and enterprise policies allow GitHub-hosted runners with outbound internet connectivity to attacker-controlled endpoints.",
          "Branch protection and rulesets do not prevent committing or modifying workflow files in the relevant branches (or the attacker can modify non-protected branches that still have workflows).",
          "Compromised credentials already satisfy MFA, SSO-only, IP allowlisting, and other auth-related constraints in the environment."
        ],
        "constraints_encountered": [
          "Organization or enterprise policies may restrict Actions to self-hosted runners or disallow network access, which can limit or block this vector on some repos.",
          "Rate Limiting does not typically apply to outbound HTTP from runners, but does apply to any REST API calls from workflows; C2 scripts must stay under rate thresholds.",
          "MFA, SSO-Only Authentication, and IP Allowlisting constrain the initial compromise and ongoing repository access for workflow modification.",
          "Billing and Actions usage monitoring can reveal anomalous or newly elevated workflow activity patterns."
        ],
        "evasion_considerations": [
          "Name workflows and jobs to resemble existing CI/CD processes, and place them in repositories where automated pipelines are already common.",
          "Align schedules with standard build/test cycles (for example, hourly or daily) instead of unusual high-frequency cron triggers.",
          "Limit HTTP traffic volume and payload size to avoid conspicuous bandwidth usage from runners.",
          "Use popular, benign-looking actions and scripts as wrappers for the HTTP communication (for example, generic curl or language runtimes) rather than highly customized tooling.",
          "Store only minimal logs in Actions to avoid leaving obvious artifacts of C2 activity in workflow run output."
        ],
        "comments": "Because GitHub Actions runners are general-purpose compute with network access, attacker-controlled workflows can easily maintain HTTP(S) beaconing channels to external infrastructure, turning CI/CD jobs into C2 beacons running under the guise of normal automation.",
        "communication_established": "Periodic HTTPS requests from GitHub Actions runners to attacker-controlled endpoints carry beacons and receive simple commands over standard web protocols."
      },
      {
        "can_achieve": true,
        "technique_name": "Proxy",
        "technique_stix_id": "T1090",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised user account that has Codespaces access for a target repository, authenticate through GitHub’s web UI, CLI, or IDE integration to confirm that Codespaces is enabled and that policies permit its use.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Codespaces web UI (https://docs.github.com/en/codespaces)",
              "GitHub CLI integration for Codespaces (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)",
              "Codespaces in Visual Studio Code (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code)"
            ],
            "related_data": [
              "Codespaces feature and policy configuration at org/enterprise level",
              "User entitlements to create codespaces",
              "Repository association with Codespaces"
            ],
            "notes": "MFA, SSO, IP allowlisting, and other auth constraints apply to accessing the account, but not directly to network traffic from the codespace itself."
          },
          {
            "step_id": 2,
            "description": "Create a new codespace for the chosen repository, using a dev container configuration that includes general-purpose networking tools or the ability to install them (for example, via package managers).",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Codespaces Service"
            ],
            "related_interfaces": [
              "Codespaces creation flow in the web UI (https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces)",
              "Codespaces CLI commands to create and connect (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)"
            ],
            "related_data": [
              "Dev container definitions (Dockerfiles, devcontainer.json)",
              "Codespace instance metadata (machine type, region, ports)"
            ],
            "notes": "Org/enterprise policies controlling machine types, regions, and network access determine whether the codespace has public internet egress suitable for proxying."
          },
          {
            "step_id": 3,
            "description": "Within the running codespace, install and configure a proxy or tunneling tool that establishes an outbound connection from the codespace to attacker-controlled infrastructure, effectively making the codespace a pivot endpoint.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Codespaces Service"
            ],
            "related_interfaces": [
              "Terminal session inside the codespace (via browser or IDE)",
              "Codespaces ports management UI (ports panel in Codespaces)"
            ],
            "related_data": [
              "Codespace filesystem state (including installed tools and configuration files)",
              "Open ports and associated forwarding configuration"
            ],
            "notes": "The outbound connection uses standard protocols (often HTTPS or SSH) so that from GitHub’s perspective it resembles normal developer tooling or remote access."
          },
          {
            "step_id": 4,
            "description": "Optionally modify the devcontainer.json or rely on Codespaces prebuilds so that each new codespace instance for this repo automatically includes and/or starts the proxy/tunneling mechanism on creation.",
            "related_capabilities": [
              "Projects & Codespaces Automation and Prebuilds",
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "Codespaces prebuilds configuration UI (https://docs.github.com/en/codespaces/prebuilding-your-codespaces)",
              "Repository devcontainer configuration files"
            ],
            "related_data": [
              "Prebuild configurations and VM images that embed tunneling utilities",
              "Dev container configuration that auto-starts background services"
            ],
            "notes": "This turns Codespaces into a repeatable, semi-persistent proxy platform requiring minimal manual setup per instance."
          },
          {
            "step_id": 5,
            "description": "Use the established tunnel or proxy to route traffic from attacker infrastructure through the codespace to other internal resources or to GitHub and third-party services, as needed for further operations, while maintaining the codespace as the C2 pivot.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Codespaces Service"
            ],
            "related_interfaces": [
              "Remote IDE or CLI session controlling the codespace",
              "Network routes established by the tunneling tool"
            ],
            "related_data": [
              "Traffic relayed through the codespace (not directly observable via GitHub’s high-level APIs)",
              "Codespace usage metrics and audit logs"
            ],
            "notes": "From GitHub’s standpoint, this appears as typical developer network activity unless network volumes or destinations are anomalous."
          },
          {
            "step_id": 6,
            "description": "Periodically tear down and recreate codespaces to rotate the proxy infrastructure, staying within quota and billing limits to reduce anomalies.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Codespaces management UI (https://docs.github.com/en/codespaces)",
              "Billing and usage dashboards for Codespaces (https://docs.github.com/en/billing)"
            ],
            "related_data": [
              "Codespaces usage records and costs",
              "Audit logs of codespace creation and deletion"
            ],
            "notes": "Short-lived, sporadically used codespaces are less likely to attract attention than a single long-running environment consuming large amounts of compute time."
          }
        ],
        "capabilities_used": [
          "Cloud Development Environments with GitHub Codespaces",
          "Projects & Codespaces Automation and Prebuilds",
          "Codespaces Service",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management"
        ],
        "interfaces_used": [
          "Codespaces web UI (https://docs.github.com/en/codespaces)",
          "Codespaces about page (https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces)",
          "GitHub CLI for Codespaces (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli)",
          "VS Code remote Codespaces integration (https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code)",
          "Codespaces prebuilds configuration (https://docs.github.com/en/codespaces/prebuilding-your-codespaces)",
          "Billing settings and usage dashboards (https://docs.github.com/en/billing)"
        ],
        "data_accessed": [
          "Codespace instances and runtime state (filesystem, processes, open ports)",
          "Dev container configuration and prebuild images",
          "Organization and enterprise Codespaces policies (regions, network access, quotas)",
          "Codespaces usage metrics and billing data",
          "Security and audit logs related to Codespaces activity"
        ],
        "preconditions_required": [
          "Codespaces is enabled for the target organization and repository, and policies allow its use by the compromised account.",
          "Codespaces network access is not fully restricted in a way that blocks outbound connections to attacker infrastructure.",
          "The attacker’s account satisfies MFA, SSO-only auth, IP allowlisting, and other login constraints so they can create and connect to codespaces.",
          "Billing quotas for Codespaces are high enough that additional usage will not immediately trigger automated shutdowns or investigations."
        ],
        "constraints_encountered": [
          "Enterprise and organization policies may restrict Codespaces network access, machine types, or allowed regions, potentially preventing outbound connections to attacker infrastructure.",
          "IP Allowlisting and SSO-only authentication limit the locations and identities from which an attacker can initiate and manage codespaces.",
          "Billing and usage monitoring can reveal unusual Codespaces consumption patterns, especially if many environments are created or left running.",
          "MFA and admin approvals for enabling Codespaces at org/enterprise scale may limit attack surface to environments where Codespaces is already in use."
        ],
        "evasion_considerations": [
          "Use repositories and organizations where Codespaces is already widely used so that new codespace creation appears normal.",
          "Keep codespaces lifetimes and resource usage modest to fall within typical per-user consumption patterns.",
          "Hide tunneling utilities among legitimate development tools in the dev container image, and avoid opening obvious non-development ports.",
          "Configure tunnels to use standard developer-friendly protocols and port numbers (such as HTTPS over 443) to blend with normal traffic.",
          "Rotate proxies and avoid long-lived, high-bandwidth connections that could stand out in network analytics or billing data."
        ],
        "comments": "Codespaces effectively gives each authorized user an on-demand, cloud-hosted Linux environment with outbound network access. Once compromised, these environments can be turned into disposable network proxies or tunneling endpoints controlled from attacker infrastructure, providing a flexible C2 and pivot point.",
        "communication_established": "An outbound tunnel or proxy connection from a GitHub-hosted codespace to attacker-controlled infrastructure, allowing attacker traffic to be relayed through the codespace."
      },
      {
        "can_achieve": true,
        "technique_name": "Web Service: Dead Drop Resolver",
        "technique_stix_id": "T1102.001",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Create or gain control of one or more GitHub repositories (public or private) that will serve as C2 storage, and define a simple schema for encoding commands and results in issues, pull requests, files, or commit messages.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues",
              "Pull Requests & Code Review Workflow"
            ],
            "related_interfaces": [
              "Repositories UI (https://docs.github.com/en/repositories)",
              "Issues UI (https://docs.github.com/en/issues)",
              "Pull requests UI (https://docs.github.com/en/pull-requests)"
            ],
            "related_data": [
              "Repository files, commits, branches, and tags",
              "Issue titles and bodies",
              "Pull request descriptions and comments"
            ],
            "notes": "These repositories may live in attacker-owned accounts or in compromised organizations, depending on the target and desired cover."
          },
          {
            "step_id": 2,
            "description": "Generate and store an access credential (for example, a fine-grained personal access token or GitHub App token) that allows automated clients to read and write the selected resources in the C2 repositories via the GitHub REST API.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub REST API",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "Authentication settings UI for PATs and tokens (https://docs.github.com/en/authentication)",
              "REST API index and auth docs (https://docs.github.com/en/rest, https://docs.github.com/en/rest/about-the-rest-api/about-the-rest-api)"
            ],
            "related_data": [
              "Personal access tokens and their scopes",
              "GitHub App installation tokens",
              "API rate-limit metadata for the token"
            ],
            "notes": "Tokens may be embedded in malware or used by external C2 servers; MFA and SSO affect how the token is created but not its subsequent non-interactive use."
          },
          {
            "step_id": 3,
            "description": "Implement malware or an agent that periodically connects to api.github.com over HTTPS, authenticates with the stored credential, and reads from specific issues, comments, files, or branches to retrieve commands or configuration.",
            "related_capabilities": [
              "GitHub REST API",
              "Issue Tracking & Work Management with GitHub Issues",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Issues REST API (https://docs.github.com/en/rest/issues/issues)",
              "Repositories contents and commits REST API (https://docs.github.com/en/rest/repos/repos)"
            ],
            "related_data": [
              "Command payloads encoded in issue bodies or comments",
              "Configuration data stored in tracked files or branches"
            ],
            "notes": "From the perspective of the compromised host’s network, this traffic appears as routine HTTPS connections to GitHub."
          },
          {
            "step_id": 4,
            "description": "Have the malware or agent write execution results or telemetry back into GitHub by creating or updating issues, comments, commits, or repository files, effectively using GitHub as a dead drop for both commands and responses.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues"
            ],
            "related_interfaces": [
              "Issues REST API for creating/updating issues and comments",
              "Repositories contents/commits API for updating files"
            ],
            "related_data": [
              "Result payloads encoded in issue comments or new issues",
              "Data embedded in new commits or file contents"
            ],
            "notes": "This completes the dead-drop pattern: both sides communicate asynchronously via GitHub-hosted content."
          },
          {
            "step_id": 5,
            "description": "Use GitHub’s normal UI and APIs from the attacker side to monitor changes in the C2 repositories, interpret results, and post new commands, all over standard web protocols without direct contact with compromised hosts.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues"
            ],
            "related_interfaces": [
              "GitHub web UI for repositories and issues",
              "REST API for repositories and issues"
            ],
            "related_data": [
              "All C2-related content stored in repository resources",
              "Audit logs of access and changes (from GitHub’s perspective)"
            ],
            "notes": "The attacker’s use of GitHub looks like typical user or automation activity interacting with repositories and issues."
          },
          {
            "step_id": 6,
            "description": "Optionally add GitHub Actions workflows or GitHub Apps that observe changes in the C2 repositories and trigger further automation (for example, transforming or relaying data), while still keeping the main C2 logic encoded in repository content.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Actions workflows in .github/workflows",
              "GitHub Apps webhooks and REST APIs",
              "Webhook events and payloads (https://docs.github.com/en/webhooks/webhook-events-and-payloads)"
            ],
            "related_data": [
              "Workflow run logs and artifacts reflecting C2 operations",
              "App/webhook payloads summarizing C2-related repository changes"
            ],
            "notes": "These automations can further obscure the relationship between C2-related repository changes and the ultimate attacker-controlled infrastructure."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Issue Tracking & Work Management with GitHub Issues",
          "Pull Requests & Code Review Workflow",
          "GitHub REST API",
          "Authentication & Account Security Management",
          "GitHub Apps & OAuth Apps Platform",
          "Automation with GitHub Actions (User Perspective)",
          "Webhook Event Delivery"
        ],
        "interfaces_used": [
          "GitHub REST API (https://docs.github.com/en/rest)",
          "REST API for repositories (https://docs.github.com/en/rest/repos/repos)",
          "REST API for issues (https://docs.github.com/en/rest/issues/issues)",
          "Repositories UI (https://docs.github.com/en/repositories)",
          "Issues UI (https://docs.github.com/en/issues)",
          "Pull requests UI (https://docs.github.com/en/pull-requests)",
          "GitHub CLI (https://docs.github.com/en/github-cli)",
          "Actions workflows and UI (https://docs.github.com/en/actions)",
          "GitHub Apps platform (https://docs.github.com/en/apps)",
          "Webhook events and payloads (https://docs.github.com/en/webhooks/webhook-events-and-payloads)"
        ],
        "data_accessed": [
          "Repository files, commits, branches, and tags used to store encoded C2 data",
          "Issue and pull request titles, bodies, and comments carrying C2 commands or results",
          "Access tokens or app tokens enabling API-based C2 operations",
          "Workflow runs and logs created by any automation attached to C2 repositories",
          "Webhook payloads describing C2-related repository activity"
        ],
        "preconditions_required": [
          "Attacker can create or control at least one GitHub repository (attacker-owned or compromised) accessible to both the attacker and any malware/agents.",
          "Attacker can obtain and embed a valid credential (PAT, fine-grained token, or GitHub App token) in malware or C2 tooling to authenticate to the GitHub REST API.",
          "The environment’s MFA, SSO-only, email verification, domain-based registration, and admin-approval constraints are satisfied or bypassed for the account whose token is used.",
          "Compromised hosts or agents can reach api.github.com over HTTPS (i.e., no outbound network controls blocking GitHub)."
        ],
        "constraints_encountered": [
          "Rate Limiting on the GitHub REST API constrains how often agents can poll for commands or post results; C2 protocols must use low polling frequencies and caching.",
          "MFA Required and SSO-Only Authentication increase the difficulty of initially obtaining tokens but do not affect their later non-interactive use.",
          "IP Allowlisting, if enforced by GitHub Enterprise or by the victim’s egress controls, can limit from where malware can contact GitHub; attackers may need to operate from approved ranges.",
          "CAPTCHA Protection, Email Verification, and Admin Approval Required affect the creation of new accounts used for C2, pushing attackers toward compromising existing accounts.",
          "Security monitoring on the victim side may treat unexpected GitHub traffic from internal hosts as suspicious, depending on their egress rules."
        ],
        "evasion_considerations": [
          "Use public repositories or benign-looking private repos with plausible project names to host C2 data, blending with normal developer activity.",
          "Encode commands and results in formats that look like legitimate issue discussions, documentation, or configuration files rather than obvious ciphertext blobs.",
          "Throttle agent polling intervals and randomize timing to stay well under REST API rate limits and avoid traffic bursts.",
          "Use fine-grained tokens scoped narrowly to the C2 repositories to reduce the blast radius if tokens are discovered, and to look like legitimate automation access.",
          "Leverage standard GitHub clients (Git, REST, GitHub CLI) from the attacker side so that interactions with the C2 repositories look indistinguishable from normal usage."
        ],
        "comments": "This vector uses GitHub itself as a dead-drop C2 service: compromised systems and attackers never communicate directly, instead reading and writing commands and results via GitHub repositories, issues, or PRs using the REST API over HTTPS.",
        "communication_established": "An asynchronous bidirectional C2 channel where compromised agents and attackers exchange commands and results via GitHub-hosted repository content (issues, files, commits) accessed over HTTPS."
      }
    ],
    "summary": "GitHub’s documented capabilities provide multiple realistic command-and-control avenues. Key vectors include: (1) configuring repository, organization, or enterprise webhooks to send rich event payloads over HTTPS to attacker-controlled servers, enabling a push-based C2 telemetry stream; (2) registering and installing malicious GitHub Apps that receive GitHub App webhooks and act back via installation tokens and the REST API, forming a durable bidirectional integration that functions as a C2 agent inside the GitHub environment; (3) embedding HTTP(S)-based beaconing logic into GitHub Actions workflows running on GitHub-hosted runners, which periodically contact attacker infrastructure as part of scheduled or event-driven jobs; (4) abusing GitHub Codespaces as on-demand, cloud-hosted pivot hosts where attackers establish outbound tunnels or proxies, using Codespaces as a network relay under the guise of development activity; and (5) using GitHub repositories, issues, pull requests, and files as dead-drop storage for commands and results, with compromised hosts polling the GitHub REST API over HTTPS to implement covert C2 over a legitimate web service. Environment-wide controls like MFA, SSO, IP allowlisting, rate limiting, and app policies primarily raise the bar for initial compromise and large-scale automation; they do not fundamentally prevent these C2 patterns once an attacker controls suitable accounts, tokens, or app installations."
  },
  "exfiltration": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Exfiltration Over Alternative Protocol",
        "technique_stix_id": "attack-pattern--a19e86f8-1c0a-4fea-8407-23b73d615776",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised user, fine‑grained PAT, or GitHub App installation token that already has access to one or more organizations, the attacker enumerates all accessible organizations, repositories, and packages via the GitHub REST API or the web UI.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Package Management with GitHub Packages",
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "REST API index and auth docs – https://docs.github.com/en/rest and https://docs.github.com/en/rest/authentication",
              "Repositories REST API – https://docs.github.com/en/rest/repos/repos",
              "Packages REST API – https://docs.github.com/en/rest/packages/packages",
              "Organizations REST API – https://docs.github.com/en/rest/orgs/orgs",
              "Web UI: Repositories and organization views – https://docs.github.com/en/repositories and https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "Lists of organizations and repositories the identity can access",
              "Repository metadata (visibility, default branch, permissions)",
              "Lists of packages and versions under users/orgs"
            ],
            "notes": "This step assumes the compromised identity has already satisfied MFA/SSO, email verification, domain restrictions, and any admin approval requirements."
          },
          {
            "step_id": 2,
            "description": "For each target repository, the attacker downloads full source and Git history using Git clone/fetch over HTTPS or SSH, or via repository archive downloads (for example, ZIPball endpoints or “Download ZIP” in the UI).",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "GitHub REST API",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Git over HTTPS/SSH via configured remotes – https://docs.github.com/en/get-started/git-basics/set-up-git",
              "Repository web UI clone/archive controls – https://docs.github.com/en/repositories",
              "/repos contents and archive endpoints – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Git objects (commits, trees, blobs, tags) for each repository",
              "Working tree content (source code, configs, IaC, docs)",
              "Releases and release assets where downloaded"
            ],
            "notes": "From an exfiltration perspective, every successful clone or archive download moves a complete copy of the repository out of GitHub’s tenant onto attacker‑controlled infrastructure."
          },
          {
            "step_id": 3,
            "description": "The attacker uses REST APIs to bulk pull collaboration metadata such as issues, comments, pull requests, and Projects data that may contain design details, incident reports, or security information, paginating through all results and storing them off‑platform.",
            "related_capabilities": [
              "Issue Tracking & Work Management with GitHub Issues",
              "Project Planning & Reporting with GitHub Projects",
              "Pull Requests & Code Review Workflow",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Issues REST API – https://docs.github.com/en/rest/issues/issues",
              "Projects REST API – https://docs.github.com/en/rest/projects/projects",
              "Pull requests REST API – https://docs.github.com/en/rest/pulls/pulls",
              "Issues/Projects UI – https://docs.github.com/en/issues and https://docs.github.com/en/issues/planning-and-tracking-with-projects"
            ],
            "related_data": [
              "Issue titles, bodies, comments, labels, and milestones",
              "Pull request metadata, diffs, and review comments",
              "Projects items, custom fields, and roadmap views"
            ],
            "notes": "This mirrors how legitimate reporting or migration tools export issues/PRs/projects, but here the destination is attacker infrastructure."
          },
          {
            "step_id": 4,
            "description": "Where the compromised identity has security roles or Advanced Security access, the attacker calls security‑focused REST endpoints to export code scanning alerts, Dependabot alerts, secret scanning alerts, and organization‑level security configuration and campaign data.",
            "related_capabilities": [
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection",
              "Organization-Scale Security Configuration, Risk Assessment & Campaigns",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Code scanning REST API – https://docs.github.com/en/rest/code-scanning/code-scanning",
              "Dependabot alerts REST API – https://docs.github.com/en/rest/dependabot/alerts",
              "Secret scanning REST API – https://docs.github.com/en/rest/secret-scanning/secret-scanning",
              "Code security configurations REST API – https://docs.github.com/en/rest/code-security/configurations"
            ],
            "related_data": [
              "Code scanning alerts and SARIF results",
              "Dependabot vulnerability alerts and metadata",
              "Secret scanning alerts and push protection decisions",
              "Org‑level security configurations, risk assessments, and campaigns"
            ],
            "notes": "These exports provide a high‑value map of vulnerabilities and leaked secrets across the tenant."
          },
          {
            "step_id": 5,
            "description": "If the identity has billing or admin access, the attacker queries billing/usage APIs and views audit and security logs via admin UIs (and any available APIs) to export invoices, usage metrics (Actions, Codespaces, Copilot), and activity logs.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Billing usage REST API – https://docs.github.com/en/rest/billing/usage",
              "Billing UI – https://docs.github.com/en/billing",
              "Enterprise admin UI – https://docs.github.com/en/enterprise-cloud@latest/admin",
              "Org admin/audit views – https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "Actions minutes, Codespaces hours, and other usage metrics",
              "Invoices and billing account details",
              "Organization or enterprise audit and security logs where exposed"
            ],
            "notes": "Even if logs are only UI‑accessible, an attacker can scrape them via normal browser sessions; any log data viewed in a browser is effectively exfiltrated."
          },
          {
            "step_id": 6,
            "description": "The attacker consolidates the downloaded code, metadata, security findings, and telemetry in attacker‑controlled storage (for example, local file system or their own cloud account), compressing and encrypting archives where desired.",
            "related_capabilities": [
              "GitHub REST API",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Any of the above REST/API and Git endpoints used as data sources"
            ],
            "related_data": [
              "Aggregated source code archives and Git mirrors",
              "Bulk JSON exports of issues, PRs, projects, and security alerts",
              "Usage reports, invoices, and log exports"
            ],
            "notes": "At this point the data is fully outside the GitHub tenant; any further movement is outside the application’s control."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Issue Tracking & Work Management with GitHub Issues",
          "Project Planning & Reporting with GitHub Projects",
          "Pull Requests & Code Review Workflow",
          "Package Management with GitHub Packages",
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management",
          "GitHub REST API",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Git over HTTPS/SSH remotes as configured in Git – https://docs.github.com/en/get-started/git-basics/set-up-git",
          "Repository web UI and settings – https://docs.github.com/en/repositories",
          "Issues and Projects UIs – https://docs.github.com/en/issues and https://docs.github.com/en/issues/planning-and-tracking-with-projects",
          "REST API root and auth – https://docs.github.com/en/rest and https://docs.github.com/en/rest/authentication",
          "/repos, /issues, /pulls, /projects REST APIs – https://docs.github.com/en/rest/repos/repos, https://docs.github.com/en/rest/issues/issues, https://docs.github.com/en/rest/pulls/pulls, https://docs.github.com/en/rest/projects/projects",
          "Security REST APIs – https://docs.github.com/en/rest/code-scanning/code-scanning, https://docs.github.com/en/rest/dependabot/alerts, https://docs.github.com/en/rest/secret-scanning/secret-scanning, https://docs.github.com/en/rest/code-security/configurations",
          "Billing REST API and UI – https://docs.github.com/en/rest/billing/usage, https://docs.github.com/en/billing",
          "Org and enterprise admin UIs – https://docs.github.com/en/organizations, https://docs.github.com/en/enterprise-cloud@latest/admin"
        ],
        "data_accessed": [
          "Repository Git data (files, blobs, trees, commits, branches, tags)",
          "Repository metadata (visibility, collaborators, rulesets, branch protection)",
          "Issues, comments, labels, milestones, and linked PRs",
          "Pull requests, diffs, reviews, and merge metadata",
          "GitHub Projects items, custom fields, and views",
          "Packages and versions, including container images",
          "Code scanning alerts and SARIF results",
          "Dependabot vulnerability alerts and dependency manifests",
          "Secret scanning alerts and push‑protection metadata",
          "Org‑ and enterprise‑level security configurations and campaigns",
          "Billing invoices, usage metrics, and budgets",
          "Organization/enterprise audit and security logs (where accessible)"
        ],
        "preconditions_required": [
          "Attacker controls a user account, fine‑grained PAT, or GitHub App installation token with at least read access to target repositories and any desired issues/projects/PRs.",
          "To export security alerts, the identity must have roles/scopes permitting access to Advanced Security data (code scanning, Dependabot, secret scanning) and org‑level security configuration APIs.",
          "To export billing/usage data, the identity must hold organization/enterprise owner or billing manager roles, and billing APIs must be enabled.",
          "MFA Required: the compromised account must already have MFA enrolled and satisfied; the attacker is operating with a valid session or token obtained post‑MFA.",
          "SSO‑Only Authentication & Domain‑Based Registration: the account must be provisioned via the allowed IdP and email domains; exfiltration assumes compromise of such an existing account rather than new registration.",
          "IP Allowlisting: if enforced, the attacker’s client or proxy must originate from an allowlisted IP range to use the UI and REST/Git endpoints."
        ],
        "constraints_encountered": [
          "Rate Limiting: GitHub’s own API and the environment’s generic rate limiting can throttle high‑volume REST and Git activity, forcing the attacker to use low‑and‑slow downloads or distribute requests across time/tokens.",
          "IP Allowlisting: UI and API access is only possible from allowed IP ranges; exfiltration traffic must be proxied through an allowlisted host or compromised workstation inside the corporate network."
        ],
        "evasion_considerations": [
          "Throttle API calls and Git clones to remain under rate‑limit thresholds and resemble normal CI, backup, or mirroring activity.",
          "Use standard Git clients and REST libraries with typical user‑agents rather than custom tooling that might stand out in logs.",
          "Interleave exfiltration with legitimate operations (for example, only clone active repos, or pull issues for specific projects) to reduce anomaly signals.",
          "Stage exports in small batches and over extended periods rather than attempting one‑time mass export, minimizing spikes in network and billing metrics."
        ],
        "comments": "This is the most straightforward and universally applicable exfiltration path: any compromised identity with normal read/billing/security permissions can pull large volumes of code and metadata using only standard Git and REST/API access over HTTPS/SSH.",
        "data_exfiltrated": "Comprehensive copies of all data the compromised identity can read, including full Git history, releases, packages, issues, pull requests, projects, security alerts, and billing/usage information, downloaded over HTTPS/SSH to attacker-controlled systems."
      },
      {
        "can_achieve": true,
        "technique_name": "Exfiltration Over Web Service",
        "technique_stix_id": "attack-pattern--40597f16-0963-4249-bf4c-ac93b7fb9807",
        "method_steps": [
          {
            "step_id": 1,
            "description": "With the ability to modify workflows in a target repository, the attacker adds or alters a GitHub Actions workflow under .github/workflows to run on a chosen trigger (for example, schedule, push to main, or workflow_dispatch) and to have read access to repository contents and any needed secrets.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Actions concepts and workflow syntax – https://docs.github.com/en/actions/concepts/workflows-and-actions and https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
              "Repository Actions tab and run management – https://docs.github.com/en/actions",
              "REST API for workflows – https://docs.github.com/en/rest/actions/workflows"
            ],
            "related_data": [
              "Workflow definitions (YAML) in .github/workflows",
              "Repository contents checked out by the workflow",
              "Repository‑ or org‑level secrets and environment variables usable by the workflow"
            ],
            "notes": "This mirrors normal CI/CD usage, but the workflow’s true intent is data theft."
          },
          {
            "step_id": 2,
            "description": "Inside the workflow, the attacker defines steps that collect sensitive data (for example, archiving the repository, reading configuration files, or printing selected secrets into files) and then use standard HTTP clients (such as curl) or SaaS‑specific CLIs/SDKs to upload that archive to an external web service under the attacker’s control (for example, generic HTTPS endpoint, cloud storage bucket, or chat/file‑sharing SaaS).",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Runner execution model and secrets usage – https://docs.github.com/en/actions/concepts",
              "Workflow run logs/artifacts – https://docs.github.com/en/actions/how-tos/manage-workflow-runs"
            ],
            "related_data": [
              "Repository source and configuration files included in the archive",
              "Any secrets or tokens deliberately written into the archive",
              "Temporary archives created on the runner file system"
            ],
            "notes": "This is analogous to MITRE examples where malware compresses data locally then uses curl/HTTP APIs to send it to cloud services such as Google Drive or email providers."
          },
          {
            "step_id": 3,
            "description": "The workflow runs on a GitHub‑hosted or self‑hosted runner with network egress; during execution, it initiates outbound HTTPS requests to the attacker’s chosen web service, authenticating with attacker‑controlled credentials and transferring the prepared archive or data chunks.",
            "related_capabilities": [
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Actions runner environment – https://docs.github.com/en/actions/concepts",
              "REST actions workflow-runs API for monitoring and re-running – https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "HTTP request bodies containing compressed source, configuration, or secrets",
              "Runner logs reflecting transfer commands (if not suppressed)"
            ],
            "notes": "Because outbound HTTPS is common for CI (fetching dependencies, hitting deployment APIs), these transfers can blend with normal runner traffic."
          },
          {
            "step_id": 4,
            "description": "The attacker accesses the external web service (for example, their own cloud storage account or SaaS workspace) out-of-band and downloads or processes the uploaded archives, completing exfiltration outside of GitHub’s control.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)"
            ],
            "related_interfaces": [
              "External web service APIs or consoles (outside GitHub)"
            ],
            "related_data": [
              "Archived repositories and any included secrets stored in the attacker’s external account"
            ],
            "notes": "From GitHub’s perspective, the data has already left once the runner posted it to the external web service."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "GitHub REST API",
          "Authentication & Account Security Management",
          "Billing & Usage Management"
        ],
        "interfaces_used": [
          "Workflow definition and syntax – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax",
          "Actions concepts and runners – https://docs.github.com/en/actions/concepts/workflows-and-actions and https://docs.github.com/en/actions/concepts",
          "Actions run management UI and APIs – https://docs.github.com/en/actions/how-tos/manage-workflow-runs and https://docs.github.com/en/rest/actions/workflow-runs",
          "Repository UI for enabling Actions – https://docs.github.com/en/actions",
          "REST API for workflows – https://docs.github.com/en/rest/actions/workflows"
        ],
        "data_accessed": [
          "Repository contents checked out in the workflow workspace",
          "Secrets and environment variables made available to workflows (for example, deployment keys, cloud provider keys)",
          "Any additional data fetched via REST APIs during the workflow (issues, security alerts, etc.)"
        ],
        "preconditions_required": [
          "Actions must be enabled for the organization and repository, and policies must permit the types of runners and actions used.",
          "The attacker controls a user or token with permission to modify workflow files in the target repository (for example, write access or ability to push to a branch where workflows are honored).",
          "Required secrets (for example, credentials for the external web service) must either already exist in the repository/organization or be addable by the attacker.",
          "MFA/SSO/Email verification/Admin approval constraints are already satisfied for the compromised account; the attacker is operating with an approved identity."
        ],
        "constraints_encountered": [
          "Rate Limiting: Excessive or frequent workflow runs that generate large outbound transfers can be constrained by GitHub Actions usage limits and general environment rate limiting, so attackers may spread exfiltration across time or multiple repositories.",
          "Billing & Usage Monitoring: Large volumes of Actions minutes used for exfiltration may cause billing anomalies; the attacker may attempt to stay within typical usage patterns."
        ],
        "evasion_considerations": [
          "Blend exfiltration steps into existing CI/CD workflows (for example, add a seemingly innocuous step that in reality uploads artifacts to attacker infrastructure).",
          "Use popular external SaaS targets (for example, generic cloud storage or collaboration tools) so HTTPS traffic appears similar to legitimate build/deploy integrations, as seen in ATT&CK examples leveraging services like Google Drive or Outlook.",
          "Limit archive sizes and run frequency to avoid sudden spikes in Actions usage and network egress.",
          "Encrypt archives before upload so that any intermediate inspection (for example, log capture) reveals minimal content."
        ],
        "comments": "GitHub Actions provides near‑arbitrary code execution with outbound HTTPS on runners; repurposing this to call external web services is a powerful and realistic way to stream code and secrets out of GitHub under the guise of normal CI traffic.",
        "data_exfiltrated": "Archives or serialized bundles of repository contents and secrets are uploaded from GitHub Actions runners to attacker-controlled web services (cloud storage, file‑sharing, or collaboration SaaS), where the attacker later retrieves them."
      },
      {
        "can_achieve": true,
        "technique_name": "Exfiltration Over Web Service",
        "technique_stix_id": "attack-pattern--40597f16-0963-4249-bf4c-ac93b7fb9807",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised developer account with access to private repositories and permission to use Codespaces, the attacker creates or opens a Codespace for one or more target repositories via the GitHub.com UI or GitHub CLI.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Repository Management & Source Code Hosting",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Codespaces UI – https://docs.github.com/en/codespaces",
              "Codespaces CLI integration – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli",
              "Codespaces overview – https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces"
            ],
            "related_data": [
              "Repository source and configuration files mounted into the codespace",
              "Dev container configuration and any codespace‑scoped secrets"
            ],
            "notes": "This step mirrors normal developer behavior; exfiltration begins once the codespace environment is used as a launching point."
          },
          {
            "step_id": 2,
            "description": "Inside the Codespace terminal or IDE, the attacker collects target data by copying repository contents (and any additional reachable repositories) into local archives or staging directories inside the codespace file system.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "VS Code / IDE remote integration with Codespaces – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code"
            ],
            "related_data": [
              "Working copies of source code and configuration files",
              "Any additional files or credentials stored in the dev container image or prebuilds"
            ],
            "notes": "Codespaces prebuilds or devcontainer images may already contain cached artifacts or tools that expand what is available to copy."
          },
          {
            "step_id": 3,
            "description": "From within the Codespace, the attacker uses standard network tools (for example, curl, cloud‑storage CLIs, or even git to an attacker‑owned remote) to upload the staged archives to attacker‑controlled infrastructure or third‑party web services over HTTPS.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "Codespaces networking behavior and policies – https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces"
            ],
            "related_data": [
              "HTTP/HTTPS request bodies containing compressed source, configs, or other files",
              "Potentially additional metadata (for example, repository names, branch names) included in the uploads"
            ],
            "notes": "This mirrors ATT&CK examples where adversaries use common tools like curl or cloud‑sync utilities to push staged archives to cloud storage."
          },
          {
            "step_id": 4,
            "description": "The attacker accesses their external web service account out-of-band and downloads or processes the uploaded data, while optionally deleting or expiring the Codespace to reduce local forensic traces.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "External web service consoles/APIs (outside GitHub)"
            ],
            "related_data": [
              "Archives and files now resident in attacker‑controlled cloud storage or services"
            ],
            "notes": "Codespace deletion does not affect data that has already been transmitted off‑platform."
          }
        ],
        "capabilities_used": [
          "Cloud Development Environments with GitHub Codespaces",
          "Projects & Codespaces Automation and Prebuilds",
          "Repository Management & Source Code Hosting",
          "Authentication & Account Security Management",
          "Billing & Usage Management"
        ],
        "interfaces_used": [
          "Codespaces UI – https://docs.github.com/en/codespaces",
          "What are GitHub Codespaces? – https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces",
          "Codespaces with GitHub CLI – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli",
          "Codespaces in VS Code – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code",
          "Codespaces prebuild configuration – https://docs.github.com/en/codespaces/prebuilding-your-codespaces",
          "Org/enterprise settings governing Codespaces – https://docs.github.com/en/organizations and https://docs.github.com/en/enterprise-cloud@latest/admin"
        ],
        "data_accessed": [
          "Repository source code and history checked out into Codespaces",
          "Dev container images and prebuild snapshots that may include additional tools or cached data",
          "Codespaces‑scoped secrets and environment variables used in development workflows"
        ],
        "preconditions_required": [
          "Codespaces must be enabled for the organization/repository, and organizational policies must permit the attacker’s account to create and connect to codespaces.",
          "The attacker controls a valid account (already satisfying MFA/SSO and any domain/admin approval policies) with at least read access to the target repositories and Codespaces eligibility.",
          "Network access from Codespaces to the broader internet must not be fully egress‑restricted; outbound HTTPS to attacker‑controlled services must be permitted by Codespaces network policies and any corporate egress controls."
        ],
        "constraints_encountered": [
          "Billing & Usage Management: Actions and Codespaces are metered; unusually high Codespaces usage devoted solely to data collection may create billing anomalies.",
          "Org/Enterprise Codespaces Network Policies: Some enterprises may restrict Codespaces egress to specific domains or private networks, which can block direct uploads to arbitrary attacker infrastructure; in such cases this vector is constrained or forced to use only allowed third‑party endpoints."
        ],
        "evasion_considerations": [
          "Keep Codespaces usage patterns similar to normal development (for example, editing, building, and testing) while intermittently uploading archives to external services.",
          "Use widely accepted developer tools (for example, language package registries, cloud CLIs) as the mechanism for outbound transfers to blend with normal dependency and deployment traffic.",
          "Use small, incremental uploads rather than large monolithic archives to avoid conspicuous bursts of outbound data or billing anomalies.",
          "Leverage prebuilds or devcontainer customization to automatically stage data whenever a codespace is created, minimizing manual steps and making activity appear as part of normal environment provisioning."
        ],
        "comments": "Codespaces gives an attacker a full Linux development environment with the target repository mounted; any outbound network connection made from that environment is effectively a web‑service‑based exfiltration channel for repository contents and derived data.",
        "data_exfiltrated": "Full or partial copies of repository source code and any additional data available in Codespaces are uploaded over HTTPS from the codespace environment to attacker-controlled cloud storage or web services."
      },
      {
        "can_achieve": true,
        "technique_name": "Exfiltration Over Webhook",
        "technique_stix_id": "attack-pattern--43f2776f-b4bd-4118-94b8-fee47e69676d",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised repository admin, organization owner, enterprise admin, or GitHub App configuration, the attacker registers new webhooks (or modifies existing ones) that point to attacker-controlled HTTPS endpoints, selecting broad event types such as push, pull_request, issues, and security-related events.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Webhook configuration UI – https://docs.github.com/en/webhooks",
              "Org webhooks REST API – https://docs.github.com/en/rest/orgs/webhooks",
              "Global webhooks for enterprises – https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks",
              "GitHub App webhook configuration – https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events"
            ],
            "related_data": [
              "Webhook endpoint URLs and shared secrets",
              "Configuration of subscribed events for repos/orgs/enterprise"
            ],
            "notes": "At enterprise scope, a single global webhook can receive events from all organizations in the enterprise, greatly amplifying reach."
          },
          {
            "step_id": 2,
            "description": "As normal activity occurs (pushes, PRs, issue updates, security events), GitHub’s Webhook Delivery Service sends JSON payloads for each subscribed event to the attacker’s endpoint over HTTPS, including repository, commit, issue, and sometimes security metadata.",
            "related_capabilities": [
              "Webhook Event Delivery"
            ],
            "related_interfaces": [
              "Webhook events and payloads reference – https://docs.github.com/en/webhooks/webhook-events-and-payloads"
            ],
            "related_data": [
              "Push event payloads containing commit metadata, branch names, and sometimes abbreviated diffs or file paths",
              "Issue and PR event payloads including titles, bodies, labels, and links to code changes",
              "Security‑related payloads (for example, from Dependabot or code scanning integrations) referencing alerts and affected resources"
            ],
            "notes": "Although payloads may not contain full code blobs, they often include enough context for sensitive information (for example, credentials in commit messages or issue bodies) and can be used to drive follow‑on API pulls."
          },
          {
            "step_id": 3,
            "description": "The attacker’s webhook receiver stores incoming payloads and can optionally use the referenced URLs and IDs to call GitHub REST APIs (using a separate compromised token or GitHub App credentials) to fetch full repository contents, diffs, or security alerts associated with each event.",
            "related_capabilities": [
              "GitHub REST API",
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "REST APIs for repos/issues/pulls/security – https://docs.github.com/en/rest",
              "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps"
            ],
            "related_data": [
              "Full commit diffs and file contents referenced by push/PR events",
              "Associated issues, PRs, and alerts pulled via API using event metadata"
            ],
            "notes": "This turns the webhook stream into a trigger mechanism for targeted, automated data harvesting tied to new or changed resources."
          },
          {
            "step_id": 4,
            "description": "The attacker aggregates and analyzes the stored webhook payloads and any additional data pulled via API on infrastructure they control, effectively maintaining a near–real-time external mirror of key activity and selected content.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Webhook delivery logs (for troubleshooting and redelivery) – https://docs.github.com/en/webhooks",
              "REST API for webhook redelivery management – https://docs.github.com/en/rest/orgs/webhooks"
            ],
            "related_data": [
              "Historical stream of repository/issue/PR/security activity",
              "Optionally, reconstructed or mirrored subsets of code and configuration associated with events"
            ],
            "notes": "Webhook redelivery features can be abused to replay past events to the attacker’s endpoint if they have access to webhook management interfaces."
          }
        ],
        "capabilities_used": [
          "Webhook Event Delivery",
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "Webhook configuration and payload docs – https://docs.github.com/en/webhooks and https://docs.github.com/en/webhooks/webhook-events-and-payloads",
          "Org webhooks REST API – https://docs.github.com/en/rest/orgs/webhooks",
          "GitHub Apps configuration and APIs – https://docs.github.com/en/apps and https://docs.github.com/en/rest/apps/apps",
          "Enterprise global webhooks – https://docs.github.com/en/enterprise-cloud@latest/admin/monitoring-activity-in-your-enterprise/exploring-user-activity-in-your-enterprise/managing-global-webhooks",
          "REST API root – https://docs.github.com/en/rest"
        ],
        "data_accessed": [
          "Webhook payloads containing repository, organization, user, and activity metadata",
          "Summaries of commits, branches, and file paths in push/PR events",
          "Issue and PR content (titles, bodies, labels, links) included in events",
          "References to security alerts and configuration changes, where events are generated",
          "Any full resources subsequently fetched via REST API using IDs from the webhook payloads"
        ],
        "preconditions_required": [
          "The attacker controls an account or GitHub App configuration with permission to create or modify repository, organization, app, or enterprise webhooks.",
          "Webhook delivery to arbitrary external endpoints must be allowed by organization/enterprise policies (for example, no egress filtering that blocks the attacker’s domain).",
          "If the attacker also wants to pull full resource bodies based on webhook hints, they must hold or control a token/App installation with corresponding read permissions for those resources.",
          "The compromised admin/App identity is already onboarded and approved under MFA/SSO and any admin-approval policies."
        ],
        "constraints_encountered": [
          "IP Allowlisting (for inbound user/API access) does not generally restrict GitHub’s outbound webhook requests, but if the enterprise uses network controls to restrict which external endpoints webhooks may target, the attacker must host the receiver on an allowed domain or service.",
          "Rate Limiting: Excessive webhook configuration changes or API calls made by the attacker’s follow‑on harvesting process can be rate‑limited by GitHub or environment controls, so collection logic must respect quotas."
        ],
        "evasion_considerations": [
          "Configure webhooks to point to domains and paths that resemble legitimate integrations (for example, monitoring, SIEM, or chat services) to blend in with normal usage.",
          "Subscribe only to event types that appear business‑justified (for example, pushes and issues) and avoid obviously sensitive or unusual event sets that might draw attention.",
          "Throttle any follow‑on REST API harvesting driven by webhook events to avoid rate‑limit violations and anomalous traffic patterns.",
          "Leverage existing webhooks or App configurations where possible by surreptitiously changing destinations or adding additional endpoints, rather than creating entirely new, obvious webhooks."
        ],
        "comments": "Webhooks are a natural SaaS exfiltration channel: they are designed to continuously push structured data to external HTTP endpoints, and at enterprise scope they can expose activity across all organizations to attacker‑controlled infrastructure.",
        "data_exfiltrated": "A continuous stream of JSON webhook payloads capturing repository, issue, pull request, and security-related activity (plus any full resources fetched via follow-on API calls) is delivered over HTTPS to attacker-controlled endpoints outside the GitHub tenant."
      },
      {
        "can_achieve": true,
        "technique_name": "Exfiltration Over Web Service",
        "technique_stix_id": "attack-pattern--40597f16-0963-4249-bf4c-ac93b7fb9807",
        "method_steps": [
          {
            "step_id": 1,
            "description": "A malicious or compromised GitHub App or OAuth app with existing installations in the target organization(s) uses its app/installation tokens to enumerate all installations, organizations, repositories, and other resources it has been granted access to.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub Apps docs – https://docs.github.com/en/apps/using-github-apps/about-using-github-apps",
              "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps",
              "REST API root – https://docs.github.com/en/rest"
            ],
            "related_data": [
              "App installation records and scopes",
              "Lists of repositories per installation",
              "Organization and repository metadata"
            ],
            "notes": "This mirrors how legitimate apps discover their scope, but the goal here is to map the full data accessible for exfiltration."
          },
          {
            "step_id": 2,
            "description": "From the app’s external backend, the attacker uses short‑lived installation access tokens to call GitHub REST APIs and systematically pull repository contents, issues, pull requests, projects, and optionally security alerts for each installation.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "GitHub REST API",
              "Repository Management & Source Code Hosting",
              "Issue Tracking & Work Management with GitHub Issues",
              "Project Planning & Reporting with GitHub Projects",
              "Code Scanning for Static Application Security Testing",
              "Dependency & Supply Chain Management with Dependabot",
              "Secret Scanning & Push Protection"
            ],
            "related_interfaces": [
              "/repos, /issues, /pulls, /projects REST APIs – https://docs.github.com/en/rest/repos/repos, https://docs.github.com/en/rest/issues/issues, https://docs.github.com/en/rest/pulls/pulls, https://docs.github.com/en/rest/projects/projects",
              "Security REST APIs – https://docs.github.com/en/rest/code-scanning/code-scanning, https://docs.github.com/en/rest/dependabot/alerts, https://docs.github.com/en/rest/secret-scanning/secret-scanning"
            ],
            "related_data": [
              "Repository source and Git metadata",
              "Issues, PRs, and project items",
              "Security alerts and configurations accessible to the app"
            ],
            "notes": "Because GitHub Apps use fine‑grained permissions, the blast radius is defined by what the victim organization has granted—often broad for powerful integrations."
          },
          {
            "step_id": 3,
            "description": "The app backend stores harvested data in attacker-controlled cloud infrastructure (for example, object storage, databases, or other SaaS platforms), optionally compressing and encrypting archives before storage.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform"
            ],
            "related_interfaces": [
              "External storage/service APIs (outside GitHub) used by the app backend"
            ],
            "related_data": [
              "Mirrored source code, configuration, and metadata for all accessible repositories",
              "Aggregated security findings and organization metadata"
            ],
            "notes": "From the victim’s perspective, all traffic appears as normal API access from a trusted GitHub App; the exfiltration path is entirely through the app’s backend and its own integrations with external services."
          },
          {
            "step_id": 4,
            "description": "If the app is also configured with a webhook, it receives ongoing event payloads from GitHub, which it can use to trigger incremental updates (for example, pulling only changed repositories or new alerts) and immediately forward or store them in external services.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "GitHub App webhooks – https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-github-app-that-responds-to-webhook-events",
              "Webhook events and payloads – https://docs.github.com/en/webhooks/webhook-events-and-payloads"
            ],
            "related_data": [
              "App‑scoped webhook payloads (pushes, issues, PRs, security events)",
              "Incremental updates to previously harvested data"
            ],
            "notes": "This turns the malicious app into a long‑lived exfiltration agent, continuously synchronizing high‑value data to attacker‑controlled infrastructure."
          }
        ],
        "capabilities_used": [
          "GitHub Apps & OAuth Apps Platform",
          "GitHub REST API",
          "Webhook Event Delivery",
          "Repository Management & Source Code Hosting",
          "Issue Tracking & Work Management with GitHub Issues",
          "Project Planning & Reporting with GitHub Projects",
          "Code Scanning for Static Application Security Testing",
          "Dependency & Supply Chain Management with Dependabot",
          "Secret Scanning & Push Protection",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
        ],
        "interfaces_used": [
          "GitHub Apps management UI – https://docs.github.com/en/apps",
          "GitHub Apps REST API – https://docs.github.com/en/rest/apps/apps",
          "REST API root and core resources – https://docs.github.com/en/rest",
          "Webhook docs – https://docs.github.com/en/webhooks and https://docs.github.com/en/webhooks/webhook-events-and-payloads",
          "Org/enterprise app installation flows (through organization and enterprise settings) – https://docs.github.com/en/organizations and https://docs.github.com/en/enterprise-cloud@latest/admin"
        ],
        "data_accessed": [
          "All repositories, issues, PRs, and projects within the installations’ scopes",
          "Security alerts (code scanning, Dependabot, secret scanning) where the app has security-related permissions",
          "Org and repo metadata, including membership/permissions where granted",
          "Ongoing event streams via app webhooks"
        ],
        "preconditions_required": [
          "The GitHub App or OAuth app is installed in the victim organization(s) with read access to the target resources (repositories, issues, security alerts, etc.).",
          "The attacker either controls the app’s backend (for example, as the app developer) or has compromised that backend and its secrets.",
          "Organization or enterprise policies permit installation and usage of such apps; if app whitelisting is in place, the malicious app must already be approved.",
          "The app’s authentication to GitHub (app keys, client secrets) remains valid and is not revoked."
        ],
        "constraints_encountered": [
          "Rate Limiting: GitHub API rate limits apply per app installation and token; large-scale harvesting must respect these limits or distribute requests across time and installations.",
          "App Permission Model: Fine‑grained permissions may limit the scope of what the app can read; the attacker is constrained by what the victim has already granted unless they can escalate app permissions or convince admins to broaden them."
        ],
        "evasion_considerations": [
          "Present the app as a legitimate integration (for example, analytics, reporting, or backup) so that broad read permissions appear justified.",
          "Throttle data collection to match expected usage patterns for similar integrations (for example, periodic syncs rather than constant high‑volume scanning).",
          "Use common cloud services as storage targets so exfiltration from the app backend appears like normal SaaS‑to‑SaaS dataflows.",
          "Avoid requesting unnecessary permissions when the app is installed to reduce suspicion, focusing on the most sensitive but plausible scopes (for example, code and issues, or security alerts)."
        ],
        "comments": "GitHub Apps are a first-class automation mechanism; once installed with broad read scopes, a malicious or compromised app can continuously mirror repositories, collaboration data, and security posture to attacker-controlled infrastructure via standard web service APIs.",
        "data_exfiltrated": "All data within the GitHub App’s installation scopes—including repositories, issues, pull requests, projects, and security alerts—is periodically or continuously copied over HTTPS from GitHub’s APIs to attacker-controlled cloud services operated by the app."
      },
      {
        "can_achieve": true,
        "technique_name": "Transfer Data to Cloud Account",
        "technique_stix_id": "attack-pattern--d4bdbdea-eaec-4071-b4f9-5105e12ea4b6",
        "method_steps": [
          {
            "step_id": 1,
            "description": "With repository admin or organization owner privileges, the attacker identifies high‑value private repositories or packages and reviews organization and enterprise policies around visibility, forking, and repository transfers.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Package Management with GitHub Packages"
            ],
            "related_interfaces": [
              "Repository settings UI – https://docs.github.com/en/repositories",
              "Organization settings UI – https://docs.github.com/en/organizations",
              "Enterprise admin settings – https://docs.github.com/en/enterprise-cloud@latest/admin",
              "Packages UI – https://docs.github.com/en/packages"
            ],
            "related_data": [
              "Repository visibility and transfer settings",
              "Org and enterprise policies governing forking and transfers",
              "Package visibility and access configuration"
            ],
            "notes": "This reconnaissance uses only administrative views that the compromised account is legitimately allowed to access."
          },
          {
            "step_id": 2,
            "description": "The attacker changes repository visibility from private/internal to public, or to a broader scope (for example, from private to internal within a large enterprise), immediately exposing code and history to a wider set of GitHub accounts, including ones under attacker control.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Repository visibility management – https://docs.github.com/en/repositories"
            ],
            "related_data": [
              "Repository metadata (visibility flag)",
              "All repository contents and Git history now readable by additional accounts"
            ],
            "notes": "Even if the attacker later reverts the visibility, any clones or forks made while public remain exfiltrated copies."
          },
          {
            "step_id": 3,
            "description": "Alternatively or additionally, the attacker transfers ownership of selected repositories to an attacker-controlled user or organization account (potentially outside the victim enterprise), using the standard repository transfer mechanism in the UI or via the REST API.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Repository transfer UI – documented under repository management in https://docs.github.com/en/repositories",
              "/repos administration endpoints – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Repository ownership metadata",
              "Complete repository contents and history now under an attacker‑controlled account"
            ],
            "notes": "This mirrors the ATT&CK \"Transfer Data to Cloud Account\" pattern: the data remains on GitHub infrastructure but shifts to a cloud account the attacker fully controls."
          },
          {
            "step_id": 4,
            "description": "For GitHub Packages, the attacker updates package visibility or publishes copies of sensitive packages to registries associated with attacker-controlled users or organizations, making artifacts available to those accounts or to the public.",
            "related_capabilities": [
              "Package Management with GitHub Packages"
            ],
            "related_interfaces": [
              "Packages visibility and access configuration – https://docs.github.com/en/packages",
              "Packages REST API – https://docs.github.com/en/rest/packages/packages"
            ],
            "related_data": [
              "Package artifacts (for example, container images, libraries) and metadata"
            ],
            "notes": "Sensitive compiled artifacts or images can reveal internal IP, configuration, or proprietary code even without full repository access."
          },
          {
            "step_id": 5,
            "description": "From separate attacker‑controlled GitHub accounts (or anonymously, if made public), the attacker clones or pulls the now‑exposed repositories and packages to infrastructure they control, optionally re‑mirroring them to other Git hosting services or cloud storage.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Package Management with GitHub Packages"
            ],
            "related_interfaces": [
              "Git over HTTPS/SSH for clones – https://docs.github.com/en/get-started/git-basics/set-up-git",
              "Package consumption using ecosystem tooling – https://docs.github.com/en/packages/working-with-a-github-packages-registry"
            ],
            "related_data": [
              "Full local copies of repositories and packages on attacker infrastructure"
            ],
            "notes": "Even if the victim notices and revokes access later, these external copies remain under attacker control."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Package Management with GitHub Packages",
          "GitHub REST API"
        ],
        "interfaces_used": [
          "Repository settings and visibility controls – https://docs.github.com/en/repositories",
          "Org settings for repository policies and forking – https://docs.github.com/en/organizations",
          "Enterprise admin repository policy interfaces – https://docs.github.com/en/enterprise-cloud@latest/admin",
          "Packages configuration UIs – https://docs.github.com/en/packages",
          "REST /repos and /packages APIs – https://docs.github.com/en/rest/repos/repos and https://docs.github.com/en/rest/packages/packages",
          "Git clone/fetch over HTTPS/SSH – https://docs.github.com/en/get-started/git-basics/set-up-git"
        ],
        "data_accessed": [
          "Full repository contents and Git history of targeted projects",
          "Repository metadata including visibility and ownership",
          "Packages and versions associated with the repositories",
          "Organization and enterprise policy settings around visibility, forking, and transfers"
        ],
        "preconditions_required": [
          "The attacker’s compromised identity holds repository admin or organization owner roles that allow changing visibility and initiating repository transfers, or equivalent API permissions via PAT/GitHub App.",
          "Organization and enterprise policies must allow the chosen visibility changes or transfers; or the attacker must also control the enterprise/org policies to relax restrictions.",
          "For package exfiltration, the attacker must have maintainer/admin rights on the relevant packages or publishing workflows.",
          "Separate attacker-controlled GitHub accounts (or external Git hosting accounts) exist to receive transferred repositories or to clone newly public repos."
        ],
        "constraints_encountered": [
          "Enterprise/Org Policies: Enterprises may enforce strict rules preventing transfers of private repositories outside the enterprise or disallowing forking private repos to external accounts; without enterprise‑level compromise, some cross‑tenant transfers may be blocked.",
          "Audit and Security Logging: Visibility changes and transfers are recorded in organization/enterprise audit logs, increasing detection likelihood, though they do not technically prevent exfiltration."
        ],
        "evasion_considerations": [
          "Temporarily mark repositories as public or transfer them to attacker‑controlled accounts only briefly, cloning them quickly and then reverting visibility or deleting the external copies to reduce the visible window of exposure.",
          "Transfer or expose only selected repositories at a time to avoid large, anomalous policy changes that might trigger reviews.",
          "Use intermediate organizations or accounts that appear legitimate (for example, similarly named teams) to mask the true ownership of transferred repositories.",
          "For packages, adjust visibility gradually or mirror them under seemingly benign public projects to reduce suspicion."
        ],
        "comments": "Instead of pulling data directly over the network, this vector repurposes GitHub’s own sharing and ownership features to move repositories and packages into attacker-controlled GitHub accounts or into public scope, after which normal cloning and package pulls complete the exfiltration.",
        "data_exfiltrated": "Private repositories and package artifacts are effectively relocated—by visibility changes, transfers, or republishing—to attacker-controlled GitHub accounts or public scope, after which full copies are cloned or downloaded outside the victim’s organizational boundary."
      }
    ],
    "summary": "Given GitHub’s documented capabilities, exfiltration is realistically achievable through multiple channels once an attacker controls a sufficiently privileged account, token, or app:\n\n• Direct bulk download via Git and the REST API (Exfiltration Over Alternative Protocol) allows mass export of repositories, collaboration data, security alerts, and billing/usage information over HTTPS/SSH using only standard clients.\n\n• GitHub Actions and Codespaces provide arbitrary code execution with outbound HTTPS, enabling automated uploads of archives and secrets to attacker-controlled web services (Exfiltration Over Web Service) that can closely mimic legitimate CI/CD or development traffic.\n\n• Repository, organization, app, and enterprise webhooks can continuously push rich JSON payloads about code, issues, and security events to attacker endpoints (Exfiltration Over Webhook), and malicious GitHub Apps can systematically harvest and forward tenant data from their external backends.\n\n• Administrative features for changing repository/package visibility and transferring repositories allow data to be rehomed directly into attacker-controlled GitHub accounts or public scope (Transfer Data to Cloud Account), from which it can be cloned or downloaded at will.\n\nEnvironment constraints like MFA, SSO-only auth, domain-based registration, admin approval, and CAPTCHAs mainly harden initial access; exfiltration vectors remain viable once a legitimate, policy-compliant identity or app is compromised. Rate limiting, IP allowlisting for user/API access, and enterprise policies on Actions, Codespaces, webhooks, and transfers can slow or narrow these vectors but generally do not eliminate them if administrative roles or high-privilege tokens are under attacker control."
  },
  "impact": {
    "application_name": "GitHub",
    "vectors": [
      {
        "can_achieve": true,
        "technique_name": "Financial Theft",
        "technique_stix_id": "attack-pattern--851e071f-208d-4c79-adc6-5974c85c78f3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "Using a compromised account with write/admin access in a target organization repository where Actions is enabled, the attacker selects or creates a repository whose workflows they can modify.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Repository web UI (Repositories tab) – https://docs.github.com/en/repositories",
              "Git CLI / GitHub CLI to push changes – https://docs.github.com/en/get-started/git-basics/set-up-git",
              "Actions tab in the repository UI – https://docs.github.com/en/actions"
            ],
            "related_data": [
              "Repositories and repository metadata",
              "Commits, branches, and tags",
              "Workflow definitions (YAML files under .github/workflows)",
              "Account credentials and tokens used to authenticate the attacker"
            ],
            "notes": "Assumes the attacker has already passed MFA, SSO, IP allowlisting, CAPTCHA, and other environment constraints by compromising a valid account/session."
          },
          {
            "step_id": 2,
            "description": "The attacker creates or modifies one or more workflow YAML files to define highly compute-intensive jobs (for example, large job matrices, long-running loops, or heavy build/test tasks) that run exclusively on GitHub-hosted runners.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Workflow YAML definitions under .github/workflows – https://docs.github.com/en/actions/reference/workflows-and-actions",
              "Actions concepts docs – https://docs.github.com/en/actions/concepts"
            ],
            "related_data": [
              "Workflow definitions (YAML) specifying jobs, steps, and runners",
              "Runner configuration and labels indicating use of GitHub-hosted runners"
            ],
            "notes": "Using GitHub-hosted runners ensures all consumed minutes are billable to the victim. This mirrors real-world resource-abuse patterns used by financially motivated actors, but here focused on Actions minutes rather than generic cloud compute."
          },
          {
            "step_id": 3,
            "description": "They configure triggers to maximize execution frequency and fan-out, such as cron schedules (for example, every few minutes), push/pull_request events on frequently updated branches, and manual workflow_dispatch triggers.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Workflow syntax for triggers – https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax"
            ],
            "related_data": [
              "Triggers and event payload mappings for each workflow (push, schedule, workflow_dispatch, etc.)",
              "Repository events (pushes, pull requests) that will fire workflows"
            ],
            "notes": "By combining schedules with event-based triggers and large matrices, the attacker can keep many runners busy in parallel."
          },
          {
            "step_id": 4,
            "description": "The attacker repeatedly triggers workflows (for example, by pushing no-op commits, force-pushing branches, or invoking workflow_dispatch via the REST API or UI) to sustain a high volume of concurrent runs.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Actions run management UI – https://docs.github.com/en/actions/how-tos/manage-workflow-runs",
              "REST API for workflows – https://docs.github.com/en/rest/actions/workflows",
              "REST API for workflow runs – https://docs.github.com/en/rest/actions/workflow-runs"
            ],
            "related_data": [
              "Actions job execution metadata and logs",
              "Artifacts and caches produced by workflows",
              "API rate limit metadata related to workflow APIs"
            ],
            "notes": "If API rate limiting is encountered, the attacker can throttle requests or distribute them across multiple repositories or tokens."
          },
          {
            "step_id": 5,
            "description": "If the compromised account has org/enterprise admin or billing roles, the attacker loosens any restrictive Actions policies and adjusts budgets or alerts upward to avoid automatic throttling or early detection of abnormal usage.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Organization settings UI – https://docs.github.com/en/organizations",
              "Enterprise admin UI – https://docs.github.com/en/enterprise-cloud@latest/admin",
              "Billing settings and dashboards – https://docs.github.com/en/billing",
              "Billing usage REST API – https://docs.github.com/en/rest/billing/usage"
            ],
            "related_data": [
              "Org-level feature flags and Actions policies",
              "Enterprise-wide policies for Actions and repositories",
              "Budgets, alerts, and cost centers",
              "Product usage metrics for Actions minutes"
            ],
            "notes": "GitHub explicitly calls out that budgets and alerts can surface anomalous Actions workloads; an attacker may try to preempt or suppress those signals."
          },
          {
            "step_id": 6,
            "description": "Over the billing cycle, the sustained high volume of GitHub-hosted workflow execution drives Actions usage far beyond the included allowance, causing a substantial unexpected bill and potentially contributing to account lock or service disruption if invoices go unpaid.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Billing & Metering Service",
              "Billing & Usage Flow"
            ],
            "related_interfaces": [
              "Billing and licensing pages – https://docs.github.com/en/billing",
              "Viewing usage of metered products – https://docs.github.com/en/billing/how-tos/products/view-product-use"
            ],
            "related_data": [
              "Billing accounts and contacts",
              "Aggregated Actions minutes usage per account",
              "Invoices and payment transactions"
            ],
            "notes": "This is a direct financial impact: the victim pays for compute the attacker consumed, similar in outcome to other Financial Theft campaigns that abuse cloud resources."
          }
        ],
        "capabilities_used": [
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management",
          "GitHub REST API",
          "Billing & Metering Service",
          "Billing & Usage Flow",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Repository web UI – https://docs.github.com/en/repositories",
          "Git / GitHub CLI – https://docs.github.com/en/get-started/git-basics/set-up-git",
          "Actions tab UI – https://docs.github.com/en/actions",
          "Workflow YAML under .github/workflows – https://docs.github.com/en/actions/reference/workflows-and-actions",
          "REST API for workflows – https://docs.github.com/en/rest/actions/workflows",
          "REST API for workflow runs – https://docs.github.com/en/rest/actions/workflow-runs",
          "Billing settings and dashboards – https://docs.github.com/en/billing",
          "Billing usage REST API – https://docs.github.com/en/rest/billing/usage"
        ],
        "data_accessed": [
          "Repositories and repository metadata",
          "Workflow definitions (YAML files under .github/workflows)",
          "Actions job execution logs, artifacts, and caches",
          "Runner configuration and labels (GitHub-hosted vs self-hosted)",
          "Repository events (pushes, pull requests, schedules)",
          "Billing accounts and contacts",
          "Aggregated Actions minutes usage and budgets",
          "Invoices and billing statements"
        ],
        "preconditions_required": [
          "Attacker controls a user account, personal access token, or GitHub App installation with at least write access to a repository in the victim organization where Actions is enabled.",
          "To adjust org- or enterprise-level Actions policies or budgets, the attacker must control an organization owner, enterprise owner, or billing manager role.",
          "The compromised account has already satisfied global environment constraints such as MFA Required, IP Allowlisting, SSO-Only Authentication, CAPTCHA Protection, Email Verification Required, Domain-Based Registration, and Admin Approval Required."
        ],
        "constraints_encountered": [
          "Rate Limiting on REST API endpoints for Actions workflows and runs may slow automated triggering of runs.",
          "Organization and enterprise Actions policies may restrict use of GitHub-hosted runners, disallow certain workflows, or require approval for first-time workflows.",
          "Actions minutes, concurrency limits, and GitHub’s platform-wide quotas may cap the maximum scale of abusive workloads.",
          "Budgets and alerts in Billing & Usage Management can highlight unusual Actions consumption and may trigger manual or automated mitigation by defenders."
        ],
        "evasion_considerations": [
          "Distribute abusive workflows across many repositories and organizations to stay below per-repo or per-org anomaly thresholds and rate limits.",
          "Name malicious workflows and jobs to resemble existing CI/CD pipelines to reduce the chance that unusual runs are noticed in the Actions UI.",
          "Prefer scheduled and event-based triggers over frequent manual re-runs via API to avoid standing out in audit logs as repeated manual workflow invocations.",
          "Ramp up Actions usage gradually over multiple billing cycles rather than in a single spike, making cost growth look like organic CI expansion."
        ],
        "comments": "GitHub explicitly highlights malicious Actions workloads as a billing risk in its billing documentation. This vector repurposes normal CI/CD capabilities purely to generate billable compute for financial gain, aligning with the Financial Theft technique even though the mechanism is resource overuse rather than direct transfer of funds.",
        "impact_achieved": "Victim organization incurs substantial unplanned GitHub Actions charges due to attacker-driven workflow execution, potentially leading to financial loss and, if bills go unpaid, degraded access or account lock that impacts service availability."
      },
      {
        "can_achieve": true,
        "technique_name": "Financial Theft",
        "technique_stix_id": "attack-pattern--851e071f-208d-4c79-adc6-5974c85c78f3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "With a compromised account that can create Codespaces in one or more organization repositories, the attacker confirms that Codespaces is enabled and reviews any org-level restrictions on machine types, regions, and retention.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)"
            ],
            "related_interfaces": [
              "Codespaces overview and settings UI – https://docs.github.com/en/codespaces",
              "Organization settings UI for Codespaces – https://docs.github.com/en/codespaces/about-codespaces/what-are-codespaces"
            ],
            "related_data": [
              "Codespaces policy settings at the org and repository level",
              "Codespaces quotas and allowed machine types per organization",
              "List of repositories where the user can create codespaces"
            ],
            "notes": "GitHub organizations can centrally control whether Codespaces is enabled, which machine types are available, and how long environments are retained."
          },
          {
            "step_id": 2,
            "description": "If the attacker controls org/enterprise admin roles, they relax Codespaces restrictions by enabling larger machine types, permissive retention, and broad repository eligibility to maximize potential compute consumption.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Enterprise Cloud admin UI – https://docs.github.com/en/enterprise-cloud@latest/admin",
              "Organization Codespaces settings – https://docs.github.com/en/codespaces"
            ],
            "related_data": [
              "Org-level feature flags and Codespaces policies",
              "Enterprise-level policies applying Codespaces across organizations",
              "Billing plans and quotas for Codespaces hours"
            ],
            "notes": "This augments the impact by allowing more expensive machines and more users/repositories to consume paid hours."
          },
          {
            "step_id": 3,
            "description": "Using the Codespaces UI, GitHub CLI, or IDE integration, the attacker rapidly creates many codespaces across multiple repositories and branches, preferentially selecting the largest available machine types and avoiding auto-shutdown where possible.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces",
              "Projects & Codespaces Automation and Prebuilds",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Codespaces web UI – https://docs.github.com/en/codespaces",
              "GitHub CLI for Codespaces – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli",
              "Codespaces in Visual Studio Code – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code"
            ],
            "related_data": [
              "Codespace instances, including machine type and active time",
              "Dev container configuration (devcontainer.json, Dockerfiles)",
              "Repository source trees checked out into each codespace"
            ],
            "notes": "Even idle codespaces consume billable storage and, when running, CPU/RAM capacity billed as Codespaces hours."
          },
          {
            "step_id": 4,
            "description": "To keep environments running and consuming compute, the attacker runs long-lived tasks inside each codespace (for example, background processes or continuous builds) and ensures they remain active for extended periods or repeatedly re-opens them.",
            "related_capabilities": [
              "Cloud Development Environments with GitHub Codespaces"
            ],
            "related_interfaces": [
              "Codespaces terminals and IDE sessions via browser/VS Code – https://docs.github.com/en/codespaces"
            ],
            "related_data": [
              "Codespaces runtime and activity telemetry used for metering",
              "Persistent volumes and snapshots tied to each codespace"
            ],
            "notes": "Unlike Actions, this consumption is interactive but can still be orchestrated by a malicious actor to run continuously."
          },
          {
            "step_id": 5,
            "description": "If the attacker can configure Codespaces prebuilds, they enable prebuilds for frequently-changing branches so that background jobs automatically build images whenever code is pushed, further increasing automated compute usage without manual involvement.",
            "related_capabilities": [
              "Projects & Codespaces Automation and Prebuilds",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Codespaces prebuild configuration UI – https://docs.github.com/en/codespaces/prebuilding-your-codespaces",
              "Repository settings for Codespaces/prebuilds – https://docs.github.com/en/codespaces"
            ],
            "related_data": [
              "Codespaces prebuild configurations and VM images",
              "Repository events (pushes) that trigger prebuilds"
            ],
            "notes": "Prebuilds allow substantial automated compute to be consumed even if no developer actively uses the environment."
          },
          {
            "step_id": 6,
            "description": "Across a billing period, the inflated number of long-lived codespaces and frequent prebuilds drives Codespaces usage far beyond the included quota, increasing the victim’s monthly bill.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Billing & Metering Service",
              "Billing & Usage Flow"
            ],
            "related_interfaces": [
              "Billing and licensing pages – https://docs.github.com/en/billing",
              "Billing usage REST API – https://docs.github.com/en/rest/billing/usage"
            ],
            "related_data": [
              "Aggregated Codespaces hours per account",
              "Budgets and alerts configured for Codespaces usage",
              "Invoices reflecting overage usage"
            ],
            "notes": "This mirrors other Financial Theft campaigns where adversaries abuse cloud-hosted development or compute environments to shift cost onto victims."
          }
        ],
        "capabilities_used": [
          "Cloud Development Environments with GitHub Codespaces",
          "Projects & Codespaces Automation and Prebuilds",
          "Repository Management & Source Code Hosting",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Usage Management",
          "GitHub REST API",
          "Billing & Metering Service",
          "Billing & Usage Flow",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Codespaces web UI – https://docs.github.com/en/codespaces",
          "GitHub CLI for Codespaces – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-with-github-cli",
          "Codespaces in Visual Studio Code – https://docs.github.com/en/codespaces/developing-in-a-codespace/using-github-codespaces-in-visual-studio-code",
          "Codespaces prebuilds configuration – https://docs.github.com/en/codespaces/prebuilding-your-codespaces",
          "Organization settings UI – https://docs.github.com/en/organizations",
          "Enterprise admin UI – https://docs.github.com/en/enterprise-cloud@latest/admin",
          "Billing pages – https://docs.github.com/en/billing",
          "Billing usage REST API – https://docs.github.com/en/rest/billing/usage"
        ],
        "data_accessed": [
          "Codespace instances and associated configuration",
          "Dev container definitions (devcontainer.json, Dockerfiles)",
          "Repository code and branches checked out into codespaces",
          "Codespaces prebuild configurations and images",
          "Org and enterprise Codespaces policy settings",
          "Aggregated Codespaces usage metrics and budgets",
          "Billing accounts, invoices, and payment methods"
        ],
        "preconditions_required": [
          "Attacker controls a personal account or token allowed to create Codespaces for at least one repository in the victim organization.",
          "To relax Codespaces restrictions or enable expensive machine types, the attacker must hold organization owner or enterprise admin privileges.",
          "The compromised account has already satisfied MFA, SSO-only authentication, IP allowlisting, and other environment-wide access controls."
        ],
        "constraints_encountered": [
          "Organization and enterprise Codespaces quotas and machine-type restrictions limit the maximum number and size of environments the attacker can create.",
          "Budgets and alerts for Codespaces usage can flag rapid growth in hours consumed.",
          "If administrators have disabled Codespaces or limited it to specific repos or teams, the attacker’s impact surface is reduced to those scopes."
        ],
        "evasion_considerations": [
          "Spread codespaces across multiple repositories and users to avoid obviously anomalous activity from a single identity.",
          "Favor background prebuilds and periodic use over a sudden spike of dozens of running codespaces to make consumption resemble legitimate scaling.",
          "Avoid modifying org-level settings in ways that are clearly suspicious (such as suddenly enabling the largest machine types) if audit scrutiny is expected."
        ],
        "comments": "This vector abuses GitHub’s cloud development environments to convert the victim’s Codespaces capacity into attacker-controlled compute time, generating direct financial impact through overage charges.",
        "impact_achieved": "Victim organization is charged for a large volume of Codespaces hours created and kept running by the attacker, potentially exhausting quotas and generating significant unexpected costs."
      },
      {
        "can_achieve": true,
        "technique_name": "Financial Theft",
        "technique_stix_id": "attack-pattern--851e071f-208d-4c79-adc6-5974c85c78f3",
        "method_steps": [
          {
            "step_id": 1,
            "description": "The attacker compromises an account with organization owner or billing manager privileges for an organization that is eligible to purchase and assign GitHub Copilot licenses.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Developer Assistance with GitHub Copilot",
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Billing and licensing pages – https://docs.github.com/en/billing",
              "GitHub Copilot documentation and admin entry points – https://docs.github.com/en/copilot"
            ],
            "related_data": [
              "Billing accounts and payment methods",
              "Copilot plan and seat entitlements for the organization",
              "Org membership lists and eligible users"
            ],
            "notes": "Environment-wide constraints like MFA, SSO-only, and IP allowlisting are assumed already bypassed via the compromised privileged account."
          },
          {
            "step_id": 2,
            "description": "From the billing and Copilot administration interfaces, the attacker increases the number of purchased Copilot seats or enables a higher-tier Copilot plan for the organization.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Developer Assistance with GitHub Copilot"
            ],
            "related_interfaces": [
              "Billing settings UI – https://docs.github.com/en/billing",
              "Copilot configuration UI – https://docs.github.com/en/copilot"
            ],
            "related_data": [
              "Copilot subscription details (plan type, number of seats)",
              "Invoices and subscription change logs"
            ],
            "notes": "Copilot plans are part of GitHub’s fixed and metered billing model; expanding seats or upgrading plans directly increases monthly costs."
          },
          {
            "step_id": 3,
            "description": "The attacker assigns Copilot seats to as many accounts as possible (including dormant accounts or attacker-controlled identities that satisfy domain and approval policies), ensuring those seats remain assigned through at least one billing cycle.",
            "related_capabilities": [
              "Developer Assistance with GitHub Copilot",
              "Organization & Team Administration",
              "Billing & Usage Management"
            ],
            "related_interfaces": [
              "Copilot seat management within org/billing UI – referenced from https://docs.github.com/en/copilot and https://docs.github.com/en/billing"
            ],
            "related_data": [
              "Copilot license assignment records",
              "Organization member and collaborator lists",
              "Usage and billing data for Copilot licenses"
            ],
            "notes": "Domain-Based Registration and Admin Approval Required may limit the attacker’s ability to create entirely new paid identities, but assigning seats to existing accounts (even if unused) still incurs cost."
          },
          {
            "step_id": 4,
            "description": "The attacker leaves the expanded Copilot allocation in place, optionally suppressing or ignoring budgets and alerts, so that recurring charges for extra seats accrue on each billing date.",
            "related_capabilities": [
              "Billing & Usage Management",
              "Billing & Metering Service"
            ],
            "related_interfaces": [
              "Billing and licensing pages – https://docs.github.com/en/billing",
              "Viewing product use – https://docs.github.com/en/billing/how-tos/products/view-product-use"
            ],
            "related_data": [
              "Copilot seats consumed per billing period",
              "Invoices and payment transactions",
              "Budgets and alerts related to Copilot"
            ],
            "notes": "Unlike transient usage-based abuse, this vector relies on recurring subscription charges that may go unnoticed if billed centrally as part of a larger enterprise agreement."
          }
        ],
        "capabilities_used": [
          "Billing & Usage Management",
          "Developer Assistance with GitHub Copilot",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Billing & Metering Service",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Billing and licensing pages – https://docs.github.com/en/billing",
          "GitHub Copilot documentation and admin entry points – https://docs.github.com/en/copilot",
          "Organization settings UI – https://docs.github.com/en/organizations"
        ],
        "data_accessed": [
          "Billing account configuration, invoices, and payment methods",
          "Copilot subscription and seat allocation data",
          "Lists of organization members and eligible accounts",
          "Usage and billing metrics for Copilot licenses"
        ],
        "preconditions_required": [
          "Attacker controls an organization owner, enterprise owner, or billing manager account for an org that can purchase Copilot seats.",
          "Domain-Based Registration, Email Verification Required, CAPTCHA Protection, and Admin Approval Required may limit the attacker’s ability to create arbitrary new user accounts, so they must rely largely on existing users or pre-approved identities.",
          "Global environment constraints (MFA Required, SSO-Only Authentication, IP Allowlisting) have already been satisfied via the compromised administrative account."
        ],
        "constraints_encountered": [
          "Budgets and alerts for metered products and licenses can reveal sudden expansion of Copilot seats.",
          "Procurement and finance oversight outside GitHub may detect anomalous Copilot charges compared to historical baselines.",
          "Domain-based registration and admin approval for new accounts restrict the attacker’s ability to onboard large numbers of fake identities purely to hold seats."
        ],
        "evasion_considerations": [
          "Increase Copilot seats gradually over time and associate them with legitimate-looking accounts rather than a sudden large spike.",
          "Concentrate abuse in a subset of organizations where Copilot adoption is expected so that increases can be framed as normal growth.",
          "Avoid obvious misconfigurations such as assigning seats to clearly bogus usernames that might attract manual review."
        ],
        "comments": "This vector focuses on subscription-style financial theft by manipulating Copilot licensing rather than metered compute. Its scale is inherently more limited than Actions or Codespaces abuse but can still create non-trivial recurring costs, especially in large enterprises.",
        "impact_achieved": "Victim organization pays for an inflated number of GitHub Copilot seats that primarily benefit the attacker or are unused, resulting in ongoing unauthorized subscription charges."
      },
      {
        "can_achieve": true,
        "technique_name": "Account Access Removal",
        "technique_stix_id": "attack-pattern--b24e2a20-3b3d-4bf0-823b-1ed765398fb0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "The attacker operates from a compromised organization owner or admin account within the target organization, giving them full control over membership, teams, and repository access.",
            "related_capabilities": [
              "Organization & Team Administration",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Organization overview and settings UI – https://docs.github.com/en/organizations",
              "About organizations – https://docs.github.com/en/organizations/collaborating-with-groups-in-organizations/about-organizations"
            ],
            "related_data": [
              "Organization accounts and profiles",
              "List of members, outside collaborators, and their roles (owners, admins, members)"
            ],
            "notes": "As with enterprise ransomware operators that first remove admin accounts to delay response, this setup allows the attacker to restructure access without resistance."
          },
          {
            "step_id": 2,
            "description": "Using the organization settings UI or REST APIs, the attacker removes or demotes other organization owners and key admins to ordinary members, reducing the number of accounts that can reverse their changes.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Organization people/members UI – https://docs.github.com/en/organizations",
              "REST API for organizations – https://docs.github.com/en/rest/orgs/orgs"
            ],
            "related_data": [
              "Membership and role assignments for each user in the organization",
              "Audit logs of membership and role changes"
            ],
            "notes": "In line with observed Account Access Removal patterns, removing or demoting administrators is a precursor to broader lock-out and makes response more difficult."
          },
          {
            "step_id": 3,
            "description": "The attacker enumerates teams and adjusts team memberships so that targeted users are removed from critical teams, while attacker-controlled accounts (or newly created teams) retain access.",
            "related_capabilities": [
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Teams management UI – accessible via https://docs.github.com/en/organizations",
              "REST API for teams – https://docs.github.com/en/rest/teams/teams"
            ],
            "related_data": [
              "Teams and team hierarchies",
              "Team membership lists and mappings to repositories"
            ],
            "notes": "Because teams are often the primary mechanism for repository access, removing a user from teams can effectively strip their access across many repositories at once."
          },
          {
            "step_id": 4,
            "description": "For each critical repository, the attacker removes or downgrades collaborators and teams to eliminate write/admin access for targeted users, and, where possible, sets base permissions to 'none' so members no longer see or can clone repositories.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Repository access management UI – https://docs.github.com/en/repositories",
              "REST API for repositories – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Repository visibility (public, private, internal)",
              "Repository collaborator lists and permission levels",
              "Team-repository permission mappings"
            ],
            "notes": "This step aggressively removes access without necessarily deleting data, aligning with Account Access Removal’s focus on inhibiting access rather than destruction."
          },
          {
            "step_id": 5,
            "description": "To amplify impact, the attacker changes repository visibility from internal or public to private where allowed, then ensures only attacker-controlled teams or accounts retain access.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "Repository settings UI – https://docs.github.com/en/repositories",
              "REST API for repos – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Repository visibility and collaborator permissions",
              "Org-wide base permission settings"
            ],
            "notes": "This not only locks out internal users but can also silently disrupt external developers or partners who relied on previously visible repositories."
          }
        ],
        "capabilities_used": [
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "GitHub REST API",
          "Organizations & Enterprise Admin Service",
          "Identity & Authentication Service",
          "Authentication & Account Security Management"
        ],
        "interfaces_used": [
          "Organization settings UI – https://docs.github.com/en/organizations",
          "About organizations – https://docs.github.com/en/organizations/collaborating-with-groups-in-organizations/about-organizations",
          "Teams management UI – https://docs.github.com/en/organizations",
          "Repository settings and access UI – https://docs.github.com/en/repositories",
          "REST API for organizations – https://docs.github.com/en/rest/orgs/orgs",
          "REST API for teams – https://docs.github.com/en/rest/teams/teams",
          "REST API for repositories – https://docs.github.com/en/rest/repos/repos"
        ],
        "data_accessed": [
          "Organization membership lists and roles",
          "Teams and nested team hierarchies",
          "Repository collaborator lists and permission levels",
          "Repository visibility configuration",
          "Org-wide base permission and repository access policies",
          "Audit logs recording membership and permission changes"
        ],
        "preconditions_required": [
          "Attacker controls at least one organization owner or admin account in the target organization, or an equivalent token/GitHub App with admin:org and repo administration scopes.",
          "Enterprise-wide policies (such as SSO-only authentication) and environment controls (MFA Required, IP Allowlisting) have already been satisfied for the compromised admin account.",
          "If the organization is tightly integrated with an IdP via SCIM, the attacker must also prevent automatic re-provisioning of removed users if they want the lock-out to persist."
        ],
        "constraints_encountered": [
          "GitHub may require at least one owner per organization; the attacker must leave at least one owner account (typically their own compromised identity) to avoid blocking further admin changes.",
          "SCIM or SSO group-based provisioning may automatically re-add some users or teams, limiting how long lock-out persists without additional identity-level manipulation.",
          "REST API rate limiting may slow mass membership and permission changes, requiring batching or a longer execution window."
        ],
        "evasion_considerations": [
          "Demote or remove admins gradually and across different time windows so changes appear as normal access reviews rather than a single disruptive event.",
          "Use GitHub Apps or scripts that frame permission changes as automated governance tasks to reduce suspicion.",
          "Prefer changing roles and team memberships over outright member removal if the goal is to delay detection by targeted users."
        ],
        "comments": "This vector follows the pattern seen in many high-impact intrusions where adversaries first remove or degrade administrator access to prevent or delay incident response, here applied to GitHub organizations and repositories.",
        "impact_achieved": "Legitimate developers and administrators lose access to critical repositories and organization resources, preventing them from viewing or modifying code, and significantly impeding development, operations, and incident response."
      },
      {
        "can_achieve": true,
        "technique_name": "Account Access Removal",
        "technique_stix_id": "attack-pattern--b24e2a20-3b3d-4bf0-823b-1ed765398fb0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "The attacker identifies accounts, tokens, keys, apps, and webhooks used by CI/CD and automation (for example, deploy keys, PATs, GitHub Apps, and organization/repository webhooks) by reviewing repository, organization, and user security settings.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "GitHub Apps & OAuth Apps Platform",
              "Webhook Event Delivery",
              "Automation with GitHub Actions (User Perspective)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "User account security settings UI – https://docs.github.com/en/authentication",
              "GitHub Apps configuration UI – https://docs.github.com/en/apps",
              "Webhooks configuration UI – https://docs.github.com/en/webhooks",
              "Repository settings UI – https://docs.github.com/en/repositories"
            ],
            "related_data": [
              "Personal access tokens and SSH keys",
              "Deploy keys attached to repositories",
              "GitHub App and OAuth App installation records",
              "Repository and organization webhooks and their shared secrets",
              "Actions secrets and environment variables storing service credentials"
            ],
            "notes": "Most CI/CD and automation systems depend on a combination of these credentials to pull code, push artifacts, and receive event notifications."
          },
          {
            "step_id": 2,
            "description": "Using the compromised user or admin accounts, the attacker revokes or deletes personal access tokens, SSH keys, and deploy keys associated with automation users and service accounts.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Repository Management & Source Code Hosting"
            ],
            "related_interfaces": [
              "User security settings UI – https://docs.github.com/en/authentication",
              "REST Authentication APIs – https://docs.github.com/en/rest/authentication",
              "Repository deploy key settings – via https://docs.github.com/en/repositories and REST /repos APIs"
            ],
            "related_data": [
              "SSH keys, deploy keys, and PATs used for Git and API access",
              "Audit logs of credential revocations and key deletions"
            ],
            "notes": "This directly aligns with Account Access Removal by disabling credentials those systems rely on to authenticate to GitHub."
          },
          {
            "step_id": 3,
            "description": "The attacker uninstalls or reconfigures GitHub Apps and OAuth apps used for CI/CD (for example, build and deployment bots) at the organization and repository levels, thereby revoking their installation tokens and permissions.",
            "related_capabilities": [
              "GitHub Apps & OAuth Apps Platform",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "GitHub Apps management UI – https://docs.github.com/en/apps",
              "REST API for GitHub Apps – https://docs.github.com/en/rest/apps/apps"
            ],
            "related_data": [
              "App registrations and installation records",
              "App tokens and user access tokens tied to installations"
            ],
            "notes": "Removing or de-scoping these installations prevents the associated automation from accessing repositories or acting on behalf of the organization."
          },
          {
            "step_id": 4,
            "description": "At the repository and organization levels, the attacker deletes or disables critical webhooks or changes their shared secrets/target URLs, causing external CI/CD pipelines to stop receiving authenticated events from GitHub.",
            "related_capabilities": [
              "Webhook Event Delivery",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Webhooks configuration UI – https://docs.github.com/en/webhooks",
              "Organization webhooks REST API – https://docs.github.com/en/rest/orgs/webhooks",
              "Repository webhooks via REST /repos hooks – documented under https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Webhook endpoint URLs and shared secrets",
              "Webhook delivery logs and status"
            ],
            "notes": "Without valid webhooks, many external systems will not trigger builds or deployments even if they still hold credentials."
          },
          {
            "step_id": 5,
            "description": "Within Actions configuration, the attacker deletes or overwrites repository and organization-level secrets (such as cloud provider keys, registry tokens, and deployment credentials) so future workflow runs no longer have valid credentials for downstream systems.",
            "related_capabilities": [
              "Automation with GitHub Actions (User Perspective)",
              "Event-Driven Workflows with GitHub Actions Runners"
            ],
            "related_interfaces": [
              "Actions configuration in repository UI – https://docs.github.com/en/actions",
              "Workflow and secrets management documented under Actions reference – https://docs.github.com/en/actions/reference/workflows-and-actions"
            ],
            "related_data": [
              "Actions secrets and environment variables",
              "Workflow definitions that reference those secrets"
            ],
            "notes": "This invalidates GitHub-hosted automation, complementing the removal of external access credentials and apps."
          },
          {
            "step_id": 6,
            "description": "Optionally, the attacker commits intentionally exposed credentials (for example, outdated or cloned tokens) into repositories to trigger secret scanning integrations that may cause external providers to automatically revoke associated tokens used by CI/CD.",
            "related_capabilities": [
              "Secret Scanning & Push Protection",
              "Security Scanning, Push Protection & Policy Enforcement Pipelines"
            ],
            "related_interfaces": [
              "Secret scanning configuration and alerts UI – https://docs.github.com/en/code-security/secret-scanning",
              "Push protection workflow – https://docs.github.com/en/code-security/secret-scanning/working-with-secret-scanning-and-push-protection"
            ],
            "related_data": [
              "Detected secret tokens and metadata",
              "Secret scanning alerts and their provider integration metadata"
            ],
            "notes": "This leverages GitHub’s own security integrations to ensure that credentials are revoked at the provider side, even outside GitHub’s direct control."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "GitHub Apps & OAuth Apps Platform",
          "Webhook Event Delivery",
          "Automation with GitHub Actions (User Perspective)",
          "Event-Driven Workflows with GitHub Actions Runners",
          "Organization & Team Administration",
          "Repository Management & Source Code Hosting",
          "Secret Scanning & Push Protection",
          "Security Scanning, Push Protection & Policy Enforcement Pipelines",
          "GitHub REST API",
          "Identity & Authentication Service"
        ],
        "interfaces_used": [
          "User account security settings UI – https://docs.github.com/en/authentication",
          "REST Authentication API – https://docs.github.com/en/rest/authentication",
          "GitHub Apps management UI – https://docs.github.com/en/apps",
          "GitHub Apps REST APIs – https://docs.github.com/en/rest/apps/apps",
          "Webhooks configuration UI – https://docs.github.com/en/webhooks",
          "Organization webhooks REST API – https://docs.github.com/en/rest/orgs/webhooks",
          "Repository settings & deploy key configuration – https://docs.github.com/en/repositories",
          "Actions configuration and workflow syntax docs – https://docs.github.com/en/actions and https://docs.github.com/en/actions/reference/workflows-and-actions",
          "Secret scanning configuration and alerts UI – https://docs.github.com/en/code-security/secret-scanning"
        ],
        "data_accessed": [
          "Personal access tokens and associated scopes",
          "SSH keys and deploy keys used for repository access",
          "GitHub App and OAuth App registration and installation records",
          "Webhook endpoint URLs, shared secrets, and delivery logs",
          "Actions workflow definitions and secrets/environment variables",
          "Secret scanning alerts and partner integration metadata",
          "Audit logs of credential, app, and webhook changes"
        ],
        "preconditions_required": [
          "Attacker controls user and/or admin accounts whose tokens, keys, and apps are used by CI/CD and automation, or controls organization owner privileges that allow managing those artifacts.",
          "Environment-level controls such as MFA Required, SSO-Only Authentication, IP Allowlisting, and CAPTCHA have already been satisfied for the compromised accounts.",
          "External automation systems are actually dependent on the GitHub credentials, apps, and webhooks being modified (that is, they do not have independent, redundant credentials outside GitHub’s control)."
        ],
        "constraints_encountered": [
          "Some CI/CD systems may cache credentials or maintain separate, provider-side tokens that are not directly revocable from GitHub, limiting the completeness of lock-out.",
          "Secret scanning–driven revocation only applies for supported providers; other credentials embedded in code may not be automatically revoked.",
          "Audit logs and monitoring of app and webhook changes may allow defenders to detect and rapidly revert some of these removals."
        ],
        "evasion_considerations": [
          "Revoke credentials and uninstall apps incrementally to mimic normal key rotation or decommissioning of integrations.",
          "Alter webhook secrets or URLs rather than deleting webhooks outright so that configurations appear intact at a glance.",
          "Use account-level UI rather than bulk API changes where possible to blend in with manual administrator activity patterns."
        ],
        "comments": "This vector targets service and automation identities rather than human users, but the effect is still Account Access Removal: CI/CD, deployment, and integration systems lose their ability to authenticate to GitHub or receive events, causing widespread operational disruption.",
        "impact_achieved": "Build, deployment, and integration pipelines that rely on GitHub credentials, apps, and webhooks fail, cutting off automated access to code and repositories and significantly degrading the victim’s ability to deliver or recover services."
      },
      {
        "can_achieve": true,
        "technique_name": "Account Access Removal",
        "technique_stix_id": "attack-pattern--b24e2a20-3b3d-4bf0-823b-1ed765398fb0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "The attacker gains control of an organization owner or enterprise administrator account that can configure authentication requirements such as mandatory 2FA and SSO integrations.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Authentication index and security settings – https://docs.github.com/en/authentication",
              "Enterprise Cloud admin IAM docs – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam",
              "Organization security settings – https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "Org and enterprise security configuration (2FA enforcement, SSO settings)",
              "Lists of members and their 2FA/SSO status"
            ],
            "notes": "This mirrors real-world campaigns where adversaries change IAM and MFA policies to lock out administrators and users."
          },
          {
            "step_id": 2,
            "description": "At the organization and/or enterprise level, the attacker enforces mandatory two-factor authentication (2FA) with aggressive timelines, knowing that many targeted users do not yet have 2FA configured.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Organization security settings UI – https://docs.github.com/en/organizations",
              "Authentication docs about 2FA enforcement – https://docs.github.com/en/authentication"
            ],
            "related_data": [
              "2FA requirement flags at org/enterprise scope",
              "Per-user 2FA enrollment status"
            ],
            "notes": "GitHub supports mandatory 2FA enforcement; members who do not comply can be removed from the organization or blocked from access."
          },
          {
            "step_id": 3,
            "description": "Once 2FA enforcement takes effect, accounts without compliant second factors are automatically removed from or blocked from accessing the organization’s resources, effectively locking them out until they reconfigure security settings and are re-admitted.",
            "related_capabilities": [
              "Authentication & Account Security Management",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Organization people/members UI – https://docs.github.com/en/organizations",
              "Authentication settings UI – https://docs.github.com/en/authentication"
            ],
            "related_data": [
              "Updated membership lists showing removed users",
              "Audit logs of 2FA policy changes and resulting membership changes"
            ],
            "notes": "This is a policy-driven form of Account Access Removal that appears superficially as security hardening."
          },
          {
            "step_id": 4,
            "description": "If the environment uses SAML/OIDC-based SSO or Enterprise Managed Users, the attacker adjusts SSO and identity mappings (for example, changing which IdP groups are authorized or altering SSO requirements) so that selected users or groups can no longer authenticate to the affected organizations.",
            "related_capabilities": [
              "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
              "Authentication & Account Security Management"
            ],
            "related_interfaces": [
              "Enterprise IAM configuration UI – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam",
              "Organization SSO settings (where applicable) – under https://docs.github.com/en/organizations"
            ],
            "related_data": [
              "SSO configuration and SAML/OIDC metadata",
              "SCIM provisioning settings and IdP group mappings"
            ],
            "notes": "These changes can cause silent lock-out for targeted identities even if their GitHub accounts still exist, because authentication is blocked at the SSO layer."
          }
        ],
        "capabilities_used": [
          "Authentication & Account Security Management",
          "Organization & Team Administration",
          "Enterprise Account & Policy Administration (GitHub Enterprise Cloud)",
          "Organizations & Enterprise Admin Service",
          "Identity & Authentication Service"
        ],
        "interfaces_used": [
          "Authentication index and security settings – https://docs.github.com/en/authentication",
          "Organization security and member settings – https://docs.github.com/en/organizations",
          "Enterprise IAM administration UI – https://docs.github.com/en/enterprise-cloud@latest/admin/managing-iam"
        ],
        "data_accessed": [
          "Org- and enterprise-level security configuration (2FA enforcement, SSO settings)",
          "Per-user 2FA enrollment status and authentication metadata",
          "SSO/SAML/OIDC configuration and SCIM mappings",
          "Organization membership lists and their current access state",
          "Audit logs of IAM and security policy changes"
        ],
        "preconditions_required": [
          "Attacker controls an organization owner or enterprise administrator account with permissions to change IAM and security policies.",
          "The compromised admin account itself is 2FA- and SSO-compliant (or exempt) so that new stricter policies do not lock the attacker out.",
          "External IdP configuration or SCIM provisioning is either also compromised or sufficiently permissive that the attacker can change GitHub-side mappings without immediate correction."
        ],
        "constraints_encountered": [
          "Tightly integrated IdP and security teams may quickly detect and roll back unexpected changes in SSO or 2FA enforcement.",
          "Some environments may already enforce 2FA and SSO universally, reducing the incremental lock-out impact of further tightening policies.",
          "Audit logs of IAM changes are typically scrutinized in mature organizations, increasing the likelihood of detection."
        ],
        "evasion_considerations": [
          "Justify changes as part of a broader security-hardening initiative, for example by adjusting policies during a legitimate compliance effort window.",
          "Roll out stricter policies to subsets of organizations or groups in phases to make lock-outs appear as individual misconfigurations rather than coordinated malicious activity.",
          "Coordinate membership removals with concurrent changes to roles and repository access (as in other vectors) to obscure the root cause of lock-out."
        ],
        "comments": "This vector relies on legitimate IAM configuration controls to remove user access under the guise of improved security. It aligns closely with Account Access Removal as seen in ransomware operations that manipulate account policies to lock out defenders.",
        "impact_achieved": "Large numbers of legitimate users, including administrators and engineers, are prevented from authenticating to GitHub organizations or enterprise resources, significantly impairing development and response capabilities."
      },
      {
        "can_achieve": true,
        "technique_name": "Account Access Removal",
        "technique_stix_id": "attack-pattern--b24e2a20-3b3d-4bf0-823b-1ed765398fb0",
        "method_steps": [
          {
            "step_id": 1,
            "description": "The attacker uses a compromised repository administrator or organization owner account in the victim environment to identify critical repositories, releases, and packages that support production systems.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Package Management with GitHub Packages",
              "Organization & Team Administration"
            ],
            "related_interfaces": [
              "Repositories UI – https://docs.github.com/en/repositories",
              "GitHub Packages UI – https://docs.github.com/en/packages"
            ],
            "related_data": [
              "Lists of repositories, their visibility, and default branches",
              "Releases and release assets",
              "Packages and versions hosted in GitHub Packages"
            ],
            "notes": "These assets often represent the authoritative source for production binaries and container images."
          },
          {
            "step_id": 2,
            "description": "For each targeted repository, the attacker deletes the repository outright or transfers ownership to another account they control, removing it from the victim’s organization.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Organization & Team Administration",
              "GitHub REST API"
            ],
            "related_interfaces": [
              "Repository settings UI (delete/transfer operations) – https://docs.github.com/en/repositories",
              "REST API for repositories – https://docs.github.com/en/rest/repos/repos"
            ],
            "related_data": [
              "Repository deletion and transfer metadata",
              "Audit logs capturing repository lifecycle changes"
            ],
            "notes": "GitHub lists deleting and transferring repositories as privileged operations; once executed, previous collaborators immediately lose access to those resources."
          },
          {
            "step_id": 3,
            "description": "Where outright deletion is not possible or would be too obvious, the attacker disables protections (for example, branch protection rules or rulesets) and force-pushes rewritten history to critical branches, overwriting tags and release branches so that previous code states become difficult to recover.",
            "related_capabilities": [
              "Repository Management & Source Code Hosting",
              "Pull Requests & Code Review Workflow"
            ],
            "related_interfaces": [
              "Branch and ruleset configuration in repository settings – https://docs.github.com/en/repositories",
              "Git operations via CLI – https://docs.github.com/en/get-started/git-basics/set-up-git"
            ],
            "related_data": [
              "Branch protection and ruleset configuration",
              "Commit history, branches, and tags",
              "Releases tied to specific commits"
            ],
            "notes": "Although primarily an integrity impact, the practical effect is also an access impact: known-good code versions are no longer readily accessible to legitimate users."
          },
          {
            "step_id": 4,
            "description": "In GitHub Packages, the attacker deletes or unpublishes key package versions (for example, container images or libraries) or alters visibility so they are no longer accessible to dependent systems.",
            "related_capabilities": [
              "Package Management with GitHub Packages"
            ],
            "related_interfaces": [
              "GitHub Packages UI – https://docs.github.com/en/packages",
              "Packages REST APIs – https://docs.github.com/en/rest/packages/packages"
            ],
            "related_data": [
              "Package and version metadata",
              "Package visibility and access control configuration"
            ],
            "notes": "Removing or hiding these artifacts can break deployments and CI/CD pipelines that depend on them."
          }
        ],
        "capabilities_used": [
          "Repository Management & Source Code Hosting",
          "Package Management with GitHub Packages",
          "Pull Requests & Code Review Workflow",
          "Organization & Team Administration",
          "GitHub REST API",
          "Repository & Git Service"
        ],
        "interfaces_used": [
          "Repositories UI – https://docs.github.com/en/repositories",
          "Git CLI / GitHub CLI – https://docs.github.com/en/get-started/git-basics/set-up-git",
          "Repository settings (delete/transfer, branch protection) – https://docs.github.com/en/repositories",
          "REST API for repositories – https://docs.github.com/en/rest/repos/repos",
          "GitHub Packages UI – https://docs.github.com/en/packages",
          "Packages REST API – https://docs.github.com/en/rest/packages/packages"
        ],
        "data_accessed": [
          "Repositories and their full commit history, branches, and tags",
          "Branch protection and ruleset configurations",
          "Releases and associated assets",
          "Packages and package versions across ecosystems",
          "Package visibility and access control settings",
          "Audit logs of repository and package lifecycle events"
        ],
        "preconditions_required": [
          "Attacker controls a repository administrator or organization owner account with permission to delete, transfer, or reconfigure repositories and manage packages.",
          "Any global environment constraints (MFA Required, SSO-Only Authentication, IP Allowlisting) are already satisfied for the compromised admin account.",
          "Defensive backup or mirroring mechanisms (for example, separate mirrors of critical repositories) are either absent or not immediately accessible to defenders."
        ],
        "constraints_encountered": [
          "Some organizations may have backup or mirroring strategies outside GitHub, allowing partial recovery even after repository deletion or history rewriting.",
          "Branch protection and rulesets may initially prevent force-pushes; the attacker must first disable or weaken those protections using their admin rights.",
          "Audit logs and security monitoring around repository deletions and transfers can make this vector noisy and quickly detectable."
        ],
        "evasion_considerations": [
          "Prefer transferring repositories to attacker-controlled accounts or organizations instead of deleting them outright to maintain plausible deniability and preserve data for later extortion.",
          "Gradually remove or rewrite less-visible repositories before targeting the most critical ones to test detection thresholds.",
          "Combine visibility changes (for example, making repositories private) with deletions to obscure what was removed and when."
        ],
        "comments": "While this behavior also aligns with Data Destruction in the broader ATT&CK model, in GitHub’s context the immediate effect is that all legitimate accounts lose access to key code and artifacts, making Account Access Removal the closest SaaS impact mapping available here.",
        "impact_achieved": "Critical source code repositories and packages are deleted, transferred, or heavily corrupted, denying legitimate users and systems access to known-good code and artifacts and potentially halting development and production deployments."
      }
    ],
    "summary": "Given GitHub’s documented capabilities, an attacker who compromises sufficiently privileged accounts can achieve significant impact under two SaaS impact techniques: Financial Theft and Account Access Removal. Financial Theft is realistically achievable by abusing metered services—primarily GitHub Actions and Codespaces—and, to a lesser extent, Copilot seat management, to drive up the victim’s bills. Account Access Removal is achievable in several powerful ways: stripping organization and repository access from users and teams; revoking or breaking the credentials, apps, and webhooks that CI/CD and automation depend on; tightening IAM policies (2FA and SSO) to lock users out; and deleting, transferring, or corrupting repositories and packages so that no accounts can access needed code and artifacts. Environment-level constraints like MFA, SSO-only authentication, IP allowlisting, and CAPTCHA mainly harden initial access rather than these impact operations; once an attacker is operating through a compromised, compliant account, GitHub’s own admin and automation features provide ample avenues to manipulate, interrupt, or destroy access to systems and data."
  }
}